<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>闲云博客</title>
	<atom:link href="http://jianyun.org/feed" rel="self" type="application/rss+xml" />
	<link>http://jianyun.org</link>
	<description>关注互联网科技，记录编程点滴</description>
	<lastBuildDate>Mon, 18 Aug 2014 09:28:52 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.1.8</generator>
	<item>
		<title>转载：IIS在各版本windows上的并发请求限制</title>
		<link>http://jianyun.org/archives/1033.html</link>
		<comments>http://jianyun.org/archives/1033.html#comments</comments>
		<pubDate>Wed, 15 Jan 2014 11:35:50 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[.Net]]></category>
		<category><![CDATA[IIS]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=1033</guid>
		<description><![CDATA[IIS 8 on Windows Server 2012 doesn’t hav &#8230; <a href="http://jianyun.org/archives/1033.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>IIS 8 on <em>Windows Server 2012 </em>doesn’t have any fixed concurrent request limit, apart from whatever limit would be reached when resources are maxed.</p>
<p>However, the client version of IIS 8, which is on Windows 8, does have a concurrent connection request limitation to limit high traffic production uses on a client edition of Windows.</p>
<p>Starting with IIS 7 (Windows Vista), the behavior changed from previous versions.  In previous client versions of IIS, excess requests would throw a 403.9 error message (Access Forbidden: Too many users are connected.).  Instead, Windows Vista, 7 and 8 queue excessive requests so that they will be handled gracefully, although there is a maximum number of requests that will be processed simultaneously.</p>
<p>Thomas Deml provided a <a href="http://blogs.iis.net/thomad/archive/2008/05/01/understanding-iis7-request-restrictions-on-windows-vista.aspx" target="_blank">concurrent request chart</a> for Windows Vista many years ago, but I have been unable to find an equivalent chart for Windows 8 so I asked <a href="http://blogs.iis.net/wadeh/" target="_blank">Wade Hilmo</a> from the IIS team what the limits are.  Since this is controlled not by the IIS team itself but rather from the Windows licensing team, he asked around and found the authoritative answer, which I’ll provide below.</p>
<p><strong>Windows 8 – IIS 8 Concurrent Requests Limit</strong></p>
<table width="514" border="0" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td valign="top" width="250"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 8 (Basic edition)</span></td>
<td valign="top" width="262"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">3</span></td>
</tr>
<tr>
<td valign="top" width="250"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 8 Professional, Enterprise</span></td>
<td valign="top" width="262"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">10</span></td>
</tr>
<tr>
<td valign="top" width="250"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows RT</span></td>
<td valign="top" width="262"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">N/A since IIS does not run on Windows RT</span></td>
</tr>
</tbody>
</table>
<p><strong>Windows 7 – IIS 7.5 Concurrent Requests Limit</strong></p>
<table width="400" border="0" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td valign="top" width="255"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 7 Home Starter</span></td>
<td valign="top" width="145"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">1</span></td>
</tr>
<tr>
<td valign="top" width="255"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 7 Basic</span></td>
<td valign="top" width="145"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">1</span></td>
</tr>
<tr>
<td valign="top" width="255"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 7 Premium</span></td>
<td valign="top" width="145"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">3</span></td>
</tr>
<tr>
<td valign="top" width="255"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows 7 Ultimate, Professional, Enterprise</span></td>
<td valign="top" width="145"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">10</span></td>
</tr>
</tbody>
</table>
<p><strong>Windows Vista – IIS 7 Concurrent Requests Limit</strong></p>
<table width="400" border="0" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td valign="top" width="259"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows Vista Home Basic (IIS process activation and HTTP processing only)</span></td>
<td valign="top" width="141"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">3</span></td>
</tr>
<tr>
<td valign="top" width="259"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows Vista Home Premium</span></td>
<td valign="top" width="141"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">3</span></td>
</tr>
<tr>
<td valign="top" width="259"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">Windows Vista Ultimate, Professional, Enterprise</span></td>
<td valign="top" width="141"><span style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: small;">10</span></td>
</tr>
</tbody>
</table>
<p>Windows Server 2003, Windows Server 2008, Windows Server 2008 R2 and Windows Server 2012 allow an unlimited amount of simultaneously requests.</p>
<p>原文：<a title="http://weblogs.asp.net/owscott/archive/2012/11/13/windows-8-iis-8-concurrent-requests-limit.aspx" href="http://weblogs.asp.net/owscott/archive/2012/11/13/windows-8-iis-8-concurrent-requests-limit.aspx" target="_blank">http://weblogs.asp.net/owscott/archive/2012/11/13/windows-8-iis-8-concurrent-requests-limit.aspx</a></p>

<div class="wp_rp_wrap  wp_rp_plain" id="wp_rp_first"><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-667" data-post-type="none" ><a href="http://jianyun.org/archives/667.html" class="wp_rp_title">各Windows系统自带什么版本的.NET Framework</a><small class="wp_rp_comments_count"> (2)</small><br /></li><li data-position="1" data-poid="in-644" data-post-type="none" ><a href="http://jianyun.org/archives/644.html" class="wp_rp_title">文件名智能排序的规则与算法</a><small class="wp_rp_comments_count"> (1)</small><br /></li><li data-position="2" data-poid="in-214" data-post-type="none" ><a href="http://jianyun.org/archives/214.html" class="wp_rp_title">给自己用的系统热键实现大小写转换工具</a><small class="wp_rp_comments_count"> (1)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/1033.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>从10个方面来提升软件开发者的效率</title>
		<link>http://jianyun.org/archives/1029.html</link>
		<comments>http://jianyun.org/archives/1029.html#comments</comments>
		<pubDate>Sat, 04 Jan 2014 12:18:13 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[杂谈]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=1029</guid>
		<description><![CDATA[Ilias Tsagklis 是电信领域的一位资深软件工程师，以软件开发者的身份 &#8230; <a href="http://jianyun.org/archives/1029.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Ilias Tsagklis 是电信领域的一位资深软件工程师，以软件开发者的身份参与了多个应用与服务的开发工作。目前，Ilias 是 PCRF 解决方案的技术领导者。他感兴趣的领域包括多层架构、中间件服务及移动开发。近日，Ilias 撰文谈到了提升软件开发者效率的 10 个提示，这些提示很具有普遍意义，希望能为各位软件工程师工作效率的提升带来帮助。</p>
<p><strong>1. 绝不要将阅读邮件作为早上的第一件事</strong></p>
<p>请千万别将阅读邮件作为早上的第一件事。如果这么做了，那么你自然而然地就处于一种被动的状态之下，而不是你希望的那种积极、主动的状态。只在每天预先设定好的时间窗内查看和回复邮件，可以在午饭前，比如说 12 点到 13 点之间，然后在 16 点左右再看一次，因为这个时候你的能量可能处于下降的趋势，查看邮件并不会导致效率的降低。别担心，那些所谓的“紧急”邮件在绝大多数时候并没有那么紧急。</p>
<p><strong>2. 如果可能就别去开会</strong></p>
<p>在企业环境下，会议是头号效率杀手。其实道理每个人都知道，只是有人不愿意承认罢了。Dave Barry 曾说过“会议让人上瘾，导致人们过于放纵，很多公司与大型组织都是习惯性开会，否则有些人可能就无事可做了”。值得注意的是，会议会导致多人效率的同时下降。如果不是那种非参加不可的会议，那就别参加了。你可以说手头还有很多事情要做（也许事实就是如此），然后在会议后问一下参会的同事，了解一下重要的内容就行。</p>
<p>如果真的有必要参加某个会议（这种情况其实并不多），那么请记住下面这些原则：</p>
<p>在下午效率下滑时开会。 一定要设定好要讨论的主题，别随意发散。 设定严格的会议结束时间，时间到了就立刻散会。 会议结束时一定要确定好清晰的下一步行动计划。</p>
<p><strong>3. 别分心</strong></p>
<p>这个话题很大。在当今这个信息时代，导致我们分心的事情比比皆是，这些事情阻碍了我们正常地完成工作。我将分心划分为两类：一是我们自己造成的，二是别人造成的。</p>
<p>首先说说第一种。看起来很奇怪吧，但实际情况却是我们自己导致自己效率下降，甚至有时都是无意识的。这种情况比比皆是：邮件、社交媒体的“重要”通知，在不同任务间频频切换，看到 Hacker News 或是 Reddit 上的有趣新闻等等。</p>
<p>你应该创造这样一种工作环境，那就是在工作时没有任何东西能够令你分心。首先关掉所有通知，比如说手机上的短信、Facebook 更新等等。接下来，退出邮件应用，如果开着的话，请确保禁用掉自动发送/接收选项。然后，不要访问任何不会提升你效率的网站。我们都是极客，我相信你应该知道如何做到这一点。你可以通过比较底层的方式来编辑机器的 hosts 文件，将 facebook.com 指向 127.0.0.1，或是使用插件来临时禁用掉这些站点。我自己使用的是 Blocksite 插件。</p>
<p>下面谈谈第二种。你可以说上面这些令你分心的情况是由其他人造成的，不过真实情况却是你自己造成的，因为没有人强迫你访问 Twitter 或是 Facebook。第二种我称为“强迫”分心。这些情况是否出现在你身上呢？比如说，你收到经理发的一封邮件，然后他问你是否收到了，诸如此类。事实上，这种分心是比较难抵御的。有些建议，比如说戴上耳机（不过有时这样也不管用）、让来电进入语音邮箱，然后再去查看，或是在 PC 上放一张纸，写上“请勿打扰，编码中”等等。你要看看哪种情况比较适合你的工作环境，然后采取相应的行动。总的目标就是让工作能够连贯下去。</p>
<p><strong>4. 前一晚准备好任务清单</strong></p>
<p>你应该在前一晚准备好一个第二天要完成的任务清单。我这里指的并不是那种巨大的清单，这样根本就没效果。相反，列出两三个重要任务即可，这应该是会对项目产生重要影响的任务。比如说：如果今天搞定这两个任务，那么我的效率就非常不错了。</p>
<p><strong>5. 先做重要的事</strong></p>
<p>如前所述，邮件绝不应该是一天当中首先要处理的事情。那什么是首先要处理的呢？当然是清单中最重要的任务了。你应该识别出最重要的任务，然后坐下来专心解决，而不要再去考虑别的事情。理想情况下，你应该一气搞定，然后休息一会，再来做第二重要的任务。</p>
<p><strong>6. 批处理并不是数据库才有的</strong></p>
<p>我相信很多人都应该很熟悉批量查询的概念。一言以蔽之，你将相似的数据库查询放在一起，然后在一个请求中发送出去，这样可以提升性能。你也可以在自己的任务中应用这条原则。也就是说，将某个任务的代价、各种开销最小化。邮件、电话以及任何重复性的工作都是批处理的最佳应用场景。</p>
<p><strong>7. 自动化</strong></p>
<p>添加到效率工具箱中的另一个东西就是自动化。作为程序员，本质上我们生活在一个相当自动化的环境中，不过我曾看到不少开发者使用手工的方式来解决本可以轻松自动化完成的事情。人类的可靠性不如机器，特别是在面对那些无聊和不太重要的事情时。请尽可能自动化你所面对的任务。比如说通过一键的方式来执行完整的应用构建，使用一个脚本将应用部署到产品服务器上。严肃地说，请不要将你的精力浪费在机器能够更快、更可靠完成的事情上。</p>
<p><strong>8. 调整工作与休息，实现效果最大化</strong></p>
<p>现在来谈谈如何创建良好的工作框架这个问题。我的建议是为工作分配特定的时间，同时为休息，或是娱乐分配特定的时间。比如说，你可以使用 45 分钟的时间进行持续、集中的工作，然后花 15 分钟休息一下，看看社交媒体更新情况，阅读一些文章等。在休息时就别再盯着屏幕看了。久坐是非常不好的习惯，适当地站起身，走一走。</p>
<p><strong>9. 将事情记录下来</strong></p>
<p>将一切都记录下来。无论是新想法，还是新的做事方式，要知道，大脑有时是不可靠的，你需要将这一切记录下来才行。你可以将大脑看作是一个 CPU，分配给它的东西就好比是在后台启动的进程。有时，进程会挂起，不能正常工作。将事情记录下来则会解放大脑，可以让其以更加优化的方式执行任务。</p>
<p><strong>10. 利用心流，专心工作</strong></p>
<p>这是个圣杯，正是我们通过恰当地设计工作框架而要实现的东西，也是前面那些提示所要实现的终极目标。我敢肯定你经历过“心流”的状态，这指的是你的思维完全专注的一段时间，聚焦于特定的任务或是难题，甚至忘记了时间的流逝。头脑中除了编码，没有其他的东西存在。外部刺激也不会令你分心。你需要将自己置身于能够实现心流的状态下，尽量保持更长的时间，这将极大提升你的生产率，我敢肯定你会非常喜欢这种状态，为什么不让自己尝试一下进入这种状态呢？</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-183" data-post-type="none" ><a href="http://jianyun.org/archives/183.html" class="wp_rp_title">郎咸平:中国99%白领要破产, 还买房子干嘛</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-667" data-post-type="none" ><a href="http://jianyun.org/archives/667.html" class="wp_rp_title">各Windows系统自带什么版本的.NET Framework</a><small class="wp_rp_comments_count"> (2)</small><br /></li><li data-position="2" data-poid="in-843" data-post-type="none" ><a href="http://jianyun.org/archives/843.html" class="wp_rp_title">给博客换了个主题</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/1029.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>源代码管理十诫</title>
		<link>http://jianyun.org/archives/1008.html</link>
		<comments>http://jianyun.org/archives/1008.html#comments</comments>
		<pubDate>Tue, 05 Mar 2013 13:09:36 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=1008</guid>
		<description><![CDATA[英文原文：The 10 commandments of good source  &#8230; <a href="http://jianyun.org/archives/1008.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>英文原文：<a href="http://www.troyhunt.com/2011/05/10-commandments-of-good-source-control.html" target="_blank">The 10 commandments of good source control management</a></p>
<p>若是还有可以毫无偏见地涉及各个编程语言，比源代码管理软件更必要的工具，我倒是很想见识一下。源代码管理软件是我们工作的必备工具，是许多开发团队的血液。那为什么我们都会对它有所误解呢？为什么都很难理解版本控制系统的核心价值和基本原理呢？</p>
<p>我总结出 10 条惯例——如果你愿意也可以用“戒律”——意味着必须服从它而且从一开始很难去理解。它们与所有类型编程语言的版本控制软件都有关联。在这里我选取了 Subversion 和 .NET 的几个例子，不过它们也广泛地适用于其他的一些技术。</p>
<p><strong>第一诫.如果你现在还在使用 VSS－请立刻停手</strong></p>
<p>它已经死了。当然不完全对，它也存活了许多年，被全新的更实用的源代码管理工具超越之后还在苟延残喘地活着。准确地说当微软<a href="http://support.microsoft.com/lifecycle/search/default.aspx?alpha=Visual+SourceSafe" target="_blank">几个月后不再为其提供支持时</a>(还是会坚持一段时间的)，它才是真的死了。</p>
<p>平心而论，VSS 还是一个不错的工具。在 1995 年，它的光芒被像 Subversion 这样类似于 Git 和 Mercurial 的分布式软件给遮盖住了。微软表示要取代它已经好多年了。</p>
<p>原因是因为不支持如今的标准所导致的一系列缺陷使它一直不被看好。众所周知它是<a href="http://www.highprogrammer.com/alan/windev/sourcesafe.html" target="_blank">微软的悲剧系统</a>，但不知何故它能坚持这么久，尽管它有那么多小故障，缺陷，并且不包含必需的功能（相对于今天的标准）。</p>
<p><a href="http://jianyun.org/?attachment_id=1009" rel="attachment"><img class="aligncenter size-full wp-image-1009" title="05143956-e60720c4fab043408e429189f85da6e5" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-e60720c4fab043408e429189f85da6e5.jpg" alt="" width="175" height="174" /></a></p>
<p><a href="http://jianyun.org/?attachment_id=1010" rel="attachment"><img class="aligncenter size-full wp-image-1010" title="05143956-22a14efe6dc542bca5125cb0505d1bc6" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-22a14efe6dc542bca5125cb0505d1bc6.jpg" alt="" width="236" height="173" /></a></p>
<p><strong>第二诫.如果代码没放在源代码管理软件里，等于它不存在</strong></p>
<p>每天重复读这句话——“使用源代码管理软件是唯一的有效措施”。除非你在工作时使用项目的源代码管理库来控制代码版本——否则代码等于没有存在过。</p>
<p>显然你曾发觉在你的本地机器上运行良好的代码在其他人那里运行的效果并不理想。是不是？他们不能获取你的最新版本，他们没法去归并代码文件，你没有正确地部署它（参考 <a href="http://www.troyhunt.com/2010/11/you-deploying-it-wrong-teamcity.html" target="_blank">you&#8217;re deploying it wrong</a>）而且如果你的 SSD 硬盘坏了的话你将永远地失去你的劳动成果。</p>
<p>只要你保持这个心态——代码只有提交后才是真的安全，才是其他良好编程习惯的保障。你可以把你的任务划分成许多很小的单元以便你逐一提交。你需要频繁地这么做。你就不必担心你的硬件会不会出棘手问题。</p>
<p>不过更重要的意义是（至少对于你的团队领导来说），通过源代码管理软件可以看到你做了什么。使用图表并列出项目清单是个好方法，不过怎么知道他们实际上在做些什么？而使用源代码管理软件进行工作就能看得一清二楚了。</p>
<p><strong>第三诫.要早提交，常提交，并且不要觉得麻烦</strong></p>
<p>关于前面那点，避免“幻影代码”（就是只能在你的机器上看到的代码）的唯一方法是经常提交你的任务并且不要觉得麻烦。它可以解决你的问题，不过这样做也会对你的工作产生其他的影响：</p>
<p>1. <strong>每个提交的修订都会为你提供一个还原点。</strong>如果你完全把代码搞砸了（没骗你，我们都这么做过），你是希望恢复到一个小时前的工作还是一周前的工作？</p>
<p>2. <strong>归并文件时会出现的危险会随着时间不断增加。</strong>归并文件一直很麻烦。如果你不是每天都保持提交代码，某一天你会突然发现你和其他人的更改内容会有 50 多个冲突。你不会为此感到高兴的。</p>
<p>3. <strong>它促使你把任务分离成分散的单元。</strong>通常人们都是快完成的时候才提交的，因为他们想把代码做成一个完整的逻辑单元模块。不过庞大的任务不可避免地要分离出较小的分散功能，而频繁地提交它们会使你更了解它们，你可以一个个地构建并提交。</p>
<p>如果你做到这些，你的提交历史不可避免地开始类似于一种半规律的样式，里面每个工作日都是在提交任务。当然不总是这样，也有停下来重构或测试，或者其他合理的活动也会中断标准的开发周期。</p>
<p>然而，当我在看一个独立的——尤其是完整的项目时，每当发现我们在一个标准的开发周期里，有一天或几天什么都没有做，我便会非常担忧。我之所以担忧是因为这意味着什么地方出问题了。一般不是有人正在想方设法要把问题搞定的话，就是因为卡在某个问题上而导致项目完全没有进度。无论到底是什么情况，源代码管理软件都会告诉你出现问题了。</p>
<p><strong>第四诫.提交前要检查你更改了什么</strong></p>
<p>往源代码管理软件里提交代码的步骤其实非常简单。（你恐怕会困惑上一条为什么说的那么麻烦。）一般只要发现文件内容有变更时都会不顾后果地把文件传上去。像这样——“我的项目根目录下有文件内容变更了，我要快点提交上去！”</p>
<p>如此会发生一件（或两件）事情：首先，程序员会没有意识地把目录下的垃圾代码文件也上传上去。一些人看到类似下面的窗口时，就会点击“选择全部”然后提交——这样源仓库里就会被本不应该存在的未调试的文件和其他垃圾文件给弄乱。</p>
<p><a href="http://jianyun.org/?attachment_id=1011" rel="attachment"><img class="aligncenter size-full wp-image-1011" title="05143956-99368c52bb8b4b1fad92be3c2ee84ba8" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-99368c52bb8b4b1fad92be3c2ee84ba8.png" alt="" width="620" height="497" /></a></p>
<p>或者是，程序员实际上并没有检查他们更改过什么就把文件上传了。当你在工作中处理配置文件或项目定义文件时很容易就不经意把那些不想提交的文件给上传了，而且那些文件很可能就被别的程序员用到了。你真的会记住你在配置文件里的所有更改吗？</p>
<p><a href="http://jianyun.org/?attachment_id=1012" rel="attachment"><img class="aligncenter size-full wp-image-1012" title="05143956-8b458aa7ce474dba848a682186912cd8" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-8b458aa7ce474dba848a682186912cd8.png" alt="" width="620" height="496" /></a></p>
<p>解决方法很简单：<strong>你必须在提交前立刻检查你改过什么地方。</strong>做起来其实比听起来还要容易。使用许多系统已经提供的“忽略”特性可以大幅度地减轻“不经意上传文件”的危险。你可以忽略 Thumbs.db 文件因为你压根不想上传它。你在每次修订后可能还有其他文件不想上传——那么就忽略掉它们吧！</p>
<p>至于文件里的更改，你通常可以使用某个流行的文本比较工具来观察差异。为什么我又要上传一次 Web.config 文件呢？</p>
<p><a href="http://jianyun.org/?attachment_id=1013" rel="attachment"><img class="aligncenter size-full wp-image-1013" title="05143956-81cbb1e60e8544898d191794ffde0a36" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-81cbb1e60e8544898d191794ffde0a36.png" alt="" width="620" height="361" /></a></p>
<p>噢，我想起来了，我想把尝试密码失败的最大次数从 5 次减少到 3 次。啊，我差点没注意把一个虚拟的登录页面给上传上去了。这种在提交前做检查的练习可以让你更容易理解下一节的内容。</p>
<p><strong>第五诫.写提交信息时一定要认真</strong></p>
<p>这是一个古老的谚语（出处不详），大意是说“写每一条提交信息时就好象等下会读到它的人是一个斧头杀人狂，而且他还知道你住在哪里”。如果我是那个杀人狂并在研究你的代码想追踪 bug 的话，看到的提交信息全部都是“代码更新了”，小心，我会来砍你的！</p>
<p><strong>我的解决办法就是解释清楚为什么要提交新的代码。</strong>每次你对代码进行更改都是有原因的。可能什么地方会崩溃。可能客户不喜欢现在的主题颜色。可能你仅仅要调整一下构建配置。无论是什么，这都是有原因的而且你要把原因用文字保留下来。</p>
<p>为什么？这样做的原因有很多，而且在不同环境下各不相同。举个例子，使用“归属”特性或其他类似的功能显示出谁改了代码那些地方。如果我不记得 18 个月之前我对项目的 Web.config 文件改过什么地方或者我为什么要改动应用程序的设置，是因为我没有在当时留下一个适当的提交信息，而现在会非常简单：</p>
<p><a href="http://jianyun.org/?attachment_id=1014" rel="attachment"><img class="aligncenter size-full wp-image-1014" title="05143956-c138ee90fdfa4bf4a0bd71f018238f97" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143956-c138ee90fdfa4bf4a0bd71f018238f97.jpg" alt="" width="620" height="421" /></a></p>
<p>这是一个可以随时观察代码更改的软件的一种。无论我像下面那样想了解一个文件的完整更改历史，还是只想知道团队昨天做了什么，留下一个描述性的相关记录意味着只要不经意一瞥就能知道是什么情况了。</p>
<p><a href="http://jianyun.org/?attachment_id=1015" rel="attachment"><img class="aligncenter size-full wp-image-1015" title="05143957-cf3f54a4a10f4e7898d54976c38ded66" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143957-cf3f54a4a10f4e7898d54976c38ded66.jpg" alt="" width="620" height="205" /></a></p>
<p>最后强调一下，当调试遇到错误时提交信息的重要性是无法估计的。举个例子，在你的集成环境里的最后更新的地方可以找到出错的原因。我的例子是非常显而易见的，不过把信息表示出来可以把很多棘手的问题变得极好解决。</p>
<p><a href="http://jianyun.org/?attachment_id=1016" rel="attachment"><img class="aligncenter size-full wp-image-1016" title="05143957-9baf96806366477ab498c55228d70ec9" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143957-9baf96806366477ab498c55228d70ec9.jpg" alt="" width="620" height="124" /></a></p>
<p>把这条牢记于心，这里列出一些提交信息的反面教材：</p>
<p>1. 可恶</p>
<p>2. 能跑了</p>
<p>3. 解决了一些混帐问题</p>
<p>4. 解决了</p>
<p>5. 改进了一点 bug</p>
<p>6. 上传了</p>
<p>7. 排字错误</p>
<p>8. 修订 1024</p>
<p>好的，我从 Stack Overflow 网站的<a href="http://stackoverflow.com/questions/909338/what-is-the-worst-commit-message-you-have-ever-authored" target="_blank">哪些是你写过的最差劲的提交信息</a>（译者注：帖子已经被删除了，原因难道是出现了脏话？）帖子里选取了以上内容，不过它们和我以前看过的提交信息并不相同。它们没有告诉你有关代码更改的任何有效信息；它们都是垃圾信息。</p>
<p>关于提交信息最后要注意的是；<strong>同一个程序员之后提交信息绝不能和前面的完全相同。</strong>原因很好理解：你向源代码管理软件提交文件是因为对于上一个版本的代码有东西改变了。你现在的代码和之前的已经不一样了，如果你的提交信息是完整准确的，理论上就不能和前面的相同。如果是相同的（可能有时真的会这样），日志就会难以阅读，因为没有办法区分两条提交有什么区别。</p>
<p><strong>第六诫.你必须自己提交你的更改内容——不能委托他人</strong></p>
<p>听起来很奇怪，但它的确会发生，我看过不止一次，最近的是上周。情况是这样的，源代码库被视为极高的地位。因为很多原因，团队会去追求完美代码的洁净和单一。为了保持这种神圣的状态，代码只能由某个领头的程序员来提交，他在提交前会小心地整合，审查并（大概会）调整改善代码。</p>
<p>即使站在很远也能很容易评价这个方案。不太频繁的提交（可能一周几次），只有一个脱离团队其他程序员的人来提交，而且不可避免地在这段漫长的无提交时期里会有人的工作会导致项目混乱。非常非常不好。</p>
<p>这样做会有两个错误：首先，源代码管理软件并不意味着它里面代码是神圣不可侵犯的；至少在整个开发周期里是这样的。它应该是团队频繁整合文件，在出错时还原到正常并且共同解决问题的地方。不是自始至终都要这样做，只有在应用程序周期的发布时期为了达到某种状态时才做的。</p>
<p>另一个问题——并且真的是极为关键的——站在程序员的视角，<strong>这样等于你压根没有在用源代码管理软件！</strong>它等于没有同伴之间的代码整合，没有还原，提交信息没有负责人，什么都没有！你们仅仅是在自己的象牙塔里各自写各自的代码然后等着未来顺便某一天把它交给领导就完事了。</p>
<p>不要这样做。千万不要。</p>
<p><strong>第七诫.一定要管理好数据库的版本</strong></p>
<p>这一点是我们都知道必须要做的，但是很多人觉得它麻烦。问题是很多（或者是大部分）应用程序没了数据库就不能运行。如果你没有管理好数据库，那你实际上做的就是一个不完整的完全无用的应用程序。</p>
<p>几乎所有的版本控制系统的工作就是管理好文件系统内的文件。它只是对像 HTML 页面，图片，CSS，项目配置文件和其他在文件系统的独立单元这类典型应用作用较大。问题是它确实没法在与程序有关联的数据库上起到作用。你总不能替换掉庞大的数据库，把所有旧数据文件和包含一大堆对象和数据日志文件统统换掉。这样会让版本控制系统完全乱成一堆。</p>
<p>Red Gate 公司开发的智能的 <a href="http://www.red-gate.com/products/sql-development/sql-source-control/" target="_blank">SQL Source Control</a> 使这个情况得到了合理解决。我在去年写的<a href="http://www.troyhunt.com/2010/07/rocking-your-sql-source-control-world.html" target="_blank">Rocking your SQL Source Control world with Red Gate</a> 这篇帖子里详细说明了这款软件，所以我现在就不多说了；总之就是<strong>数据库管理现在会非常容易了！</strong></p>
<p>老实说，如果你没有管理好你的数据库版本，你的开发会伴随着很大的问题。在更改数据库的时候没有源代码的管理，没有还原点，并且很难和团队密切合作。使用数据库版本控制系统可以使开发更轻松。</p>
<p><strong>第八诫.编译生成的文件不要放进源代码管理软件里</strong></p>
<p>简单地说：在编译运行项目时自动生成的结果文件不要放进源代码管理软件里。对于 .Net 开发的程序员，主要是&#8221;bin&#8221;和&#8221;obj&#8221;文件夹里通常会出现的 .dll 和 .pdb 文件。</p>
<p>为什么？因为如果你这样做，你的同事会恨你的。这意味着每当他们从版本控制系统里取下最新文件时会让你的编译文件覆盖掉他们的。这是一个双重噩梦（你绝不能这样做），在他们下一次编译时就会出问题。而且只要他们重新编译后再把编译文件重新上传上去，同样的问题会以相反的方向再发生一次，不过这次你是受害者。你肯定不想这样的。</p>
<p>当然另一个问题就是这样做很浪费。这会浪费源代码管理服务器的硬盘空间，会浪费带宽并会通过网络发送时一直潜伏着，而且这样做造成的不可避免的冲突会极度浪费你的时间。</p>
<p>所以我们继续使用之前提到的“忽略”方案。只要把像&#8221;bin&#8221;和&#8221;obj&#8221;这样的路径直接忽略掉，一切就真的很轻松了。只要按照这种方法做一次，所有人都会感到开心的。</p>
<p>其实我在写 <a href="http://www.troyhunt.com/2010/02/creating-subversion-pre-commit-hooks-in.html" target="_blank">pre-commit hooks</a> 时就说到了在版本控制的服务器上不能提交此类文件。当然如果有值得这么做的原因的话，只有这种情况下你可以上传。不过我倾向于不要这么做以免将来会导致某个人在更新时发生冲突。</p>
<p><strong>第九诫.不要上传你自己的用户设置</strong></p>
<p>老实说，我认为很多人没有注意到他们把自己的私人设置文件上传到源代码管理软件里了。这样会出现的问题是：许多工具会产生只管理你自己本地配置的文件。它们只对你有用而且通常和其他人的私人设置文件相异。如果你把它们上传到源代码管理软件里，很快你就会覆盖掉其他人的私人设置文件。这样并不好。</p>
<p>这是一个典型的 .NET 程序的例子：</p>
<p><a href="http://jianyun.org/?attachment_id=1017" rel="attachment"><img class="aligncenter size-full wp-image-1017" title="05143957-5f02430de9e447ef9c21c587041a454a" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143957-5f02430de9e447ef9c21c587041a454a.jpg" alt="" width="605" height="170" /></a></p>
<p>假如你没有立刻清理的话，多余出来的就是扩展文件和类型描述，也就是 .ReSharper.user 文件和 .suo（Solution User Option， 解决方案用户选项）两个文件，它们只属于你，对其他人无效。我们要再次使用忽略方案来处理。</p>
<p><strong>第十诫.附属文件也要集成在一起</strong></p>
<p>这是十诫中的最后一条也是最最重要的一条。当应用程序需要外部的附属文件存在才可以正常运行的话，<strong>把那些文件也都放进源代码管理软件里！</strong>人们倾向于犯的错误是，在他们拥有自己设置文件和本地附属文件的环境里一切都表现得很好就把东西都上传了，之后觉得没问题了就不管了。但是其他人不能从源代码库里找到同样的附属文件的话，所有东西都会悲剧性地报错。</p>
<p>我想到这点是因为今天从源代码库里拖出某个旧项目并运行它时出现了这样的画面：</p>
<p><a href="http://jianyun.org/?attachment_id=1018" rel="attachment"><img class="aligncenter size-full wp-image-1018" title="05143957-b5268384a2f04f7ab937c1543f5ec5f7" src="http://jianyun.org/wordpress/wp-content/uploads/2013/03/05143957-b5268384a2f04f7ab937c1543f5ec5f7.jpg" alt="" width="620" height="252" /></a></p>
<p>我以为 NUnit 一直在机器上，但这次没有。幸运的是使用 <a href="http://nuget.codeplex.com/" target="_blank">NuGet</a> 可以快速解决问题，但是没有附属文件的话，不是每次都可以用同样的方式就能轻松解决的。有些情况下，它们并不是公开的，你很难全部都获取到。</p>
<p>我从源代码管理软件里取出的项目运行时之所以会报错是因为我发现&#8221;C:\Program Files&#8230;&#8221;路径下丢失了附属的文件。我花了不少时间用来联系最后更改过它的那个人（很明显他在世界上另一个很远的地方），获取了那个文件，把它放进&#8221;Libraries&#8221;文件夹下并把它上传到了版本控制系统里，这样下一个提取文件的人就不需要再这么麻烦了。</p>
<p>当然另一个重要的原因是，如果你在任何一种集成环境里工作时，你的构建服务器不一定安装了那些库。你必须有那些文件才能运行。Doug Rathbone 最近写了一篇很好的关于这点的文章 <a href="http://www.diaryofaninja.com/blog/2011/03/27/continuous-integration-ndash-itrsquos-all-about-your-build-projects-ecosystem" target="_blank">Third party tools live in your source control</a> (源代码管理软件里的第三方工具)。并不是非要那样做（我们也善意地评价了效果），不过它确实是一个很方便的建议。</p>
<p>因此推荐每个人第一天就把程序运行所需要的东西全都放进版本控制系统里。</p>
<p><strong>总结</strong></p>
<p>没有哪一条是很难理解的。老实说，它们都很基础：尽快并频繁地提交，确认你提交的东西改了什么，还有东西一定要放进版本控制系统里，解释清楚你的提交信息和确保是你自己提交的，不要忘记数据库和不要忘记附属文件。还有就是不要使用 VSS:)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-991" data-post-type="none" ><a href="http://jianyun.org/archives/991.html" class="wp_rp_title">使用HTML5开发离线应用</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-1033" data-post-type="none" ><a href="http://jianyun.org/archives/1033.html" class="wp_rp_title">转载：IIS在各版本windows上的并发请求限制</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-964" data-post-type="none" ><a href="http://jianyun.org/archives/964.html" class="wp_rp_title">CAT.NET简介</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/1008.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTC One S刷回官方RUU的详细教程</title>
		<link>http://jianyun.org/archives/1004.html</link>
		<comments>http://jianyun.org/archives/1004.html#comments</comments>
		<pubDate>Sat, 09 Feb 2013 13:37:43 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[杂谈]]></category>
		<category><![CDATA[HTC]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=1004</guid>
		<description><![CDATA[大家手头的机子如果解锁，刷了第三方的ROM，想升级到最新4.1.仍需要完成以下步 &#8230; <a href="http://jianyun.org/archives/1004.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p><span style="font-size: large;">大家手头的机子如果解锁，刷了第三方的ROM，想升级到最新4.1.仍需要完成以下步骤！<br />
本教程针对的是没有S-OFF的机型，且已经官方解锁的，如果S-OFF的完全可以无视这个！</span></p>
<p><span style="font-size: large;">一、下载RUU</span></p>
<p>切记，这个RUU必须与你手机匹配，比如你的机子是欧版的，那你这个RUU必须是欧版的！</p>
<p>还有一点：升级只能的同级别或更高级别的升级，不能降级，比如欧版以前固件是1.26的，只能刷1.26的RUU，或者最新1.28、1.29、2.17的RUU，但当你刷完1.28以上的RUU就不能刷1.26的RUU了！也就是说不能降级！当然可以平级刷1.28的RUU!<br />
<span style="font-size: large;"><br />
</span>所以首先搞清楚自己机型是哪个国家、地区版的，依照销售地来划分（可不是生产地啊）查询方法：</p>
<p><span style="font-size: large;">查询手机销售地方法：<br />
点击进入</span><span style="color: #0000ff;">http://www.chahtc.com/imei.php?from=ctop</span><span style="font-size: large;">；输入手机的IMEI码！</span></p>
<p>查询手机的IMEI码方法：<br />
（1）拨号界面下  *#*#4636#*#*<br />
（2）手机设置-关于-设备信息</p>
<p>或者登陆：<span style="color: #0000ff;">http://htc.3rdchannel.com.tw/HTC-IMEIQuery/IMEIQuery.aspx?ct=zh-CN</span></p>
<p>输入iemi 、sn即可！同时显示销售地和生产日期！</p>
<p><span style="font-size: large;"><br />
</span><br />
<span style="font-size: large;">找到自己的机型版本后，就要找对应的地区的RUU，然后下载，保存在电脑上！建议下载最新的RUU,这样才能保证手机上可以正常刷入！<br />
</span></p>
<p><span style="font-size: large;">二、加锁<br />
如果你已经官方解锁的话，想升级官方更高版本需要先进行加锁，也就是unlock变为relocked！</span><br />
<span style="font-size: large;">两种方法:<br />
</span><br />
<span style="font-size: large;">(一)现在网上很流行一键回锁的，不多说了，越傻瓜式的，问题会越多，当然你能用一键回锁那最好.</span><br />
<span style="font-size: large;">(二)在fastboot usb 下使用CMD，命令为 fastboot oem lock 回车(前提有ADB工具,方法自己找)</span><br />
<span style="font-size: large;">检查自己手机HBOOT下，最上面一行是否变为  RELOCKED ；如果是那就完成了上锁！有时候上锁后是无法进入手机系统的，只能停留在hboot界面！</span><br />
<span style="font-size: large;">三、刷ruu</span><br />
<span style="font-size: large;">手机fastboot usb界面下，双击电脑上下载的ruu即可！记住RUU是.exe文件！<br />
<span style="font-size: large;">刷RUU前后需要10-20分钟左右，切记刷的过程中不要断电、或者断开USB连接线！因此建议最好用笔记本刷！</span></span></p>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-124" data-post-type="none" ><a href="http://jianyun.org/archives/124.html" class="wp_rp_title">搭载Windows Phone 7 的HTC 舒伯特（Schubert）真机视频被泄露</a><small class="wp_rp_comments_count"> (2)</small><br /></li><li data-position="1" data-poid="in-367" data-post-type="none" ><a href="http://jianyun.org/archives/367.html" class="wp_rp_title">一篇轰动全国的猛文《一名大学毕业生的反思》：中国的未来可能就败在这上面</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-843" data-post-type="none" ><a href="http://jianyun.org/archives/843.html" class="wp_rp_title">给博客换了个主题</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/1004.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTML5之File API</title>
		<link>http://jianyun.org/archives/997.html</link>
		<comments>http://jianyun.org/archives/997.html#comments</comments>
		<pubDate>Wed, 23 Jan 2013 03:11:13 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[HTML5]]></category>
		<category><![CDATA[JavaScript]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=997</guid>
		<description><![CDATA[HTML5 File API的设计初衷，是改善基于浏览器的Web应用程序处理文件 &#8230; <a href="http://jianyun.org/archives/997.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>
    HTML5 File API的设计初衷，是改善基于浏览器的Web应用程序处理文件上传的方式，使文件直接拖放上传成为可能。草案定义了新的输入选项 ﹤input type=”file”﹥ 来处理文件上传。更为惊喜的是，该API为开发者提供了一个关联上传数据，并显示上传进度和其他信息的方法。
</p>
<h2>
    什么是File API<br />
</h2>
<p>
    File API 提供了在 Web Application 客户端表现和操作文件对象的 API, 以及可编程的选择文件和访问它们的数据。包括：
</p>
<ul style="list-style-type:disc;">
<li>
<p>
            FileList: File对象的一个类似数组的序列。(想象一下多文件上传或者直接从桌面系统拽一个文件夹的情形)
        </p>
</li>
<li>
<p>
            File: 表示 FileList 中的一个单独的文件；提供了诸如文件名，文件大小，mimetype，以及一个到文件句柄的引用。
        </p>
</li>
<li>
<p>
            Blob: 表示可变的原始数据。提供了可以把数据按字节区间切片成更小块的原始数据的方法。还提供了表示数据块大小的属性。File接口是从这个接口继承的。
        </p>
</li>
<li>
<p>
            FileReader: 可以把 File 或者 Blob 对象读进内存，并且可以使用进度事件和进度处理器属性访问这些 Files 或者 Blobs 的数据。
        </p>
</li>
</ul>
<h2>
    使用 Input 表单元素选择文件<br />
</h2>
<pre class="brush:html;toolbar:false;">
&lt;input type="file" id="files" name="files[]" multiple /&gt;
&lt;output id="list"&gt;&lt;/output&gt;
</pre>
<pre class="brush:js;toolbar:false;">
function handleFileSelect(evt) {
  var files = evt.target.files;
  var output = [];
  for (var i=0, f; f = files[i]; i++) {
    output.push('&lt;li&gt;&lt;strong&gt;', escape(f.name), 
    '&lt;/strong&gt; (', f.type || 'n/a', ') -', 
      f.size, ' 字节, 最后修改: ', 
      f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a', '&lt;/li&gt;');
  }
    document.getElementById('list').innerHTML = '&lt;ul&gt;' + output.join('') + '&lt;/ul&gt;';
}
document.getElementById('files').addEventListener('change', handleFileSelect, false);
</pre>
<h2>
    使用拖拽方式选择文件<br />
</h2>
<pre class="brush:html;toolbar:false;">
&lt;div class="example"&gt;
  &lt;div id="drop-zone"&gt;把文件拖拽到这里&lt;/div&gt;
  &lt;output id="list2"&gt;&lt;/output&gt;
&lt;/div&gt;
</pre>
<pre class="brush:js;toolbar:false;">
function handleFileSelect2(evt) {
  evt.stopPropagation();  
  evt.preventDefault();
  var files = evt.dataTransfer.files;  
  var output = [];
  for (var i=0, f; f = files[i]; i++) {
    output.push('&lt;li&gt;&lt;strong&gt;', escape(f.name), '&lt;/strong&gt; (', f.type || 'n/a', ') -', 
      f.size, ' 字节, 最后修改: ', f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a', '&lt;/li&gt;');
  }
  document.getElementById('list').innerHTML = '&lt;ul&gt;' + output.join('') + '&lt;/ul&gt;';
}
                  
function handleDragOver(evt) {
  evt.stopPropagation();  
  evt.preventDefault();
  evt.dataTransfer.dropEffect = 'copy';
}
var dropZone =  document.getElementById('drop-zone');
dropZone.addEventListener('dragover', handleDragOver, false);
dropZone.addEventListener('drop', handleFileSelect2, false);
</pre>
<h2>
    FileReader<br />
</h2>
<p>
    FileReader 包含四种异步读取文件的方式：
</p>
<ul style="list-style-type:disc;">
<li>
<p>
            FileReader.readAsBinaryString(Blob|File) &#8211; result 属性包含的是 file/blob 的二进制字符串形式的数据。每个字节由一个 0-255 的整数表示。
        </p>
</li>
<li>
<p>
            FileReader.readAsText(Blob|File, opt_encoding) &#8211; result 属性包含的是以文本方式表示的 file/blob 数据。默认情况下，字符串以&#39;UTF-8&#39;编码方式解码。使用 opt_encoding 参数可以指定一个不同的格式。
        </p>
</li>
<li>
<p>
            FileReader.readAsDataURL(Blob|File) &#8211; result 属性包含的是以<a href="http://http://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank">data URL</a>编码的 file/blob 数据。
        </p>
</li>
<li>
<p>
            FileReader.readAsArrayBuffer(Blob|File) &#8211; result属性包含的是以ArrayBuffer对象表示的 file/blob 数据。
        </p>
</li>
</ul>
<p>
    一旦这些read方法被调用，onloadstart, onprogress, onload, onabort, onerror, onloadend 就可以被用来追踪进度。
</p>
<h3>
    readAsDataURL示例<br />
</h3>
<pre class="brush:js;toolbar:false;">
function handleFileSelect3(evt) {
  var files = evt.target.files;
  for (var i=0, f; f = files[i]; i++) {
    if (!f.type.match('image.*')) {
      continue;
    }
    var reader = new FileReader();
    reader.onload = (function(theFile) {
        return function(e) {
          // Render thumnial
          var span = document.createElement('span');
          span.innerHTML = ['&lt;img class="thumb" src="', e.target.result,
          '" title="', escape(theFile.name), '"/&gt;'].join('');
          document.getElementById('thumbnails').insertBefore(span, null);
        };
      })(f);
    reader.readAsDataURL(f);    
  }
}
</pre>
<h2>
    文件切片<br />
</h2>
<p>
    File 接口提供了 slice 方法支持把文件切成不同的片段，第一个参数是起始的字节数，第二个参数是结束的字节数，还有一个可选的内容类型字符串可以作为第三个参数：
</p>
<pre class="brush:js;toolbar:false;">
var blob = file.slice(startingByte, endingByte);
reader.readAsBinary(blob);
</pre>
<h3>
    slice示例<br />
</h3>
<pre class="brush:html;toolbar:false;">
&lt;div class="example"&gt;
    &lt;input type="file" id="files4" name="file4" /&gt; 读取字节数: 
    &lt;span class="readBytesButtons"&gt;
      &lt;button data-startbyte="0" data-endbyte="79"&gt;1-80&lt;/button&gt;
      &lt;button data-startbyte="99" data-endbyte="149"&gt;100-150&lt;/button&gt;
      &lt;button data-startbyte="9" data-endbyte="19"&gt;10-20&lt;/button&gt;
      &lt;button&gt;整个文件&lt;/button&gt;
    &lt;/span&gt;
    &lt;div id="byte_range"&gt;&lt;/div&gt;
    &lt;div id="byte_content"&gt;&lt;/div&gt;  
&lt;/div&gt;
</pre>
<pre class="brush:js;toolbar:false;">
function readBlob(opt_startByte, opt_stopByte) {
  var file = document.getElementById('files4').files[0];
  var start = parseInt(opt_startByte) || 0;
  var stop = parseInt(opt_stopByte) || file.size - 1;
  var reader = new FileReader();
  reader.onloadend = function(evt) {
    if (evt.target.readyState == FileReader.DONE) {
      document.getElementById('byte_content').textContent = evt.target.result;
      document.getElementById('byte_range').textContent = 
          ['Read bytes: ', start + 1, ' - ', stop + 1,
           ' of ', file.size, ' byte file'].join('');
    }
  };
        
  var blob = file.slice(start, stop + 1);
  reader.readAsBinaryString(blob);
}
</pre>
<pre class="brush:js;toolbar:false;">
document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
    if (evt.target.tagName.toLowerCase() == 'button') {
        var startByte = evt.target.getAttribute('data-startbyte');
        var endByte = evt.target.getAttribute('data-endbyte');
        readBlob(startByte, endByte);
    }
}, false);
</pre>
<h2>
    监视文件读取进度<br />
</h2>
<p>
    可以使用 onloadstart 和 onprogress 事件来监视读取进度。
</p>
<pre class="brush:html;toolbar:false;">
&lt;div class="example"&gt;
    &lt;input type="file" id="files5" name="file5" /&gt;
    &lt;button id="abort-read"&gt;停止读取&lt;/button&gt;
    &lt;div id="progress_bar"&gt;&lt;div class="percent"&gt;0%&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
<pre class="brush:js;toolbar:false;">
var reader;
var progress = document.querySelector('.percent');
   
function abortRead() {
    reader.abort();
}
   
function errorHandler(evt) {
    switch(evt.target.error.code) {
        case evt.target.error.NOT_FOUND_ERR:
            alert('文件不存在!');
            break;
        case evt.target.error.NOT_READABLE_ERR:
            alert('文件不可读!');
            break;
        case evt.target.error.ABORT_ERR:
            break; // noop
        default:
            alert('出错啦!');
    };
}
   
function updateProgress(evt) {
    // evt is an ProgressEvent.
    if (evt.lengthComputable) {
        var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
        // Increase the progress bar length.
        if (percentLoaded &lt; 100) {
            progress.style.width = percentLoaded + '%';
            progress.textContent = percentLoaded + '%';
        }
    }
}
   
function handleFileSelect5(evt) {
    // Reset progress indicator on new file selection.
    progress.style.width = '0%';
    progress.textContent = '0%';
   
    reader = new FileReader();
    reader.onerror = errorHandler;
    reader.onprogress = updateProgress;
    reader.onabort = function(e) {
        alert('文件读取操作被取消');
    };
    reader.onloadstart = function(e) {
        document.getElementById('progress_bar').className = 'loading';
    };
    reader.onload = function(e) {
        // Ensure that the progress bar displays 100% at the end.
        progress.style.width = '100%';
        progress.textContent = '100%';
        setTimeout("document.getElementById('progress_bar').className='';", 2000);
    }
   
    // Read in the image file as a binary string.
    reader.readAsBinaryString(evt.target.files[0]);
}
   
document.getElementById('files5').addEventListener('change', handleFileSelect5, false);
document.getElementById('abort-read').addEventListener('click', abortRead, false);
</pre>
</p>
<p>
    
</p>
<p>
    </p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-991" data-post-type="none" ><a href="http://jianyun.org/archives/991.html" class="wp_rp_title">使用HTML5开发离线应用</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-785" data-post-type="none" ><a href="http://jianyun.org/archives/785.html" class="wp_rp_title">HTML5未来发展的六大趋势</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-920" data-post-type="none" ><a href="http://jianyun.org/archives/920.html" class="wp_rp_title">JavaScript学习笔记（1）</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/997.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>使用HTML5开发离线应用</title>
		<link>http://jianyun.org/archives/991.html</link>
		<comments>http://jianyun.org/archives/991.html#comments</comments>
		<pubDate>Tue, 22 Jan 2013 12:56:47 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[HTML5]]></category>
		<category><![CDATA[JavaScript]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=991</guid>
		<description><![CDATA[HTML5 是目前正在讨论的新一代 HTML 标准，它代表了现在 Web 领域的 &#8230; <a href="http://jianyun.org/archives/991.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">HTML5 是目前正在讨论的新一代 HTML 标准，它代表了现在 Web 领域的最新发展方向。在 HTML5 标准中，加入了新的多样的内容描述标签，直接支持表单验证、视频音频标签、网页元素的拖拽、离线存储和工作线程等功能。其中一个新特性就是对离线应用开发的支持。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在开发支持离线的 Web 应用程序时，开发者通常需要使用以下三个方面的功能：</p>
<p><strong>离线资源缓存</strong>：需要一种方式来指明应用程序离线工作时所需的资源文件。这样，浏览器才能在在线状态时，把这些文件缓存到本地。此后，当用户离线访问应用程序时，这些资源文件会自动加载，从而让用户正常使用。HTML5 中，通过 cache manifest 文件指明需要缓存的资源，并支持自动和手动两种缓存更新方式。<br />
<strong>在线状态检测</strong>：开发者需要知道浏览器是否在线，这样才能够针对在线或离线的状态，做出对应的处理。在 HTML5 中，提供了两种检测当前网络是否在线的方式。<br />
<strong>本地数据存储</strong>：离线时，需要能够把数据存储到本地，以便在线时同步到服务器上。为了满足不同的存储需求，HTML5 提供了 DOM Storage（又叫Web Storage或者本地存储） 和 IndexedDB 两种存储机制。前者提供了易用的 key/value 对存储方式，而后者提供了类似数据库的存储功能而且方便保存和读取JavaScript对象。<br />
&nbsp;</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">尽管 HTML5 还处于草稿状态，但是各大主流浏览器都已经实现了其中的很多功能。Chrome、Firefox、Safari 和 Opera 的最新版本都对 HTML5 离线功能提供了完整的支持。IE8 也支持了其中的在线状态检测和 DOM Storage 功能。下面将具体介绍 HTML5 离线功能中的离线资源缓存、在线状态检测、DOM Storage、Web SQL Database 和 IndexedDB，最后通过一个简单的 Web 程序说明使用 HTML5 开发离线应用的方法。</p>
<h2><span class="atitle" style="color: #0000ff;">离线资源缓存</span></h2>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">为了能够让用户在离线状态下继续访问 Web 应用，开发者需要提供一个 cache manifest 文件。这个文件中列出了所有需要在离线状态下使用的资源，浏览器会把这些资源缓存到本地。本节先通过一个例子展示 cache manifest 文件的用途，然后详细描述其书写方法，最后说明缓存的更新方式。</p>
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="smalltitle" style="color: #0000ff;">cache manifest 示例</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">我们通过 W3C 提供的示例来说明。Clock Web 应用由三个文件“clock.html”、“clock.css”和“clock.js”组成。</p>
<p><strong><span style="color: #0000ff;">清单 1. Clock 应用代码</span></strong></p>
<pre class="brush:html;toolbar:false;">&lt;!-- clock.html --&gt;
 &lt;!DOCTYPE HTML&gt; 
 &lt;html&gt; 
 &lt;head&gt; 
  &lt;title&gt;Clock&lt;/title&gt; 
  &lt;script src="clock.js"&gt;&lt;/script&gt; 
  &lt;link rel="stylesheet" href="clock.css"&gt; 
 &lt;/head&gt; 
 &lt;body&gt; 
  &lt;p&gt;The time is: &lt;output id="clock"&gt;&lt;/output&gt;&lt;/p&gt; 
 &lt;/body&gt; 
 &lt;/html&gt;</pre>
<pre class="brush:css;toolbar:false;">/* clock.css */
output { font: 2em sans-serif; }</pre>
<pre class="brush:js;toolbar:false;">/* clock.js */
setTimeout(function () { 
   document.getElementById('clock').value = new Date(); 
}, 1000);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">当用户在离线状态下访问“clock.html”时，页面将无法展现。为了支持离线访问，开发者必须添加 cache manifest 文件，指明需要缓存的资源。这个例子中的 cache manifest 文件为“clock.manifest”，它声明了 3 个需要缓存的资源文件“clock.html”、“clock.css”和“clock.js”。</p>
<p><strong><span style="color: #0000ff;">清单 2. clock.manifest 代码</span></strong></p>
<pre class="brush:plain;toolbar:false;">CACHE MANIFEST 
clock.html 
clock.css 
clock.js</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">添加了 cache manifest 文件后，还需要修改“clock.html”，把 &lt;html&gt; 标签的 manifest 属性设置为“clock.manifest”。修改后的“clock.html”代码如下。</p>
<p><strong><span style="color: #0000ff;">清单 3. 设置 manifest 后的 clock.html 代码</span></strong></p>
<pre class="brush:html;toolbar:false;">&lt;!-- clock.html --&gt;
 &lt;!DOCTYPE HTML&gt; 
 &lt;html manifest="clock.manifest"&gt; 
 &lt;head&gt; 
  &lt;title&gt;Clock&lt;/title&gt; 
  &lt;script src="clock.js"&gt;&lt;/script&gt; 
  &lt;link rel="stylesheet" href="clock.css"&gt; 
 &lt;/head&gt; 
 &lt;body&gt; 
  &lt;p&gt;The time is: &lt;output id="clock"&gt;&lt;/output&gt;&lt;/p&gt; 
 &lt;/body&gt; 
 &lt;/html&gt;</pre>
<p>&nbsp;</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">修改后，当用户在线访问“clock.html”时，浏览器会缓存“clock.html”、“clock.css”和“clock.js”文件；而当用户离线访问时，这个 Web 应用也可以正常使用了。</p>
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="smalltitle" style="color: #0000ff;">cache manifest 格式</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">下面说明书写 cache manifest 文件需要遵循的格式。</p>
<p>首行必须是 <strong>CACHE MANIFEST</strong>。</p>
<p>其后，每一行列出一个需要缓存的资源文件名。</p>
<p>可根据需要列出在线访问的白名单。白名单中的所有资源不会被缓存，在使用时将直接在线访问。声明白名单使用 <strong>NETWORK：</strong>标识符。</p>
<p>如果在白名单后还要补充需要缓存的资源，可以使用 <strong>CACHE：</strong>标识符。</p>
<p>如果要声明某 URI 不能访问时的替补 URI，可以使用 <strong>FALLBACK：</strong>标识符。其后的每一行包含两个 URI，当第一个 URI 不可访问时，浏览器将尝试使用第二个 URI。</p>
<p>注释要另起一行，以 # 号开头。</p>
<p>&nbsp;</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">清单 4 的代码中给出了 cache manifest 中各类标识符的使用示例。</p>
<h4 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span style="color: #0000ff;">清单 4. cache manifest 示例代码</span></strong></h4>
<pre class="brush:plain;toolbar:false;">CACHE MANIFEST 
# 上一行是必须书写的。

images/sound-icon.png 
images/background.png 

NETWORK: 
comm.cgi

# 下面是另一些需要缓存的资源，在这个示例中只有一个 css 文件。
CACHE: 
style/default.css

FALLBACK: 
/files/projects /projects</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="smalltitle" style="color: #0000ff;">更新缓存</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">应用程序可以等待浏览器自动更新缓存，也可以使用 Javascript 接口手动触发更新。</p>
<p><strong>自动更新</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化时更新缓存。而 cache manifest 中的资源文件发生变化并不会触发更新。</p>
<p><strong>手动更新</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status 的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update() 更新缓存。示范代码如下。</p>
<h4 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span style="color: #0000ff;">清单 5 手动更新缓存</span></strong></h4>
<pre class="brush:js;toolbar:false;">if (window.applicationCache.status == window.applicationCache.UPDATEREADY)｛
  window.applicationCache.update(); 
｝</pre>
<h2 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="atitle" style="color: #0000ff;">在线状态检测</span></strong></h2>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">如果 Web 应用程序仅仅是一些静态页面的组合，那么通过 cache manifest 缓存资源文件以后，就可以支持离线访问了。但是随着互联网的发展，特别是 Web2.0 概念流行以来，用户的提交的数据渐渐成为互联网的主流。那么在开发支持离线的 Web 应用时，就不能仅仅满足于静态页面的展现，还必需考虑如何让用户在离线状态下也可以操作数据。离线状态时，把数据存储在本地；在线以后，再把数据同步到服务器上。为了做到这一点，开发者首先必须知道浏览器是否在线。HTML5 提供了两种检测是否在线的方式：navigator.online 和 online/offline 事件。</p>
<h3>navigator.onLine</h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">navigator.onLine 属性表示当前是否在线。如果为 true, 表示在线；如果为 false, 表示离线。当网络状态发生变化时，navigator.onLine 的值也随之变化。开发者可以通过读取它的值获取网络状态。</p>
<h3>online/offline 事件</h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">当开发离线应用时，通过 navigator.onLine 获取网络状态通常是不够的。开发者还需要在网络状态发生变化时立刻得到通知，因此 HTML5 还提供了 online/offline 事件。当在线 / 离线状态切换时，online/offline 事件将触发在 body 元素上，并且沿着 document.body、document 和 window 的顺序冒泡。因此，开发者可以通过监听它们的 online/offline 事件来获悉网络状态。</p>
<h2><strong><span class="atitle" style="color: #0000ff;">本地存储</span></strong></h2>
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="atitle" style="color: #0000ff;">DOM Storage</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在开发支持离线功能的 Web 应用时，开发者需要在本地存储数据。当前浏览器支持的 cookie 虽然也可以用来存储数据，但是 cookie 长度非常小（通常几 k），而且功能有限。因此，HTML5 中新引入了 DOM Storage 机制，用于存储 key/value 对，它的设计目标是提供大规模、安全且易用的存储功能。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">它是目前得到支持最广泛的HTML5本地存储规范：IE 8+、FF 3.5+、Safari 4+、Chrome 4+、Opera 10.5+，以及iPhone 2+和Android 2+都已经支持DOM Storage，要判断你的浏览器是否支持DOM Storage，可以使用下面这个函数：</p>
<pre class="brush:js;toolbar:false;">function supports_html5_storage() {  
    try {  
        return 'localStorage' in window &amp;&amp; window['localStorage'] !== null;  
    } catch (e) {  
        return false;  
    }  
}</pre>
<h4 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><span class="smalltitle" style="color: #0000ff;">DOM Storage 分类</span></h4>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">DOM Storage 分为两类：sessionStorage 和 localStorage。除了以下区别外，这两类存储对象的功能是完全一致的。</p>
<p>sessionStorage 用于存储与当前浏览器窗口关联的数据。窗口关闭后，sessionStorage 中存储的数据将无法使用。<br />
localStorage 用于长期存储数据。窗口关闭后，localStorage 中的数据仍然可以被访问。所有浏览器窗口可以共享 localStorage 的数据。</p>
<h4 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><span class="smalltitle" style="color: #0000ff;">DOM Storage 接口</span></h4>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">每一个 Storage 对象都可以存储一系列 key/value 对，Storage 接口定义为：</p>
<pre class="brush:js;toolbar:false;">interface Storage { 
 readonly attribute unsigned long length; 
 getter DOMString key(in unsigned long index); 
 getter any getItem(in DOMString key); 
 setter creator void setItem(in DOMString key, in any data); 
 deleter void removeItem(in DOMString key); 
 void clear(); 
};</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">其中最常用的接口是 getItem 和 setItem。getItem 用于获取指定 key 的 value，而 setItem 用于设置指定 key 的 value。</p>
<h4><span class="smalltitle" style="color: #0000ff;">Storage 事件</span></h4>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">通过捕获storage事件可以跟踪存储区的改动， 任何时候调用setItem(), removeItem()或者clear()方法时，如果 真的发生了数据改动，都会在window对象上触发storage事件。（只要支持localStorage对象就一定支持 storage事件）</p>
<pre class="brush:js;toolbar:false;">if (window.addEventListener) { 
   window.addEventListener('storage', handle_storage, false); 
} 
else { 
   window.attachEvent('onstorage', handle_storage); 
}</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">handle_storage()回调函数被调用时，会传入一个<strong>StorageEvent</strong>对象作为参数，IE下面的事件对象存储在 window.event上：</p>
<pre class="brush:js;toolbar:false;">function handle_storage(e) { 
    if (!e) { e = window.event; } 
}</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">StorageEvent 对象的属性：</p>
<table width="100%" border="1" align="LEFT" bgcolor="#FFFFFF">
<tbody>
<tr>
<td style="width: 33%;">属性</td>
<td style="width: 33%;">类型</td>
<td style="width: 33%;">描述</td>
</tr>
<tr>
<td style="width: 33%;">key</td>
<td style="width: 33%;">字符串</td>
<td style="width: 33%;">加入，修改或者删除的键名</td>
</tr>
<tr>
<td style="width: 33%;">oldValue</td>
<td style="width: 33%;">任意</td>
<td style="width: 33%;">之前的数据（如果是被覆盖的情况）或者null（如果是有新数据项加入的情况）</td>
</tr>
<tr>
<td style="width: 33%;">newValue</td>
<td style="width: 33%;">任意</td>
<td style="width: 33%;">新数据或者null（如果是数据项被删除的情况）</td>
</tr>
<tr>
<td style="width: 33%;">url</td>
<td style="width: 33%;">字符串</td>
<td style="width: 33%;">调用这个触发数据区变动的函数所在的页面地址</td>
</tr>
</tbody>
</table>
<p style="padding: 0px; line-height: 20px; clear: both; margin-top: 0px; margin-bottom: 0px;">storage 事件是无法撤销存储区的改动的。在handle_storage()回调方法中，没有办法停止正在发生的对存储区 的改动。</p>
<h4><span class="smalltitle" style="color: #0000ff;">DOM Storage 示例</span></h4>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">这里给出一个使用了 sessionStorage 的例子，localStorage 的用法与它相同。首先使用 SetItem 添加了一个名为“userName”的项，它的值是“developerworks”。然后，调用 getItem 得到“userName”的值，并且弹出提示框显示它。最后，调用 removeItem 删除“userName”。</p>
<p><strong><span style="color: #0000ff;">清单 6 DOM Storage 示例代码</span></strong></p>
<pre class="brush:html;toolbar:false;">&lt;!DOCTYPE HTML&gt; 
&lt;html&gt; 
&lt;body&gt; 
&lt;script&gt; 
// 在 sessionStorage 中定义'userName'变量
sessionStorage.setItem('userName', 'developerworks');       
// 访问'userName'变量
alert("Your user is: " + sessionStorage.getItem('userName')); 
// 最后删除'userName'
sessionStorage.removeItem('userName');                       
&lt;/script&gt; 
&lt;/body&gt; 
&lt;/html&gt;</pre>
<p>&nbsp;</p>
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="atitle" style="color: #0000ff;">Web SQL Database</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">Web SQL Database是一个已经废弃的规范，但是鉴于很多浏览器都已经实现了Web SQL Database，并且它还具有一些HTML5 Storage所不具有的特性，所以还是值得了解一下的。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">它提供了基本的关系数据库功能，支持页面上的复杂的、交互式的数据存储。它既可以用来存储用户产生的数据，也可以作为从服务器获取数据的本地高速缓存。例如可以把电子邮件、日程等数据存储到数据库中。Web SQL Database 支持数据库事务的概念，从而保证了即使多个浏览器窗口操作同一数据，也不会产生冲突。</p>
<h4><span class="smalltitle" style="color: #0000ff;">Web SQL Database 基本用法</span></h4>
<p><strong>创建和打开数据库</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">使用数据库的第一步是创建并打开数据库，API 是 openDatabase。当数据库已经存在时，openDatabase 仅仅打开数据库；如果这个数据库不存在，那么就创建一个空数据库并且打开它。openDatabase 的定义是：</p>
<pre class="brush:plain;toolbar:false;">Database openDatabase(in DOMString name, in DOMString version, 
in DOMString displayName, in unsigned long estimatedSize, 
in optional DatabaseCallback creationCallback);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">name：数据库名。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">version：数据库版本。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">displayName：显示名称。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">estimatedSize：数据库预估长度（以字节为单位）。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">creationCallback：回调函数。</p>
<p><strong>执行事务处理</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在打开数据库以后，就可以使用事务 API transaction。每一个事务作为操作数据库的原子操作，不会被打断，从而避免了数据冲突。transaction 的定义是：</p>
<pre class="brush:plain;toolbar:false;">void transaction(in SQLTransactionCallback callback, 
in optional SQLTransactionErrorCallback errorCallback, 
in optional SQLVoidCallback successCallback);</pre>
<p style="line-height: 20px;">callback：事务回调函数，其中可以执行 SQL 语句。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">errorCallback：出错回调函数。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">successCallback：执行成功回调函数。</p>
<p>&nbsp;</p>
<p><strong>执行 SQL 语句</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在事务的回调函数 callback 中，可以执行 SQL 语句，API 是 executeSQL。executeSQL 的定义是：</p>
<pre class="brush:plain;toolbar:false;">void executeSql(in DOMString sqlStatement, 
in optional ObjectArray arguments, in optional SQLStatementCallback callback, 
in optional SQLStatementErrorCallback errorCallback);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">sqlStatement：SQL 语句。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">arguments：SQL 语句需要的参数。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">callback：回调函数。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">errorCallback：出错回调函数。</p>
<h4><span class="smalltitle" style="color: #0000ff;">Web SQL Database 示例</span></h4>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">下面通过一个例子说明 Web SQL Database 的基本用法。它首先调用 openDatabase 创建了名为“fooDB”的数据库。然后使用 transaction 执行两条 SQL 语句。第一条 SQL 语句创建了名为“foo”的表，第二条 SQL 语句向表中插入一条记录。</p>
<p><strong><span style="color: #0000ff;">清单 7 Web SQL Database 示例代码</span></strong></p>
<pre class="brush:js;toolbar:false;">var db = openDatabase('fooDB', '1.0', 'fooDB', 2 * 1024); 
db.transaction(function (tx) { 
 tx.executeSql('CREATE TABLE IF NOT EXISTS foo (id unique, text)');  
 tx.executeSql('INSERT INTO foo (id, text) VALUES (1, "foobar")'); 
});</pre>
<p>&nbsp;</p>
<h3 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong><span class="atitle" style="color: #0000ff;">IndexedDB</span></strong></h3>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">IndexedDB是在浏览器中保存结构化数据的一种数据库。为了替代目前已经被废弃的Web SQL Database API。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询及搜索。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><span style="line-height: 20px; white-space: normal;">IndexedDB</span>是HTML5-WebStorage的重要一环，是一种轻量级NOSQL数据库，W3C为IndexedDB定义了很多接口，其中Database对象被定义为IDBDataBase。而得到IDBDataBase用的是工厂方法，即从IDBFactory中取得。浏览器对象中，实现了IDBFactory的只有indexedDB这个实例。IndexedDB中，几乎所有的操作都是采用了command-&gt;request-&gt;result的方式。比如查询一条记录，返回一个request，在request的result中得到查询结果。又比如打开数据库，返回一个request，在request的result中得到返回的数据库引用。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">IndexedDB的对象名在不同浏览器内核中是不同的。IndexedDB在IE10中叫 msIndexedDB, 在Firefox中叫mozIndexedDB, 在Chrome中叫 webkitIndexedDB。</p>
<pre class="brush:js;toolbar:false;">    var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || webkitIndexedDB;</pre>
<p><strong>打开IndexedDB</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">IndexedDB大的特色是使用对象保存数据，而不是使用表来保存数据。一个 IndexedDB数据库，就是一组位于相同命名空间下的对象的集合。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">使用IndexedDB前首先要打开它，即把要打开的数据库名传给indexDB.open()。</p>
<ul style="list-style-type: disc;">
<li>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">如果传入的数据库已经存在，就会发送一个打开它的请求；</p>
</li>
<li>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">如果传入的数据库还不存在，就会发送一个创建并打开它的请求；</p>
</li>
<li>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">总之，调用indexedDB.open()会返回一个IDBRequest对象，在这个对象上可以添加onerror和onsuccess事 件处理程序。</p>
</li>
</ul>
<pre class="brush:js;toolbar:false;">var request, database; 
request = indexedDB.open("admin"); 
request.onerror = function(event) {  
    alert("打开数据库错误：" + event.target.errorcode); 
}; 
request.onsuccess = function(event) {  
    database = event.target.result; 
};</pre>
<p><strong>数据库版本号</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">默认情况下，IndexedDB数据库是没有版本号的。好一开始就调用setVersion()方法为数据库指定一个版本号 （传入一个表示版本号的字符串）。</p>
<pre class="brush:js;toolbar:false;">if (database.version != "1.0") {
  request = database.setVersion("1.0");
  request.onerror = function(event) {
    alert("设置版本号时发生错误：" + event.target.errorCode);
  };
  request.onsuccess = function() {
    alert("数据库初始化完成，数据库名：" + database.name + ", 版本：" + database.version);
  };
 } else {
  alert("数据库已经初始化过了。数据库名称：" + database.name + ",版本号：" + database.version);
 }</pre>
<p><strong>初始化object store</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">建立完数据库连接以后，就要创建对象存储空间(object store)。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">假设我们要保存用户记录，user对象格式可能类似于：</p>
<pre class="brush:js;toolbar:false;">var user = {
  username: "007",
  firstName: "James",
  lastName: "Bond",
  password: "foo"
 };</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">创建对象存储空间时，必须指定一个全局唯一键（主键），这里我们可以用&#8221;username&#8221;。下面是为了保存用户记录而 创建对象存储空间的示例：</p>
<pre class="brush:js;toolbar:false;">var store = database.createObjectStore("users", {keyPath: "username"});</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">keyPath属性，就是空间中要保存的对象的一个属性，这个属性将作为存储空间的主键来使用。</p>
<p style="white-space: normal;"><strong>添加数据</strong></p>
<p><span style="white-space: nowrap;">获得了object store的引用之后，就可以使用add()或put()方法向其中添加数据。这两个方法都接收一个参</span><span style="white-space: nowrap;">数，即要保存的对象，然后这个对象就会被保存到存储空间中。</span></p>
<p style="white-space: normal; padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">这两个方法的区别在于，如果空间中已经包含了键值相同的对象：add()会返回错误，而put()则会重写原有对象。</p>
<p><span style="white-space: nowrap;">比如，我们可以用下面的方法来初始化对象存储空间,把返回的请求对象保存在一个变量中，然后再指定</span><span style="white-space: nowrap;">onerror或onsuccess事件处理程序，来验证请求是否成功完成：</span></p>
<pre class="brush:js;toolbar:false;">var request, requests[];
for (var index = 0; index &lt; users.length; index++) {  
  request = store.add(users[index]);
  request.onerror = function() {  // 错误处理
  };
  request.onsuccess = function() {  // 成功
  };
  requests.push(request);
}</pre>
<p style="white-space: normal;"><strong>使用事务</strong></p>
<p><span style="white-space: nowrap;">在数据库对象上调用transaction()方法就可以创建事务。任何时候，想要读取或修改数据，都要通过事务来组</span><span style="white-space: nowrap;">织所有的操作。</span></p>
<p><span style="white-space: nowrap;">在IndexedDB中，事务会自动提交或回滚。所以无需手动commit或者rollback。</span></p>
<p><span style="white-space: nowrap;">事务分为三种</span></p>
<p><span style="white-space: nowrap;">IDBTransaction.READ_ONLY 只读</span></p>
<p><span style="white-space: nowrap;">IDBTransaction.READ_WRITE 可读可写</span></p>
<p><span style="white-space: nowrap;">IDBTransaction.VERSION_CHANGE 版本升级</span></p>
<p><span style="white-space: nowrap;">我们用的最多的是前两种。如果不设置事务级别，则默认为READ_ONLY。</span></p>
<p>&nbsp;</p>
<p style="white-space: normal;">下面的代码保证只加载users存储空间中的数据，以便通过事务进行访问：</p>
<pre class="brush:js;toolbar:false;">    var transaction = db.transaction("users");</pre>
<p style="white-space: normal;">如果要访问多个对象存储空间，可以传入字符串数组：</p>
<pre class="brush:js;toolbar:false;">    var transaction = db.transaction(["users", "anotherStore"]);</pre>
<p style="white-space: normal;">上面的两个事务都是以只读的方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数。</p>
<p><span style="white-space: nowrap;">E10+和Firefox4+实现的叫做IDBTransaction, 但在Chrome中则叫webkitIDBTransaction, 所以使用下面的代码</span><span style="white-space: nowrap;">可以统一接口：</span></p>
<pre class="brush:js;toolbar:false;">var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;</pre>
<p style="white-space: normal;">有了这行代码就可以比较方便地为transaction()指定第二个参数：</p>
<pre class="brush:js;toolbar:false;">var transaction = db.transaction("users", IDBTransaction.READ_WRITE);</pre>
<p style="white-space: normal;">事务本身也有事件处理程序：onerror和oncomplete。这两个事件可以提供事务级的状态信息。</p>
<pre class="brush:js;toolbar:false;">transaction.onerror = function(event) {
  // 整个事务都被取消了
};
transaction.oncomplete = fucntion(event) {
  // 事务成功完成
};</pre>
<p style="white-space: normal;"><strong>访问存储空间</strong></p>
<p style="white-space: normal;">拿到事务以后，使用objectStore()方法并传入存储空间的名称，就可以访问特定的存储空间。然后就可以：</p>
<ul style="list-style-type: disc;">
<li>
<p style="white-space: normal;">使用add()和put()方法添加数据;</p>
</li>
<li>
<p style="white-space: normal;">使用get()可以取得值；</p>
</li>
<li>
<p style="white-space: normal;">使用delete()可以删除对象；</p>
</li>
<li>
<p style="white-space: normal;">使用clear()可以删除所有对象；</p>
</li>
</ul>
<p style="white-space: normal;">get()和delete()方法都接收一个对象键作为参数。所有的这5个方法都会返回一个新的请求对象。例如：</p>
<pre class="brush:js;toolbar:false;">var request = db.transaction("users").objectStore("users").get("007");
request.onerror = function(event) {
  alert("获取对象失败！");
};
request.onsuccess = function(event) {
  var result = event.target.result;
  alert(result.firestName);
};</pre>
<p style="white-space: normal;"><strong>使用游标查询</strong></p>
<p><span style="white-space: nowrap;">使用事务可以直接通过已知的键来检索单个对象，在需要检索多个对象的情况下，需要在事务内部创建游</span><span style="white-space: nowrap;">标。</span></p>
<p><span style="white-space: nowrap;">游标就是指向结果集的一个指针，游标指针首先会指向结果集中的第一项，在接到查找下一项的指令时，才</span><span style="white-space: nowrap;">会指向下一项。</span></p>
<p><span style="white-space: nowrap;">在对象存储空间上调用openCursor()方法可以创建游标。openCursor()方法返回的也是一个请求对象，也需</span><span style="white-space: nowrap;">要为该对象指定onsuccess和onerror事件处理函数。</span></p>
<pre class="brush:js;toolbar:false;">var store = db.transaction("users").objectStore("users"),
    request = store.openCursor();

request.onsuccess = function(event) {
  // 处理成功
};
request.onerror = function(event) {
  // 处理失败
};</pre>
<p><span style="white-space: nowrap;">在onsuccess事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个对象。在结果集中有下一项时，result是一个IDBCursor的实例；如果没有下一项，result为null。</span></p>
<p style="white-space: normal;">IDBCursor实例具有以下几个属性：</p>
<ul style="list-style-type: circle;">
<li>
<p style="white-space: normal;">key: 对象的键；</p>
</li>
<li>
<p style="white-space: normal;">value：实际的对象；</p>
</li>
<li>
<p style="white-space: normal;">direction：数值，表示游标走动的方向。</p>
<ul style="list-style-type: disc;">
<li>
<p style="white-space: normal;">默认是IDBCursor.NEXT(0), 表示下一项。</p>
</li>
<li>
<p style="white-space: normal;">IDBCursor.NEXT_TO_DUPLICATE(1), 表示下一个不重复的项；</p>
</li>
<li>
<p style="white-space: normal;">IDBCursor.PREV(2)表示前一项；</p>
</li>
<li>
<p style="white-space: normal;">IDBCursor.PREV_NO_DUPLICATE表示前一个不重复的项。</p>
</li>
</ul>
</li>
<li>
<p style="white-space: normal;">primaryKey：游标使用的键，有可能是对象键，也有可能是索引键。</p>
</li>
</ul>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">要检索某一个结果信息，可以像下面这样：</p>
<pre class="brush:js;toolbar:false;">request.onsuccess = function(event) {
  var cursor = event.target.result;
  if (cursor) {
    console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value));
  }
};</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">因为result.value是一个对象，所以显示前要先转成JSON字符串。</p>
<p style="white-space: normal;"><strong>使用游标更新记录</strong></p>
<p style="white-space: normal;">调用update()方法可以使用指定的对象更新当前游标的value：</p>
<pre class="brush:js;toolbar:false;">request.onsuccess = function(event) {
  var cursor = event.target.result, value, updateRequest;
  if (cursor) {
    if (cursor.key == "foo") {
      value = cursor.value;  // 取得当前值
      value.password = "magic";  // 更新密码

      updateRequest = cursor.udpate(value); // 请求保存更新
      updateRequest.onsuccess = function() {
        // 处理成功
      };
      updateRequest.onerror = function() {
        // 处理失败
      };
    }
  }
};</pre>
<p style="white-space: normal;"><strong>使用游标删除记录</strong></p>
<p style="white-space: normal;">调用delete()方法可以删除相应的记录：</p>
<pre class="brush:js;toolbar:false;">request.onsuccess = function(event) {
  var cursor = event.target.result, value, deleteRequest;
  if (cursor) {  // 检查一下
    if (cursor.key == "foo") {
      deleteRequest = cursor.delete(); // 请求删除当前项
      deleteRequest.onsuccess = function() {
        // 处理成功
      };
      deleteRequest.onerror = function() {
        // 处理失败
      };
    }
  }
};</pre>
<p style="white-space: normal;">注意：如果当前的事务没有修改对象存储空间的权限，update()和delete()会抛出错误。</p>
<p style="white-space: normal;"><strong>移动游标</strong></p>
<p style="white-space: normal;">默认情况下每个游标只发起一次请求；要想发起另一次请求，必须调用下面的一个方法：</p>
<ul style="list-style-type: disc;">
<li><span style="white-space: nowrap;">continue(key): 移动到结果集的下一项。参数key是可选的，不指定这个参数，游</span><span style="white-space: nowrap;">标移动到下一项；指定这个参数的话，游标会移动到指定键的位置。</span></li>
<li>
<p style="white-space: normal;">advance(count): 向前移动count指定的项数。</p>
</li>
</ul>
<p style="white-space: normal;">下面的例子遍历了对象存储空间中的所有项：</p>
<pre class="brush:js;toolbar:false;">request.onsuccess = function(event) {
  var cursor = event.target.result;
  if (cursor) {  // 检查一下
    console.log("key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value));
    cursor.continue();  // 移动到下一项
  } else {
    console.log("Done!");
  }
};</pre>
<p><span style="white-space: nowrap;">调用continue()会触发另一次请求，进而再次调用onsuccess处理程序。如果没有更多</span><span style="white-space: nowrap;">项可以遍历时，event.target.result的值为null。</span></p>
<p style="white-space: normal;"><strong>键范围</strong></p>
<p style="white-space: normal;"><span style="line-height: 20px;">通过游标查找数据的方式比较有限，键范围(key range)为使用游标增添了一些灵活性。</span></p>
<p style="white-space: normal;"><span style="line-height: 20px;">键范围由<strong>IDBKeyRange</strong>的实例表示。</span></p>
<p>&nbsp;<br />
<span style="white-space: nowrap;">支持标准IDBKeyRange的浏览器有IE10+和Firefox4+， Chrome中的名字叫</span><span style="white-space: nowrap;">webkitIDBKeyRange。</span></p>
<p style="white-space: normal;"><span style="line-height: 20px;">考虑到不同浏览器中的差异，也是要声明一个本地的类型：</span></p>
<pre class="brush:js;toolbar:false;">var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;</pre>
<p style="white-space: normal;">
<p style="white-space: normal;"><span style="line-height: 20px;">第一种键范围方式是使用only()方法，传入想要取得对象的键：</span></p>
<pre class="brush:js;toolbar:false;">var onlyRange = IDBKeyRange.only("007");</pre>
<p style="white-space: normal;"><span style="line-height: 20px;">这个范围保证只取得键值为&#8221;007&#8243;的对象。使用这个范围创建的游标和直接访问存储空间并调用get(&#8220;007&#8243;)差不多。</span></p>
<p>&nbsp;</p>
<p style="white-space: normal;">
<p style="white-space: normal;"><span style="line-height: 20px;">第二种定义键范围的方法是指定结果集的下界lowerBound()方法。下界表示游标开始的位置。</span></p>
<p>&nbsp;</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">下面代码的键范围可以保证游标从键为&#8221;007&#8243;的对象开始，然后继续前移，直到最后一个对象：</p>
<pre class="brush:js;toolbar:false;">// 从键为“007”的对象开始，然后可以移动到最后
var lowerRange = IDBKeyRange.lowerBound("007");</pre>
<p><span style="white-space: nowrap;">如果想要忽略键为&#8221;007&#8243;的对象本身，从它的下一个对象开始，可以传入第二个参数</span><span style="white-space: nowrap;">true：</span></p>
<pre class="brush:js;toolbar:false;">// 从键为“007”的下一个对象开始，然后可以移动到最后      
var lowerRange = IDBKeyRange.lowerBound("007", true);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">第三种定义键范围的方法是指定结果集的上界upperBound()方法，也就是指定游标不能超过哪个键。</p>
<pre class="brush:js;toolbar:false;">// 从头开始，到取得键为"ace"的对象为止      
var upperRange = IDBKeyRange.upperBound("ace");</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">如果不想包含键为指定值的对象，同样传入第二个参数true：</p>
<pre class="brush:js;toolbar:false;">// 从头开始，到取得键为"ace"的上一个对象为止      
var upperRange = IDBKeyRange.upperBound("ace", true);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">使用bound()方法可以同时指定上下界。</p>
<p><span style="white-space: nowrap;">这个方法可以接收四个参数：表示下界的键，表示上界的键，可选的表示是否跳过下</span><span style="white-space: nowrap;">界的布尔值和可选的表示是否跳过上界的布尔值。</span></p>
<pre class="brush:js;toolbar:false;">var upperRange = IDBKeyRange.bound("007", "ace");
var upperRange = IDBKeyRange.bound("007", "ace", true);
var upperRange = IDBKeyRange.bound("007", "ace", true, true);
var upperRange = IDBKeyRange.bound("007", "ace", false, true);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><strong>使用KeyRange的openCursor()方法</strong></p>
<p><span style="white-space: nowrap;">定义好了key range之后，就可以把它传给openCursor()方法，就能得到一个符合相</span><span style="white-space: nowrap;">应约束条件的游标。</span></p>
<pre class="brush:js;toolbar:false;">var store = db.transaction("users").objectStore("users"),
  range = IDBKeyRange.bound("007", "ace")，
  request = store.openCursor(range);

request.onsuccess = function(event) {
  var cursor = event.target.result;
  if (cursor) {
    console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value));
    cursor.continue(); // 移动到下一项
  } else {
    console.log("Done!");
  }
};</pre>
<p style="white-space: normal;"><strong>设定游标方向</strong></p>
<p style="white-space: normal;">openCursor()可以接收两个参数，一个是刚才的IDBKeyRange实例，第二个是表示</span><span style="white-space: nowrap;">方向的数值常量，也就是前面讲到的IDBCursor中的常量，</span><span style="white-space: nowrap;">有4种：</p>
<p><span style="white-space: nowrap;">IDBCursor.NEXT 顺序循环</span><br />
<span style="white-space: nowrap;">IDBCursor.NEXT_NO_DUPLICATE 顺序循环不重复</span><br />
<span style="white-space: nowrap;">IDBCursor.PREV 倒序循环</span><br />
<span style="white-space: nowrap;">IDBCursor.PREV_NO_DUPLICATE 倒序循环不重复</span></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">正常情况下，游标都是从存储空间的第一项开始，调用continue()或advance()前进到最后一项。游标的默认方向值是IDBCursor.NEXT。</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">也可以创建一个游标，从最后一个对象开始，逐个迭代，直到第一个对象：</p>
<pre class="brush:js;toolbar:false;">var store = db.transaction("users").objectStore("users"),
  request = store.openCursor(null, IDBCursor.PREV);</pre>
<p><br/></p>
<h2 style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;"><span class="atitle" style="color: #0000ff;">离线应用示例</span></h2>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">最后，通过一个例子来说明使用 HTML5 开发离线应用的基本方法。这个例子会用到前面提到的离线资源缓存、在线状态检测和 DOM Storage 等功能。假设我们开发一个便签管理的 Web 应用程序，用户可以在其中添加和删除便签。它支持离线功能，允许用户在离线状态下添加、删除便签，并且当在线以后能够同步到服务器上。</p>
<p><strong>应用程序页面</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">这个程序的界面很简单，如图 1 所示。用户点击“New Note”按钮可以在弹出框中创建新的便签，双击某便签就表示删除它。</p>
<p><strong><span style="color: #0000ff;">图 1. 应用程序页面</span></strong></p>
<p style="text-align: center;"><a href="http://jianyun.org/archives/991.html/ui01" rel="attachment wp-att-992"><img class="size-full wp-image-992 aligncenter" title="ui01" src="http://jianyun.org/wordpress/wp-content/uploads/2013/01/ui01.gif" alt="" width="153" height="105" /></a></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">这个页面的源文件是 index.html，它的代码如清单 8 所示。</p>
<p><strong><span style="color: #0000ff;">清单 8 页面 HTML 代码</span></strong></p>
<pre class="brush:html;toolbar:false;">&lt;html manifest="notes.manifest"&gt; 
&lt;head&gt; 
&lt;script type="text/javascript" src="server.js"&gt;&lt;/script&gt; 
&lt;script type="text/javascript" src="data.js"&gt;&lt;/script&gt; 
&lt;script type="text/javascript" src="UI.js"&gt;&lt;/script&gt; 
&lt;title&gt;Note List&lt;/title&gt; 
&lt;/head&gt; 

&lt;body onload = "SyncWithServer()"&gt; 
&lt;input type="button" value="New Note" onclick="newNote()"&gt; 
&lt;ul id="list"&gt;&lt;/ul&gt; 
&lt;/body&gt; 
&lt;/html&gt;</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在 body 中声明了一个按钮和一个无序列表。当按下“New Note”按钮时，newNote 函数将被调用，它用来添加一条新的便签。而无序列表初始为空，它是用来显示便签的列表。</p>
<p>&nbsp;<br />
<strong>cache manifest 文件</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">定义 cache manifest 文件，声明需要缓存的资源。在这个例子中，需要缓存“index.html”、“server.js”、“data.js”和“UI.js”等 4 个文件。除了前面列出的“index.html”外，“server.js”、“data.js”和“UI.js”分别包含服务器相关、数据存储和用户界面代码。cache manifest 文件定义如下。</p>
<p><strong><span style="color: #0000ff;">清单 9 cache manifest 文件</span></strong><a style="color: #333333; text-shadow: 0px 1px 0px; border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: #cccccc;" name="listing9"></a></p>
<pre class="brush:plain;toolbar:false;">CACHE MANIFEST 
index.html 
server.js 
data.js 
UI.js</pre>
<p>&nbsp;<br />
<strong>用户界面代码</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">用户界面代码定义在 UI.js 中。</p>
<p><strong><span style="color: #0000ff;">清单 10 用户界面代码 UI.js</span></strong></p>
<pre class="brush:js;toolbar:false;">function newNote() 
{ 
   var title = window.prompt("New Note:"); 
   if (title) 
   { 
       add(title); 
   } 
} 

function add(title) 
{ 
   // 在界面中添加
   addUIItem(title); 
   // 在数据中添加
   addDataItem(title); 
} 

function remove(title) 
{ 
   // 从界面中删除
   removeUIItem(title); 
   // 从数据中删除
   removeDataItem(title); 
} 

function addUIItem(title) 
{ 
   var item = document.createElement("li"); 
   item.setAttribute("ondblclick", "remove('"+title+"')"); 
   item.innerHTML=title; 

   var list = document.getElementById("list"); 
   list.appendChild(item);    
}  

function removeUIItem(title) 
{ 
   var list = document.getElementById("list"); 
   for (var i = 0; i &lt; list.children.length; i++) { 
       if(list.children[i].innerHTML == title) 
       { 
           list.removeChild(list.children[i]); 
       } 
   } 
}</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">UI.js 中的代码包含添加便签和删除便签的界面操作。</p>
<p><strong>添加便签</strong></p>
<p>用户点击“New Note”按钮，newNote 函数被调用。</p>
<p>newNote 函数会弹出对话框，用户输入新便签内容。newNote 调用 add 函数。</p>
<p>add 函数分别调用 addUIItem 和 addDataItem 添加页面元素和数据。addDataItem 代码将在后面列出。</p>
<p>addUIItem 函数在页面列表中添加一项。并指明 ondblclick 事件的处理函数是 remove，使得双击操作可以删除便签。</p>
<p><strong>删除便签</strong></p>
<p>用户双击某便签时，调用 remove 函数。</p>
<p>remove 函数分别调用 removeUIItem 和 removeDataItem 删除页面元素和数据。removeDataItem 将在后面列出。</p>
<p>removeUIItem 函数删除页面列表中的相应项。</p>
<p>&nbsp;</p>
<p><strong>数据存储代码</strong></p>
<p><span style="line-height: 20px;">数据存储代码定义在 data.js 中。 </span></p>
<p><strong><span style="color: #0000ff;">清单 11 数据存储代码 data.js</span></strong></p>
<pre class="brush:js;toolbar:false;">var storage = window['localStorage']; 

 function addDataItem(title) 
 { 
    if (navigator.onLine) // 在线状态
    { 
        addServerItem(title); 
    } 
    else // 离线状态
    { 
        var str = storage.getItem("toAdd"); 
        if(str == null) 
        { 
            str = title; 
        } 
        else
        { 
            str = str + "," + title; 
        } 
        storage.setItem("toAdd", str); 
    } 
 } 

 function removeDataItem(title) 
 { 
    if (navigator.onLine) // 在线状态
    { 
        removeServerItem(title); 
    } 
    else // 离线状态
    { 
        var str = storage.getItem("toRemove"); 
        if(str == null) 
        { 
            str = title; 
        } 
        else
        { 
            str = str + "," + title; 
        } 
        storage.setItem("toRemove", str); 
    } 
 } 

 function SyncWithServer() 
 { 
    // 如果当前是离线状态，不需要做任何处理
    if (navigator.onLine == false)return; 

    var i = 0; 
    // 和服务器同步添加操作
    var str = storage.getItem("toAdd"); 
    if(str != null) 
    { 
        var addItems = str.split(","); 
        for(i = 0; i&lt;addItems.length; i++) 
        { 
            addDataItem(addItems[i]); 
        } 
        storage.removeItem("toAdd"); 
    } 

    // 和服务器同步删除操作
    str = storage.getItem("toRemove"); 
    if(str != null) 
    { 
        var removeItems = str.split(","); 
        for(i = 0; i&lt;removeItems.length; i++) 
        { 
            removeDataItem(removeItems[i]); 
        } 
        storage.removeItem("toRemove"); 
    } 

    // 删除界面中的所有便签   
    var list = document.getElementById("list"); 
    while(list.lastChild != list.firstElementChild) 
        list.removeChild(list.lastChild); 
    if(list.firstElementChild) 
        list.removeChild(list.firstElementChild);        

    // 从服务器获取全部便签，并显示在界面中
    var allItems = getServerItems(); 
    if(allItems != "") 
    { 
        var items = allItems.split(","); 
        for(i = 0; i&lt;items.length; i++) 
        { 
            addUIItem(items[i]); 
        } 
    } 
 }

window.addEventListener("online", SyncWithServer,false);</pre>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">data.js 中的代码包含添加便签、删除便签和与服务器同步等数据操作。其中用到了 navigator.onLine 属性、online 事件、DOM Storage 等 HTML5 新功能。</p>
<p>添加便签：addDataItem</p>
<p>通过 navigator.onLine 判断是否在线。</p>
<p>如果在线，那么调用 addServerItem 直接把数据存储到服务器上。addServerItem 将在后面列出。</p>
<p>如果离线，那么把数据添加到 localStorage 的“toAdd”项中。</p>
<p>&nbsp;</p>
<p>删除便签：removeDataItem</p>
<p>通过 navigator.onLine 判断是否在线。</p>
<p>如果在线，那么调用 removeServerItem 直接在服务器上删除数据。removeServerItem 将在后面列出。</p>
<p>如果离线，那么把数据添加到 localStorage 的“toRemove”项中。</p>
<p>&nbsp;</p>
<p>数据同步：SyncWithServer</p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">在 data.js 的最后一行，注册了 window 的 online 事件处理函数 SyncWithServer。当 online 事件发生时，SyncWithServer 将被调用。其功能如下。</p>
<p>如果 navigator.onLine 表示当前离线，则不做任何操作。</p>
<p>把 localStorage 中“toAdd”项的所有数据添加到服务器上，并删除“toAdd”项。</p>
<p>把 localStorage 中“toRemove”项的所有数据从服务器中删除，并删除“toRemove”项。</p>
<p>&nbsp;</p>
<p>删除当前页面列表中的所有便签。</p>
<p>调用 getServerItems 从服务器获取所有便签，并添加在页面列表中。getServerItems 将在后面列出。<br />
&nbsp;<br />
<strong>服务器相关代码</strong></p>
<p style="padding: 0px; line-height: 20px; margin-top: 0px; margin-bottom: 0px;">服务器相关代码定义在 server.js 中。</p>
<p><strong><span style="color: #0000ff;">清单 12 服务器相关代码 server.js</span></strong></p>
<pre class="brush:js;toolbar:false;">function addServerItem(title) 
{ 
   // 在服务器中添加一项
} 

function removeServerItem(title) 
{ 
   // 在服务器中删除一项
} 

function getServerItems() 
{ 
   // 返回服务器中存储的便签列表
}</pre>
<p><span style="line-height: 20px;">由于这部分代码与服务器有关，这里只说明各个函数的功能，具体实现可以根据不同服务器编写代码。 </span></p>
<p>在服务器中添加一项：addServerItem</p>
<p>在服务器中删除一项：removeServerItem</p>
<p>返回服务器中存储的便签列表：getServerItems</p>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-997" data-post-type="none" ><a href="http://jianyun.org/archives/997.html" class="wp_rp_title">HTML5之File API</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-785" data-post-type="none" ><a href="http://jianyun.org/archives/785.html" class="wp_rp_title">HTML5未来发展的六大趋势</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-925" data-post-type="none" ><a href="http://jianyun.org/archives/925.html" class="wp_rp_title">JavaScript学习笔记（2）</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/991.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>基于.NET的大型Web站点StackOverflow架构分析</title>
		<link>http://jianyun.org/archives/987.html</link>
		<comments>http://jianyun.org/archives/987.html#comments</comments>
		<pubDate>Thu, 17 Jan 2013 08:56:10 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[.Net]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=987</guid>
		<description><![CDATA[原文链接：Stack Overflow Architecture Update  &#8230; <a href="http://jianyun.org/archives/987.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>原文链接：<a href="http://highscalability.com/blog/2011/3/3/stack-overflow-architecture-update-now-at-95-million-page-vi.html" target="_blank">Stack Overflow Architecture Update &#8211; Now At 95 Million Page Views A Month</a></p>
<p>编译/博客园</p>
<p>Stack Overflow网址：<a href="http://stackoverflow.com/" target="_blank">http://stackoverflow.com/</a></p>
<p><strong>当前访问量：</strong>每月9500PV（每天300多万PV）</p>
<p><strong>当前Alexa排名：</strong>149</p>
<p><strong>所用.NET技术：</strong>C#、Visual Studio 2010 Team Suite、ASP.NET 4、ASP.NET MVC 3、Razor、LINQ to SQL+raw SQL</p>
<p><strong>下面是英文原文：</strong></p>
<p>A lot has happened since my first article on the <a href="http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html">Stack Overflow Architecture</a>(2009-8-5). Contrary to the theme of that last article, which lavished attention on Stack Overflow&#8217;s dedication to a scale-up strategy, Stack Overflow has both grown up and out in the last few years.</p>
<p>自从2009年8月发布了第一篇关于“Stack Overflow 架构”方面的文章，Stack Overflow已经发生了很大的变化。那篇文章更多关注的是Stack Overflow如何解决网站的扩展性(scale-up)问题，而经过几年的发展，Stack Overflow已经长大成人，成长为了大型网站。</p>
<p>Stack Overflow has grown up by more then doubling in size to over 16 million users and multiplying its number of page views nearly 6 times to 95 million page views a month.</p>
<p>现在与2009年相比，Stack Overflow每月独立访问用户翻了一倍，超过1600万；每月PV翻了近6倍，达到9500万。</p>
<p>Stack Overflow has grown out by expanding into the <a href="http://stackexchange.com/">Stack Exchange Network</a>, which includes Stack Overflow, Server Fault, and Super User for a grand total of 43 different sites. That&#8217;s a lot of fruitful multiplying going on.</p>
<p>Stack Overflow新增了很多站点，比如Server Fault, Super User等，共有43个不同站点组成了Stack Exchange Network，可谓硕果累累，迅猛增长。</p>
<p>What hasn&#8217;t changed is Stack Overflow&#8217;s openness about what they are doing. And that&#8217;s what prompted this update. A recent series of posts talks a lot about how they&#8217;ve been handling their growth: <a href="http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/">Stack Exchange’s Architecture in Bullet Points</a>, <a href="http://blog.serverfault.com/post/1432571770/">Stack Overflow’s New York Data Center</a>, <a href="http://blog.serverfault.com/post/1097492931/">Designing For Scalability of Management and Fault Tolerance</a>, <a href="http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/">Stack Overflow Search — Now 81% Less</a>, <a href="http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/">Stack Overflow Network Configuration</a>, <a href="http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how">Does StackOverflow use caching and if so, how?</a>, <a href="http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network">Which tools and technologies build the Stack Exchange Network?</a>.</p>
<p>Stack Overflow的变化翻天覆地，而不变的是他们开放的心态，所以才有了这篇架构分享的文章。最近，他们写了一系列文章分享他们如何应对这样的快速增长。</p>
<p>Some of the more obvious differences across time are:<br />
穿越时空，我们来看看有哪些明显的变化？</p>
<ul>
<li><strong>Just More</strong>. More users, more page views, more datacenters, more sites, more developers, more operating systems, more databases, more machines. Just a lot<a href="http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/">more of more</a>.<br />
<strong>更多：</strong>更多的用户，更多的PV，更多的数据中心，更多的站点，更多的开发者，更多的操作系统，更多的数据库，更多的服务器&#8230;</li>
<li><strong>Linux</strong>. Stack Overflow was known for their Windows stack, now they are using a lot more Linux machines for HAProxy, Redis, Bacula, Nagios, logs, and routers. All support functions seem to be handled by Linux, which has required the development of <a href="http://blog.serverfault.com/post/1097492931/">parallel release processes</a>.<br />
<strong>Linux：</strong>Stack Overflow因使用Windows系统而著称，现在他们使用越来越多的Linux服务器，比如HAProxy(负载均衡), Redis(NoSQL数据库), Bacula(数据备份系统), Nagios(远程监控软件), 日志, 路由器都运行于Linux系统，几乎所有需要并行处理的功能都是由Linux处理(这句话的翻译可能不准确)。</li>
<li><strong>Fault Tolerance</strong>. Stack Overflow is now <a href="http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/">being served by two different</a> switches on two different internet connections, they&#8217;ve added redundant machines, and some functions have moved to a second datacenter.<br />
<strong>容错：</strong>Stack Overflow使用了两条不同的互联网线路，增加了更多的冗余服务器，将一些网站服务运行于第二个数据中心。</li>
<li><strong>NoSQL</strong>. Redis is now used as a <a href="http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how">caching layer</a> for the entire network. There wasn&#8217;t a separate caching tier before so this a big change, as is using a NoSQL database on Linux.<br />
<strong>NoSQL：</strong>Redis作为整个网站的缓存层。这是一个巨大的改变，以前并没有将缓存作为一个独立的层分离出来。Redis运行于Linux。</li>
</ul>
<p>Unfortunately, I couldn&#8217;t find any coverage on some of the open questions I had last time, like how they were going to deal with multi-tenancy across so many diffrent properties, but there&#8217;s still plenty to learn from. Here&#8217;s a roll up a few different sources:</p>
<p>遗憾的是，一些我关注的问题并没有从中找到答案，比如面对这么多不同的系统，如何解决多租户的问题（Multi-tenancy 是一种软件体系结构，在这种体系结构中软件运行在 software as a service 服务商的服务器上，服务于多个客户组织即 tenant）。但是，从中我们依然可以学到很多。下面是收集的一些数据列表：</p>
<h3>The Stats</h3>
<ul>
<li>95 Million Page Views a Month</li>
<li>800 HTTP requests a second</li>
<li>180 DNS requests a second</li>
<li>55 Megabits per second</li>
<li>16 Million Users  &#8211; Traffic to Stack Overflow grew 131% in 2010, to 16.6 million global monthly uniques.</li>
</ul>
<h3>Data Centers</h3>
<ul>
<li>1 Rack with Peak Internet in OR (Hosts our chat and Data Explorer)</li>
<li>2 Racks with Peer 1 in NY (Hosts the rest of the Stack Exchange Network)</li>
</ul>
<h3>Hardware</h3>
<ul>
<li>10 Dell R610 IIS web servers (3 dedicated to Stack Overflow):
<ul>
<li>1x Intel Xeon Processor E5640 @ 2.66 GHz Quad Core with 8 threads</li>
<li>16 GB RAM</li>
<li>Windows Server 2008 R2</li>
</ul>
</li>
</ul>
<ul>
<li>2 Dell R710 database servers:
<ul>
<li>2x Intel Xeon Processor X5680 @ 3.33 GHz</li>
<li>64 GB RAM</li>
<li>8 spindles</li>
<li>SQL Server 2008 R2</li>
</ul>
</li>
</ul>
<ul>
<li>2 Dell R610 HAProxy servers:
<ul>
<li>1x Intel Xeon Processor E5640 @ 2.66 GHz</li>
<li>4 GB RAM</li>
<li>Ubuntu Server</li>
</ul>
</li>
</ul>
<ul>
<li>2 Dell R610 Redis servers:
<ul>
<li>2x Intel Xeon Processor E5640 @ 2.66 GHz</li>
<li>16 GB RAM</li>
<li>CentOS</li>
</ul>
</li>
</ul>
<ul>
<li>1 Dell R610 Linux backup server running Bacula:
<ul>
<li>1x Intel Xeon Processor E5640 @ 2.66 GHz</li>
<li>32 GB RAM</li>
</ul>
</li>
</ul>
<ul>
<li>1 Dell R610 Linux management server for Nagios and logs:
<ul>
<li>1x Intel Xeon Processor E5640 @ 2.66 GHz</li>
<li>32 GB RAM</li>
</ul>
</li>
</ul>
<ul>
<li>2 Dell R610 VMWare ESXi domain controllers:
<ul>
<li>1x Intel Xeon Processor E5640 @ 2.66 GHz</li>
<li>16 GB RAM</li>
</ul>
</li>
</ul>
<ul>
<li>2 Linux routers</li>
<li>5 Dell Power Connect switches</li>
</ul>
<h3>Dev Tools</h3>
<ul>
<li><strong>C#</strong>: Language</li>
<li><strong>Visual Studio 2010 Team Suite</strong>: IDE</li>
<li><strong>Microsoft ASP.NET (version 4.0)</strong>: Framework</li>
<li><strong>ASP.NET MVC 3</strong>: Web Framework</li>
<li><strong>Razor</strong>: View Engine</li>
<li><strong>jQuery 1.4.2</strong>: Browser Framework:</li>
<li><strong>LINQ to SQL, some raw SQL</strong>: Data Access Layer</li>
<li><strong><a href="http://mercurial.selenic.com/" target="_blank">Mercurial</a> and <a href="http://www.fogcreek.com/kiln/" target="_blank">Kiln</a></strong>: Source Control（分布式版本控制系统）</li>
<li><a href="http://www.scootersoftware.com/" target="_blank"><strong>Beyond Compare 3</strong></a>: Compare Tool（文件比较工具）</li>
</ul>
<h3>Software and Technologies Used</h3>
<ul>
<li>Stack Overflow uses a <a href="http://stackoverflow.com/questions/177901/what-does-wisc-stack-mean">WISC</a> stack via <a href="http://blog.stackoverflow.com/2009/03/stack-overflow-and-bizspark/">BizSpark</a></li>
<li><strong>Windows Server 2008 R2 x64</strong>: Operating System</li>
<li><strong>SQL Server 2008 R2</strong> running<strong> Microsoft Windows Server 2008 Enterprise Edition x64</strong>: Database</li>
<li>Ubuntu Server</li>
<li>CentOS</li>
<li><strong>IIS 7.0</strong>: Web Server</li>
<li><a href="http://haproxy.1wt.eu/" target="_blank"><strong>HAProxy</strong></a>: for load balancing（高性能的负载TCP/HTTP均衡器）</li>
<li><strong>Redis</strong>: used as the distributed caching layer.（作为分布式缓存层的NoSQL数据库）</li>
<li><strong>CruiseControl.NET</strong>: for builds and automated deployment（.NET平台的持续集成工具）</li>
<li><strong>Lucene.NET</strong>:  for search</li>
<li><a href="http://www.bacula.org/en/" target="_blank"><strong>Bacula</strong></a>: for backups（开源的数据备份系统）</li>
<li><a href="http://www.nagios.org/" target="_blank"><strong>Nagios</strong></a>: (with <a href="http://n2rrd.diglinks.com/cgi-bin/trac.fcgi">n2rrd</a> and drraw plugins) for monitoring（监视系统运行状态和网络信息的远程监控软件）</li>
<li><strong><a href="http://www.splunk.com/" target="_blank">Splunk</a>:</strong> for logs（日志分析工具）</li>
<li><strong><a href="http://www.red-gate.com/products/dba/sql-monitor/" target="_blank">SQL Monitor</a>:</strong> from Red Gate &#8211; for SQL Server monitoring</li>
<li><strong>Bind</strong>: for DNS</li>
<li><strong><a href="http://www.wowwee.com/en/products/tech/telepresence/rovio/rovio">Rovio</a></strong>:  a little robot (a real robot) allowing remote developers to visit the office “virtually.”</li>
<li><a href="http://www.pingdom.com/" target="_blank"><strong>Pingdom</strong></a>:  an external monitor and alert service.（网站监控服务及网站速度测试工具）</li>
</ul>
<h3>External Bits</h3>
<p>Code that is not included as part of the development tools:</p>
<ul>
<li><a href="http://www.google.com/recaptcha" target="_blank">reCAPTCHA</a>（用于验证码验证，已被Google收购）</li>
<li>DotNetOpenId（.NET 平台上的 OpenID 实现方案）</li>
<li>WMD &#8211; Now developed as open source. See <a href="https://github.com/cky/wmd" target="_blank">github network graph</a> （轻量级所见即所得编辑器）</li>
<li><a href="http://code.google.com/p/google-code-prettify/" target="_blank">Prettify</a>（代码高亮显示）</li>
<li>Google Analytics</li>
<li>Cruise Control .NET</li>
<li>HAProxy（负载均衡）</li>
<li><a href="http://www.cacti.net/" target="_blank">Cacti</a>（网络流量监测图形分析工具）</li>
<li><a href="http://code.google.com/p/markdownsharp/" target="_blank">MarkdownSharp</a>（Markdown文本处理器的C#实现）</li>
<li><a href="http://code.google.com/p/flot/" target="_blank">Flot</a>（基于JQuery的纯JavaScript实现的绘图库）</li>
<li>Nginx（反向代理服务器）</li>
<li>Kiln（分布式版本控制系统）</li>
<li>CDN: none, all static content is served off the <a href="http://sstatic.net/">sstatic.net</a>, which is a fast, cookieless domain intended for static content delivered to the Stack Exchange family of websites.<br />
（没有使用CDN，用一个专门的域名sstatic.net传递所有的静态内容）</li>
</ul>
<h3>Developers and System Administrators</h3>
<ul>
<li>14 Developers</li>
<li>2 System Administrators</li>
</ul>
<h3>Content</h3>
<ul>
<li><strong>License:</strong> Creative Commons Attribution-Share Alike 2.5 Generic</li>
<li><strong>Standards:</strong> OpenSearch, Atom</li>
<li><strong>Host:</strong> PEAK Internet</li>
</ul>
<div id="_mcePaste"></div>
<h3>More Architecture and Lessons Learned</h3>
<ul>
<li>HAProxy is used instead of Windows NLB because HAProxy is cheap, easy, free, works great as a 512MB VM “device” on a network via Hyper-V. It also works in front of the boxes so it’s completely transparent to them, and easier to troubleshoot as a different networking layer instead of being intermixed with all your windows configuration.<br />
用HAProxy取代了Windows NLB，HAProxy成本更低，更易于使用，通过Hyper-V可以很好地运行于512M内存的虚拟机。它工作于服务器群的最前端，对所有的服务器都透明。相比于原来混杂在一起的Windows配置，它运行于一个独立的网络层，更易于维护与故障处理。</li>
<li>A CDN is not used because even “cheap” CDNs like Amazon one are very expensive relative to the bandwidth they get bundled into their existing host’s plan. The least they could pay is $1k/month based on Amazon’s CDN rates and their bandwidth usage.<br />
没有使用CDN，即使使用像Amazon那样与主机空间捆绑在一起的看起来“便宜”的CDN，实际的费用也是很高的，至少需要1000美元/月。</li>
<li>Backup is to disk for fast retrieval and to tape for historical archiving.<br />
备份方案有两种，一种用于快速恢复的磁盘备份，一种用于历史数据存档的磁带备份。</li>
<li>Full Text Search in SQL Server is very badly integrated, buggy, deeply incompetent, so they went to Lucene.<br />
SQL Server的全文索引是非常差劲的，所以他们用Lucene.NET。</li>
<li>Mostly interested in peak HTTP request figures as this is what they need to make sure they can handle.<br />
让人很感兴趣的是他们如何处理访问高峰时的HTTP请求。</li>
<li>All properties now run on the same Stack Exchange platform. That means Stack Overflow, Super User, Server Fault, Meta, WebApps, and Meta Web Apps are all running on the same software.<br />
所有这些都运行于Stack Exchange平台，那意味着Stack Overflow, Super User, Server Fault, Meta, WebApps, 和Meta Web Apps都运行于同一个软件。</li>
<li>There are separate StackExchange sites because people have different sets of expertise that shouldn&#8217;t cross over to different topic sites. <a href="http://meta.stackoverflow.com/questions/69422/why-separate-stack-exchange-accounts">You can be the greatest chef in the world, but that doesn&#8217;t qualify you for fixing a server.</a><br />
也有一些独立运行的StackExchange站点，服务于那些具有多个专业技能，又不想为了不同的话题在多个站点之间奔波的人。如果你能成为最伟大的主厨，不能因为给你安排了服务员的工作，你就安于现状。</li>
<li>They aggressively cache everything.<br />
他们疯狂地使用缓存。</li>
<li>All pages accessed by (and subsequently served to) annonymous users are cached via <a href="http://learn.iis.net/page.aspx/154/walkthrough-iis-70-output-caching/">Output Caching</a>.<br />
未登录用户访问的所有页面都通过Output Caching进行缓存。</li>
<li>Each site has 3 distinct caches: local, site, global.<br />
每个站点使用三种类型的缓存：本地、站点、全局。</li>
<li><strong>local cache</strong>: can only be accessed from 1 server/site pair<br />
本地缓存：只能被当前站点的当前服务器访问。</p>
<ul>
<li>To limit network latency they use a local &#8220;L1&#8243; cache, basically HttpRuntime.Cache, of recently set/read values on a server. This would reduce the cache lookup overhead to 0 bytes on the network.<br />
为了减少网络延时，通常使用HttpRuntime.Cache作为一级缓存，这样可以避免通过网络在缓存服务器上查找的开销。</li>
<li>Contains things like user sessions, and pending view count updates.<br />
缓存内容包含用户会话，视图数的更新。</li>
<li>This resides purely in memory, no network or DB access.<br />
直接缓存在内存中。</li>
</ul>
</li>
<li><strong>site cache</strong>:  can be accessed by any instance (on any server) of a single site<br />
<strong>站点级缓存：</strong>能被同一个站点的所有服务器访问。</p>
<ul>
<li>Most cached values go here, things like hot question id lists and user acceptance rates are good examples<br />
大部分的缓存都在这一级，比如热点问题ID列表，用户支持率。</li>
<li>This resides in Redis (in a distinct DB, purely for easier debugging)<br />
缓存数据存储在Redis数据库中。</li>
<li>Redis is so fast that the slowest part of a cache lookup is the time spent reading and writing bytes to the network.<br />
Redis速度很快，缓存查找的开销主要在网络传输上。</li>
<li>Values are compressed before sending them to Redis. They have plenty of CPU and most of their data are strings so they get a great compression ratio.<br />
缓存数据发送至Redis之前会被压缩。为什么要压缩呢？因为CPU资源绰绰有余，而且大部分缓存数据是字符串，压缩率会很高，何乐而不为呢。</li>
<li>The CPU usage on their Redis machines is 0%.<br />
Redis服务器上的CPU使用率是0%。</li>
</ul>
</li>
<li><strong>global cache</strong>: which is shared amongst all sites and servers<br />
<strong>全局缓存：</strong>被所有站点和服务器共享。</p>
<ul>
<li>Inboxes, API usage quotas, and a few other truly global things live here<br />
缓存内容包含收件箱，API使用限额，一些全局设置等。</li>
<li>This resides in Redis (in DB 0, likewise for easier debugging)<br />
缓存于Redis数据库中。</li>
</ul>
</li>
<li>Most items in the cache expire after a timeout period (a few minutes usually) and are never explicitly removed. When a specific cache invalidation is required they use <a href="http://code.google.com/p/redis/wiki/PublishSubscribe">Redis messaging</a> to publish removal notices to the &#8220;L1&#8243; caches.<br />
大部分缓存项目在超过缓存时间之后会自动过期（通常几分钟），不需要进行删除操作。当需要让一个特定的缓存失效，会通过Redis消息系统给一级缓存发送删除通知。</li>
<li>Joel Spolsky is not a Microsoft Loyalist, he doesn&#8217;t make the technical decisions for Stack Overflow, and considers Microsoft licensing a rounding error. Consider yourself corrected <a href="http://news.ycombinator.com/item?id=2284900">Hacker News commentor</a>.<br />
Joel Spolsky（Stack Overflow的创始人）并不是微软的忠诚分子，他不负责技术决策，使用微软软件考虑的也只是性价比。Hacker News上一些评论者的说法需要纠正。</li>
<li>For their IO system <a href="http://blog.serverfault.com/post/our-storage-decision/">they selected</a> a RAID 10 array of <a href="http://www.intel.com/design/flash/nand/extreme/index.htm">Intel X25 solid state drives</a> . The RAID array eased any concerns about reliability and the SSD drives performed really well in comparision to FusionIO at a much cheaper price.<br />
对于IO系统，他们选择的是Intel X25 solid state drives(SSD硬盘)的RAID 10磁盘阵列，这样的磁盘阵列，保证了可靠性。这个SSD硬盘用起来感觉不错，而且价格比FusionIO的便宜。</li>
<li>The <a href="http://news.ycombinator.com/item?id=2285931">full boat cost</a> for their Microsoft licenses would be approximately $242K. Since Stack Overflow is using Bizspark they are not paying near the full sticker price, but that&#8217;s the max they could pay.<br />
使用的这些微软软件，如果全部购买的话，总费用大概在24.2万美元。由于Stack Overflow参加了微软的Bizspark计划，所以不需要付这么多钱，但是要付的话，最多也就是这么多。</li>
</ul>
<h2>Related Articles</h2>
<ul>
<li><a href="http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/">Stack Exchange’s Architecture in Bullet Points</a></li>
<li><a href="http://blog.serverfault.com/post/1432571770/">Stack Overflow’s New York Data Center</a> &#8211; hardware of the various machines?</li>
<li><a href="http://blog.serverfault.com/post/1097492931/">Designing For Scalability of Management and Fault Tolerance</a></li>
<li><a href="http://news.ycombinator.com/item?id=2207789">HackerNews Thread</a></li>
<li><a href="http://blog.stackoverflow.com/">Stack Overflow Blog</a></li>
<li><a href="http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/">Stack Overflow Search — Now 81% Less Crappy</a> &#8211; Lucene is now running on an underused cluster.</li>
<li><a href="http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/">State of the Stack 2010 (a message from your CEO)</a></li>
<li><a href="http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/">Stack Overflow Network Configuration</a></li>
<li><a href="http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how">Does StackOverflow use caching and if so, how?</a></li>
<li><a href="http://meta.stackoverflow.com/">Meta StackOverflow</a></li>
<li><a href="http://meta.stackoverflow.com/questions/6435/how-does-stackoverflow-handle-cache-invalidation">How does StackOverflow handle cache invalidation?</a></li>
<li><a href="http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network">Which tools and technologies build the Stack Exchange Network?</a></li>
<li><a href="http://meta.stackoverflow.com/questions/2765/how-does-stack-overflow-handle-spam">How does Stack Overflow handle spam?</a></li>
<li><a href="http://blog.serverfault.com/post/our-storage-decision/">Our Storage Decision</a></li>
<li><a href="http://meta.stackoverflow.com/questions/4766/how-are-hot-questions-selected">How are “Hot” Questions Selected?</a></li>
<li><a href="http://meta.stackoverflow.com/questions/20473/how-are-related-questions-selected">How are “related” questions selected?</a> &#8211; the title, the question body, and the tags.</li>
<li><a href="http://blog.stackoverflow.com/2010/04/stack-overflow-and-dvcs/">Stack Overflow and DVCS</a> &#8211; Stack Overflow selects Mercurial for source code control.</li>
<li><a href="http://chat.stackexchange.com/rooms/127/the-comms-room">Server Fault Chat Room</a></li>
<li><a href="https://github.com/ServiceStack/ServiceStack.Redis">C# Redis Client</a></li>
</ul>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-563" data-post-type="none" ><a href="http://jianyun.org/archives/563.html" class="wp_rp_title">使用GhostDoc在Visual Studio中为代码生成注释</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-558" data-post-type="none" ><a href="http://jianyun.org/archives/558.html" class="wp_rp_title">安装.Net Framework 2.0 SP2后，连接oracle出现错误信息的经历和解决方案</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-315" data-post-type="none" ><a href="http://jianyun.org/archives/315.html" class="wp_rp_title">.Net remoting error &#8220;The input stream is not a valid binary format.&#8221;</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/987.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>UMDEditor更新到V2.7.3,新增合并章节，优化程序性能</title>
		<link>http://jianyun.org/archives/983.html</link>
		<comments>http://jianyun.org/archives/983.html#comments</comments>
		<pubDate>Wed, 16 Jan 2013 02:39:00 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[软件介绍]]></category>
		<category><![CDATA[TXT转UMD]]></category>
		<category><![CDATA[UMD编辑器]]></category>
		<category><![CDATA[UMD转TXT]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=983</guid>
		<description><![CDATA[下面是具体的更新内容： ============================ &#8230; <a href="http://jianyun.org/archives/983.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>下面是具体的更新内容：</p>
<p>===============================================================================</p>
<p>2.7.3 (2014-8-18)<br />
增加选项-设置菜单<br />
增加导入txt文件为章节和多个txt文件批量转换为一个umd文件时，设置默认的章节名的功能<br />
批量转换的目标文件夹路径默认为源文件夹路径</p>
<p>2.7.2 (2013-1-17)<br />
修正导入导出txt文件的编码问题<br />
修正拖曳逻辑</p>
<p>2.7.1 (2013-1-16)<br />
新增合并章节的功能，多选章节后右键合并<br />
新增拖拽txt文件到章节栏来添加章节的功能<br />
优化鼠标拖动调整章节目录时的判断逻辑<br />
优化保存逻辑<br />
优化查找和替换功能，提高全部替换的性能<br />
优化内存占用</p>
<p><strong>新版UMDEditor V2.7.3下载</strong>：<a title="UmdEditor-V2.7.3.zip" href="http://jianyun.org/downloads/UmdEditor-V2.7.3.zip" target="_blank">UmdEditor-V2.7.3.zip</a></p>
<p>下载次数：200</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-606" data-post-type="none" ><a href="http://jianyun.org/archives/606.html" class="wp_rp_title">PC端UMDEditorV2.4发布，新增自动更新及章节顺序调整功能等</a><small class="wp_rp_comments_count"> (2)</small><br /></li><li data-position="1" data-poid="in-727" data-post-type="none" ><a href="http://jianyun.org/archives/727.html" class="wp_rp_title">PC端UmdEditor更新到V2.6，新增字体颜色设置，加强查找替换等编辑功能</a><small class="wp_rp_comments_count"> (22)</small><br /></li><li data-position="2" data-poid="in-612" data-post-type="none" ><a href="http://jianyun.org/archives/612.html" class="wp_rp_title">PC端UMDEditorV2.4.1发布，解决一些问题和新增章节多选拖曳</a><small class="wp_rp_comments_count"> (3)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/983.html/feed</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>CAT.NET简介</title>
		<link>http://jianyun.org/archives/964.html</link>
		<comments>http://jianyun.org/archives/964.html#comments</comments>
		<pubDate>Mon, 15 Oct 2012 07:24:30 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[软件介绍]]></category>
		<category><![CDATA[.Net]]></category>
		<category><![CDATA[ASP.NET]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=964</guid>
		<description><![CDATA[CAT.NET(Microsoft Code Analysis Tool .NE &#8230; <a href="http://jianyun.org/archives/964.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>CAT.NET(Microsoft Code Analysis Tool .NET)是一套微软推出的基于Web应用程序（ASP.NET）进行静态代码安全检测工具。</p>
<p>它可以找出网页是否存在可被利用的安全漏洞，如Cross-Site Scripting (XSS), SQL Injection, XPath Injection, File Canonicalization, … 等知名且常见的漏洞，目前有8条规则，但规则都是以XML定义的，很容易扩展。</p>
<p>&nbsp;</p>
<p>CAT.NET的使用有两种方式：</p>
<h4>1. 直接从Visual Studio中启动作为插件的CAT.NET Code Analysis工具</h4>
<p>打开solution之后，通过Tools -&gt; CAT.NET Code Analysis菜单来开启工具窗口。</p>
<p style="text-align: center;"><a href="http://jianyun.org/archives/964.html/image" rel="attachment"><img class="size-full wp-image-965 aligncenter" title="image" src="http://jianyun.org/wordpress/wp-content/uploads/2012/10/image.png" alt="" width="298" height="540" /></a></p>
<p>然后点击启动检测即可</p>
<p><a href="http://jianyun.org/archives/964.html/image2" rel="attachment"><img class="aligncenter size-full wp-image-966" title="image2" src="http://jianyun.org/wordpress/wp-content/uploads/2012/10/image2.png" alt="" width="584" height="218" /></a></p>
<p>正常只需要使用默认的规则即可，如果需要自定义规则，可以自行设定。</p>
<p><a href="http://jianyun.org/archives/964.html/image3" rel="attachment"><img class="aligncenter size-full wp-image-967" title="image3" src="http://jianyun.org/wordpress/wp-content/uploads/2012/10/image3.png" alt="" width="584" height="464" /></a></p>
<p>扫描完毕后，工具会生成检测报告，可以定位到代码级别。</p>
<p><a href="http://jianyun.org/archives/964.html/cat_net_3" rel="attachment"><img class="aligncenter size-full wp-image-968" title="cat_net_3" src="http://jianyun.org/wordpress/wp-content/uploads/2012/10/cat_net_3.jpg" alt="" width="673" height="307" /></a></p>
<p>&nbsp;</p>
<p>不过这套工具微软出了都好几年了，版本还只有v1 CTP，不知道还更不更新了。我在使用这种方式分析稍微大一点的project的时候，Visual Studio会直接挂掉。</p>
<p>这种情况下，只能使用第二种命令行调用的方法了。</p>
<p>&nbsp;</p>
<p>还有一个，当初微软出这套工具的时候，还没有VS2010，所以如果是VS2010的话，需要手工修改插件配置文件来使用。</p>
<p>步骤如下：</p>
<p>1） 通过记事本等文本编辑器打开%APPDATA%\Microsoft\MSEnvShared\Addins\Microsoft.ACESec.CATNet.AddIn文件</p>
<p>2） 在&#8221;&lt;Version&gt;9.0&lt;/Version&gt;&#8221;下面多加一行&#8221;&lt;Version&gt;10.0&lt;/Version&gt;&#8221;以支持VS2010</p>
<p>3） 重启VS2010</p>
<p>&nbsp;</p>
<h4>2. 在命令窗口下执行扫描工具</h4>
<p><a href="http://jianyun.org/archives/964.html/cat_net_4" rel="attachment"><img class="aligncenter size-full wp-image-969" title="cat_net_4" src="http://jianyun.org/wordpress/wp-content/uploads/2012/10/cat_net_4.jpg" alt="" width="677" height="330" /></a></p>
<p>执行完之后，会在同目录下看到两个生成的文件，其中MicrosoftACECodeAnalysisReport.xml是完整的分析报告，以XML方式存储。另一个是report.html是给人看的，里面有问题描述、出现问题的代码行号、代码片段以及建议的解决方案。</p>
<p>&nbsp;</p>
<p>遗憾的是，这个工具微软出了之后，好几年都没更新过，建议的解决方案中有使用Anti-XSS库的，Anti-XSS库都更新到了4.2版本了，我使用了后，重新扫描，CAT.NET竟然不认。。。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-954" data-post-type="none" ><a href="http://jianyun.org/archives/954.html" class="wp_rp_title">Microsoft Anti-Cross Site Scripting Library</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="1" data-poid="in-586" data-post-type="none" ><a href="http://jianyun.org/archives/586.html" class="wp_rp_title">在Custom Control中添加CSS</a><small class="wp_rp_comments_count"> (0)</small><br /></li><li data-position="2" data-poid="in-944" data-post-type="none" ><a href="http://jianyun.org/archives/944.html" class="wp_rp_title">ASP.NET中Session造成请求阻塞现象</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/964.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>文件名/路径去除非法字符的方法，CSV格式文件Encode方法</title>
		<link>http://jianyun.org/archives/959.html</link>
		<comments>http://jianyun.org/archives/959.html#comments</comments>
		<pubDate>Sun, 14 Oct 2012 12:36:34 +0000</pubDate>
		<dc:creator><![CDATA[Jian Yun]]></dc:creator>
				<category><![CDATA[编程点滴]]></category>
		<category><![CDATA[.Net]]></category>
		<category><![CDATA[C#]]></category>

		<guid isPermaLink="false">http://jianyun.org/?p=959</guid>
		<description><![CDATA[1. 文件名去除非法字符 /// &#60;summary&#62; /// Rem &#8230; <a href="http://jianyun.org/archives/959.html">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>1. 文件名去除非法字符</p>
<pre class="brush:c#;toolbar:false;">/// &lt;summary&gt;
/// Remove invalid characters which are not allowed in the file name
/// &lt;/summary&gt;
/// &lt;param name="fileName"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static string RemoveFileNameInvalidChar(this string fileName)
{
    if (string.IsNullOrEmpty(fileName))
        return fileName;
    string invalidChars = new string(Path.GetInvalidFileNameChars());
    string invalidReStr = string.Format("[{0}]", Regex.Escape(invalidChars));
    return Regex.Replace(fileName, invalidReStr, "");
}</pre>
<p>&nbsp;</p>
<p>2. 文件路径去除非法字符</p>
<pre class="brush:c#;toolbar:false;">/// &lt;summary&gt;
/// Remove invalid characters which are not allowed in the path names
/// &lt;/summary&gt;
/// &lt;param name="filePath"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static string RemovePathInvalidChar(this string filePath)
{
    if (string.IsNullOrEmpty(filePath))
        return filePath;
    string invalidChars = new string(Path.GetInvalidPathChars());
    string invalidReStr = string.Format("[{0}]", Regex.Escape(invalidChars));
    return Regex.Replace(filePath, invalidReStr, "");
}</pre>
<p>&nbsp;</p>
<p>3. 输出CSV格式的文件时的Encode方法</p>
<pre class="brush:c#;toolbar:false;">/// &lt;summary&gt;
/// Encode the field in the CSV format file
/// &lt;/summary&gt;
/// &lt;param name="field"&gt;CSV field string&lt;/param&gt;
/// &lt;returns&gt;Encoded field string&lt;/returns&gt;
public static string CsvFieldEncode(this string field)
{
    if (string.IsNullOrEmpty(field))
        return field;
    bool quotesRequired = field.Contains(",");
    bool escapeQuotes = field.Contains("\"");
    string fieldValue = (escapeQuotes ? field.Replace("\"", "\"\"") : field);
    return string.Format("{0}{1}{0}",
            (quotesRequired || escapeQuotes ? "\"" : string.Empty),
            fieldValue);
}</pre>
<p>&nbsp;</p>

<div class="wp_rp_wrap  wp_rp_plain" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li data-position="0" data-poid="in-241" data-post-type="none" ><a href="http://jianyun.org/archives/241.html" class="wp_rp_title">使用一个HttpModule拦截Http请求，来检测页面刷新(F5或正常的请求)</a><small class="wp_rp_comments_count"> (2)</small><br /></li><li data-position="1" data-poid="in-644" data-post-type="none" ><a href="http://jianyun.org/archives/644.html" class="wp_rp_title">文件名智能排序的规则与算法</a><small class="wp_rp_comments_count"> (1)</small><br /></li><li data-position="2" data-poid="in-595" data-post-type="none" ><a href="http://jianyun.org/archives/595.html" class="wp_rp_title">从AD中根据group name获取group下所有的用户信息</a><small class="wp_rp_comments_count"> (0)</small><br /></li></ul></div></div>
]]></content:encoded>
			<wfw:commentRss>http://jianyun.org/archives/959.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>

<!-- Dynamic page generated in 0.248 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2015-09-17 14:36:11 -->
