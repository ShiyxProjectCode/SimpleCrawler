<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园_dudu</title>
  <subtitle type="text">为程序员打杂的站长</subtitle>
  <id>uuid:283f8d56-61ca-49a6-8cba-78657ba4eeb7;id=752</id>
  <updated>2015-09-15T05:08:16Z</updated>
  <author>
    <name>dudu</name>
    <uri>http://www.cnblogs.com/dudu/</uri>
  </author>
  <generator>feed.cnblogs.com</generator>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4804574.html</id>
    <title type="text">“状态机”学习笔记 - dudu</title>
    <summary type="text">有限状态机FSM思想广泛应用于硬件控制电路设计，也是软件上常用的一种处理方法（软件上称为FMM有限消息机）。它把复杂的控制逻辑分解成有限个稳定状态，在每个状态上判断事件，变连续处理为离散数字处理，符合计算机的工作特点。</summary>
    <published>2015-09-13T05:24:00Z</published>
    <updated>2015-09-13T05:24:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4804574.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4804574.html" />
    <content type="html">有限状态机FSM思想广泛应用于硬件控制电路设计，也是软件上常用的一种处理方法（软件上称为FMM有限消息机）。它把复杂的控制逻辑分解成有限个稳定状态，在每个状态上判断事件，变连续处理为离散数字处理，符合计算机的工作特点。&lt;img src="http://counter.cnblogs.com/blog/rss/4804574" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4804574.html" target="_blank"&gt;“状态机”学习笔记&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4760425.html</id>
    <title type="text">HttpClient读取ASP.NET Web API错误信息的简单方法 - dudu</title>
    <summary type="text">在C#中，用HttpClient调用Web API并且通过Content.ReadAsStringAsync()读取响应内容时，如果出现500错误（InternalServerError），会得到一个包含错误信息的json字符串。这样一个复杂的字符串可读性很差，通常只需要部分信息（比如ExceptionMessage）就可以知道错误的情况。那如何读取所需的部分信息呢？</summary>
    <published>2015-08-26T06:56:00Z</published>
    <updated>2015-08-26T06:56:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4760425.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4760425.html" />
    <content type="html">在C#中，用HttpClient调用Web API并且通过Content.ReadAsStringAsync()读取响应内容时，如果出现500错误（InternalServerError），会得到一个包含错误信息的json字符串。这样一个复杂的字符串可读性很差，通常只需要部分信息（比如ExceptionMessage）就可以知道错误的情况。那如何读取所需的部分信息呢？&lt;img src="http://counter.cnblogs.com/blog/rss/4760425" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4760425.html" target="_blank"&gt;HttpClient读取ASP.NET Web API错误信息的简单方法&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4739605.html</id>
    <title type="text">开发笔记：用Owin Host实现脱离IIS跑Web API单元测试 - dudu</title>
    <summary type="text">今天在开发一个ASP.NET Web API项目写单元测试时，实在无法忍受之前的笨方法，决定改过自新。这次经历再次证明了，当有一个问题影响你写代码的乐趣时，一定要尽早下定决心解决它，否则它浪费的时间很可能是解决这个问题所需时间的n倍，而且很多时候解决一个问题的难易程度取决于你下的决心有多大。</summary>
    <published>2015-08-18T09:00:00Z</published>
    <updated>2015-08-18T09:00:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4739605.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4739605.html" />
    <content type="html">今天在开发一个ASP.NET Web API项目写单元测试时，实在无法忍受之前的笨方法，决定改过自新。这次经历再次证明了，当有一个问题影响你写代码的乐趣时，一定要尽早下定决心解决它，否则它浪费的时间很可能是解决这个问题所需时间的n倍，而且很多时候解决一个问题的难易程度取决于你下的决心有多大。&lt;img src="http://counter.cnblogs.com/blog/rss/4739605" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4739605.html" target="_blank"&gt;开发笔记：用Owin Host实现脱离IIS跑Web API单元测试&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4735211.html</id>
    <title type="text">开发笔记：基于EntityFramework.Extended用EF实现指定字段的更新 - dudu</title>
    <summary type="text">今天在将一个项目中使用存储过程的遗留代码迁移至新的架构时，遇到了一个问题——如何用EF实现数据库中指定字段的更新（根据UserId更新Users表中的FaceUrl与AvatarUrl字段）？最终验证了，添加IUnitOfWork.UpadteAsync()接口，基于EntityFramework.Extended，用EF实现数据库中指定字段的更新，这种方法在实际开发中使用完全可行。</summary>
    <published>2015-08-17T05:22:00Z</published>
    <updated>2015-08-17T05:22:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4735211.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4735211.html" />
    <content type="html">今天在将一个项目中使用存储过程的遗留代码迁移至新的架构时，遇到了一个问题——如何用EF实现数据库中指定字段的更新（根据UserId更新Users表中的FaceUrl与AvatarUrl字段）？最终验证了，添加IUnitOfWork.UpadteAsync()接口，基于EntityFramework.Extended，用EF实现数据库中指定字段的更新，这种方法在实际开发中使用完全可行。&lt;img src="http://counter.cnblogs.com/blog/rss/4735211" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4735211.html" target="_blank"&gt;开发笔记：基于EntityFramework.Extended用EF实现指定字段的更新&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4721797.html</id>
    <title type="text">ASP.NET OAuth：解决refresh token无法刷新access token的问题 - dudu</title>
    <summary type="text">最近同事用iOS App调用Open API时遇到一个问题：在access token过期后，用refresh token刷新access token时，服务器响应"invalid_grant"错误；而在access token没有过期的情况下，能正常刷新access token。先查看了一下OAuth规范中的“Refreshing an Expired Access Token”流程图，以确认客户端的操作流程有没有问题。</summary>
    <published>2015-08-16T14:12:00Z</published>
    <updated>2015-08-16T14:12:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4721797.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4721797.html" />
    <content type="html">最近同事用iOS App调用Open API时遇到一个问题：在access token过期后，用refresh token刷新access token时，服务器响应"invalid_grant"错误；而在access token没有过期的情况下，能正常刷新access token。先查看了一下OAuth规范中的“Refreshing an Expired Access Token”流程图，以确认客户端的操作流程有没有问题。&lt;img src="http://counter.cnblogs.com/blog/rss/4721797" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4721797.html" target="_blank"&gt;ASP.NET OAuth：解决refresh token无法刷新access token的问题&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4705247.html</id>
    <title type="text">通过git rebase修改commit message - dudu</title>
    <summary type="text">今天发现一个项目的git commit message中的单词拼错了，需要修改一下。但这样简单的修改，需要通过git rebase才能完成。首先要git rebase到需要修改message的那个commit的前1个commit。假设commit id是32e0a87f，运行下面的git rebase命令：git rebase -i 32e0a87f。在git bash中运行上面的命令后，会弹出编辑框</summary>
    <published>2015-08-05T09:09:00Z</published>
    <updated>2015-08-05T09:09:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4705247.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4705247.html" />
    <content type="html">今天发现一个项目的git commit message中的单词拼错了，需要修改一下。但这样简单的修改，需要通过git rebase才能完成。首先要git rebase到需要修改message的那个commit的前1个commit。假设commit id是32e0a87f，运行下面的git rebase命令：git rebase -i 32e0a87f。在git bash中运行上面的命令后，会弹出编辑框&lt;img src="http://counter.cnblogs.com/blog/rss/4705247" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4705247.html" target="_blank"&gt;通过git rebase修改commit message&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4679592.html</id>
    <title type="text">ASP.NET OWIN OAuth：遇到的2个refresh token问题 - dudu</title>
    <summary type="text">之前写过2篇关于refresh token的生成与持久化的博文。后来发现一个问题（这是遇到的第1个问题），在用户不登录的情况下，以client credentials grant方式获取access token时，也会生成refresh token并且保存至数据库。</summary>
    <published>2015-07-27T08:16:00Z</published>
    <updated>2015-07-27T08:16:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4679592.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4679592.html" />
    <content type="html">之前写过2篇关于refresh token的生成与持久化的博文。后来发现一个问题（这是遇到的第1个问题），在用户不登录的情况下，以client credentials grant方式获取access token时，也会生成refresh token并且保存至数据库。&lt;img src="http://counter.cnblogs.com/blog/rss/4679592" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4679592.html" target="_blank"&gt;ASP.NET OWIN OAuth：遇到的2个refresh token问题&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4660986.html</id>
    <title type="text">求同存异：持久化从文件到数据库引发的架构变动 - dudu</title>
    <summary type="text">在前一篇博文中，突发奇想地用文件存储实现了oauth refresh token的持久化。在这篇博文中，我们将面对现实地将文件存储改为数据库存储。既然软件开发中唯一不变的就是变化本身，那我们主动求变，用变化来验证代码的设计是否能随机应变。</summary>
    <published>2015-07-20T09:34:00Z</published>
    <updated>2015-07-20T09:34:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4660986.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4660986.html" />
    <content type="html">在前一篇博文中，突发奇想地用文件存储实现了oauth refresh token的持久化。在这篇博文中，我们将面对现实地将文件存储改为数据库存储。既然软件开发中唯一不变的就是变化本身，那我们主动求变，用变化来验证代码的设计是否能随机应变。&lt;img src="http://counter.cnblogs.com/blog/rss/4660986" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4660986.html" target="_blank"&gt;求同存异：持久化从文件到数据库引发的架构变动&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/nginx-subs_filter.html</id>
    <title type="text">编译nginx的源码安装subs_filter模块 - dudu</title>
    <summary type="text">使用nginx的反向代理功能搭建nuget镜像服务器时，需要针对官方nuget服务器的响应内容进行字符串替换，比如将www.nuget.org替换为镜像服务器的主机名，将https://替换为http://。而nginx没有内置这个功能，需要使用第三方module，比如subs_filter。</summary>
    <published>2015-07-19T08:11:00Z</published>
    <updated>2015-07-19T08:11:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/nginx-subs_filter.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/nginx-subs_filter.html" />
    <content type="html">使用nginx的反向代理功能搭建nuget镜像服务器时，需要针对官方nuget服务器的响应内容进行字符串替换，比如将www.nuget.org替换为镜像服务器的主机名，将https://替换为http://。而nginx没有内置这个功能，需要使用第三方module，比如subs_filter。&lt;img src="http://counter.cnblogs.com/blog/rss/4658497" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/nginx-subs_filter.html" target="_blank"&gt;编译nginx的源码安装subs_filter模块&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/dudu/p/4654114.html</id>
    <title type="text">HttpClient与APS.NET Web API：请求内容的压缩与解压 - dudu</title>
    <summary type="text">对于请求内容的http compression，.NET中的HttpClient并没有提供对压缩的内置支持，IIS也没有提供对解压的内置支持，需要自己写代码实现，本文也是由此而生。对于压缩与解压，System.IO.Compression中提供了对应的类库——GZipStream与DeflateStream，我们只需要在HttpClient与Web API中应用它们即可。</summary>
    <published>2015-07-17T09:33:00Z</published>
    <updated>2015-07-17T09:33:00Z</updated>
    <author>
      <name>dudu</name>
      <uri>http://www.cnblogs.com/dudu/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/dudu/p/4654114.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/dudu/p/4654114.html" />
    <content type="html">对于请求内容的http compression，.NET中的HttpClient并没有提供对压缩的内置支持，IIS也没有提供对解压的内置支持，需要自己写代码实现，本文也是由此而生。对于压缩与解压，System.IO.Compression中提供了对应的类库——GZipStream与DeflateStream，我们只需要在HttpClient与Web API中应用它们即可。&lt;img src="http://counter.cnblogs.com/blog/rss/4654114" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/dudu/p/4654114.html" target="_blank"&gt;HttpClient与APS.NET Web API：请求内容的压缩与解压&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
</feed>