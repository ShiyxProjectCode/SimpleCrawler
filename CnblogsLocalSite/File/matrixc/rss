        		<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
    <title>MatrixC的博客</title> 
    <link>http://my.oschina.net/matrixc</link> 
    <description>MatrixC的博客</description>
    <language>zh-CN</language>
    <pubDate>Sat, 04 May 2013 12:25:10 +0800</pubDate>    
	<image>
		<link>http://my.oschina.net/matrixc</link>
		<url>http://static.oschina.net/uploads/user/$__user.SmallPortrait()</url>
		<title>MatrixC</title>
	</image>
				<item>
        <title>C# 计算表达式 支持自定义函数</title>
        <link>http://my.oschina.net/matrixc/blog/127218</link>
        <category>工作日志</category>
        <description><![CDATA[http://www.mssle.net/archives/125

看了网上一些解决C#运算表达式的思路，感觉大致有三种思路。

1.调用javascript中的eval函数。

2.用.net 的动态编译。

3.程序解析字符串，得出运算结果。

第一种方法感觉不灵活，效率估计也不会很高。
动态编译的话运行速度应该会很快，但调用动态编译模块可能会占用比较大的内存。

解析字符串运算，实现起来比较麻烦，但可以灵活的处理，扩展。
为了解决字符串处理麻烦的问题，我用了正则表达式，可以减少大量的代码。

如果只是类似这种简单的括带括号的加减乘除运算，只需以下代码即可。

((-234.5823423+2342/23423)--2342+(-232.6*22.65)*5.98-76.88)

  ```


    class MExpress
    {
        private static Regex inBracket = new Regex(@"\(([0-9\+\-\*\/\.]+)\)");
        private static Regex twoNumberMD = new Regex(@"\(?(-?\d+(\.\d+)?)\)?([\*\/])\(?(-?\d+(\.\d+)?)\)?");
        private static Regex twoNumberAE = new Regex(@"\(?(-?\d+(\.\d+)?)\)?([+-])\(?(-?\d+(\.\d+)?)\)?");

        private string calcTwoNumber(string left, string oper, string right)
        {
            switch (oper)
            {
                case "+": return (Convert.ToSingle(left) + Convert.ToSingle(right)).ToString();
                case "-": return (Convert.ToSingle(left) - Convert.ToSingle(right)).ToString();
                case "*": return (Convert.ToSingle(left) * Convert.ToSingle(right)).ToString();
                case "/": return (Convert.ToSingle(left) / Convert.ToSingle(right)).ToString();
                default: return string.Empty;
            }
        }
        private string calcExpressNoBracket(String exp)
        {
            Match m = null;
            while (true)
            {
                m = twoNumberMD.Match(exp);
                if (m.Success)
                    exp = calcReplace(m, exp);
                else
                {
                    m = twoNumberAE.Match(exp);
                    if (m.Success)
                        exp = calcReplace(m, exp);
                    else
                        break;
                }
            }
            return exp;
        }
        private string calcReplace(Match m, string express)
        {
            string result = calcTwoNumber(m.Groups[1].Value, m.Groups[3].Value, m.Groups[4].Value);
            express = express.Replace(m.Groups[0].Value, result);
            return express;
        }
        public string runExpress(string exp)
        {
            Match m = null;
            while (true)
            {
                m = inBracket.Match(exp);
                if (m.Success)
                    exp = exp.Replace(m.Groups[0].Value, calcExpressNoBracket(m.Groups[1].Value));
                else
                    break;
            }
            return calcExpressNoBracket(exp);
        }
    }
```

算上括号只有50多行，是我见过的表达式计算代码中最短的，但功能不强大。

为了让程序支持更多的功能，比如三角函数，科学计数法等，还需要对其进行扩展。
我扩展的代码如下。

    ```
        class ExtendMExpress
    {
        private static Regex inBracket = new Regex(@"\(([0-9\+\-\*\/\.\^]+)\)");
        private static Regex twoNumberPow = new Regex(@"\(?(-?\d+(\.\d+)?)\)?([\^])\(?(-?\d+(\.\d+)?)\)?");
        private static Regex twoNumberMD = new Regex(@"\(?(-?\d+(\.\d+)?)\)?([\*\/])\(?(-?\d+(\.\d+)?)\)?");
        private static Regex twoNumberAE = new Regex(@"\(?(-?\d+(\.\d+)?)\)?([+-])\(?(-?\d+(\.\d+)?)\)?");
        private static Regex snRegex = new Regex(@"(-?\d+(\.\d+)?[Ee]\d+)");
        private IList<FunctionReflect> functions = new List<FunctionReflect>();
        private delegate string runFunction(string[] args);

        private string runFunctionSin(string[] args)
        {
            return Math.Sin(Convert.ToDouble(args[0])).ToString();
        }

        private string runFunctionCos(string[] args)
        {
            return Math.Cos(Convert.ToDouble(args[0])).ToString();
        }

        private string runFunctionTan(string[] args)
        {
            return Math.Tan(Convert.ToDouble(args[0])).ToString();
        }

        private string runFunctionSqrt(string[] args)
        {
            return Math.Sqrt(Convert.ToDouble(args[0])).ToString();
        }

            

        class FunctionReflect
        {
            public FunctionReflect(Regex regx,runFunction runFun)
            {
                this.funRegex = regx;
                this.funDelegate = runFun;
            }

            public FunctionReflect(string funname, runFunction runFun)
            {
                this.funRegex = buildFunctionRegx(funname);
                this.funDelegate = runFun;
            }
            public Regex funRegex { get; set; }
            public runFunction funDelegate { get; set; }

            private Regex buildFunctionRegx(string funName)
            {
                string regex = funName + @"\(([0-9\+\-\*\/\.\^\(\)]+?)\)";
                return new Regex(regex);
            }
        }

        private void functionRegxRegister()
        {
            FunctionReflect funRef = null;

            funRef = new FunctionReflect("sin", runFunctionSin); functions.Add(funRef);
            funRef = new FunctionReflect("cos", runFunctionCos); functions.Add(funRef);
            funRef = new FunctionReflect("tan", runFunctionTan); functions.Add(funRef);
            funRef = new FunctionReflect("sqrt", runFunctionSqrt); functions.Add(funRef);

        }

        private bool hasFunction(string exp)
        {
            bool result = false;
            foreach(FunctionReflect fr in functions)
            {
                if (fr.funRegex.Match(exp).Success)
                {
                    result = true;
                    break;
                }
            }
            return result;
        }

        private string calcFunction(string exp)
        {
            Match m = null;
            string express = exp;

            while (true)
            {
                if (!hasFunction(express))
                    break;

                foreach (FunctionReflect fr in functions)
                {
                    while (true)
                    {
                        m = fr.funRegex.Match(express);
                        if (m.Success)
                        {
                            string repExp = m.Groups[0].Value;
                            string[] calcExp = m.Groups[1].Value.Split(',');
                            IList<string> args = new List<string>();
                            foreach (string param in calcExp)
                            {
                                args.Add(CalcExpress(param));
                            }
                            string result = fr.funDelegate(args.ToArray());
                            express = express.Replace(repExp, result);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
            return express;
        }



        private string calcTwoNumber(string left, string oper, string right)
        {
            double leftValue = Convert.ToDouble(left);
            double rightValue = Convert.ToDouble(right);
            switch (oper)
            {
                case "+": return (leftValue + rightValue).ToString();
                case "-": return (leftValue - rightValue).ToString();
                case "*": return (leftValue * rightValue).ToString();
                case "/": return (leftValue / rightValue).ToString();
                case "^": return Math.Pow(leftValue,rightValue).ToString();
                default: return string.Empty;
            }
        }
 
        private string calcTwoNumberSingle(string left, string oper, string right)
        {
            switch (oper)
            {
                case "+": return (Convert.ToSingle(left) + Convert.ToSingle(right)).ToString();
                case "-": return (Convert.ToSingle(left) - Convert.ToSingle(right)).ToString();
                case "*": return (Convert.ToSingle(left) * Convert.ToSingle(right)).ToString();
                case "/": return (Convert.ToSingle(left) / Convert.ToSingle(right)).ToString();
                default: return string.Empty;
            }
        }


        
        private string snToNormal(string sn)
        {
            sn = sn.ToLower().Trim();
            string[] temp = sn.Split('e');
            double l = Convert.ToDouble(temp[0]);
            double r = Convert.ToDouble(temp[1]);
            string result = (Math.Pow(10,r) * l).ToString();
            return result;
        }

        public string snReplace(string exp)
        {
            string express = exp.Trim();
            Match m = snRegex.Match(express);
            while (m.Success)
            {
                string sn = m.Groups[0].Value;
                express = express.Replace(sn, snToNormal(sn));
                m = m.NextMatch();
            }
            return express;
        }

        
        
        /**
         * 计算两个数字加减乘除
         * 参数为X+Y类似的表达式
         */
        private string calcExpressNoBracket(String exp)
        {
            Match m = null;
            string express = exp;

            operationReplace(ref m, ref express, twoNumberPow);
            operationReplace(ref m, ref express, twoNumberMD);
            operationReplace(ref m, ref express, twoNumberAE);

            return express;

        }

        private void operationReplace(ref Match m, ref string express,Regex reg)
        {
            while (true)
            {
                m = reg.Match(express);
                if (m.Success)
                {
                    express = calcReplace(m, express);
                }
                else
                {
                    break;
                }

            }
        }
        
        private string calcReplace(Match m, string express)
        {
            string twoNumberExp = m.Groups[0].Value;
            string leftValue = m.Groups[1].Value;
            string operatorStr = m.Groups[3].Value;
            string rightValue = m.Groups[4].Value;
            string result = calcTwoNumber(leftValue, operatorStr, rightValue);
            express = express.Replace(twoNumberExp, result);
            return express;
        }

        
        private string clearBracket(string exp)
        {
            Match m = null;
            string express = exp;
            while (true)
            {
                m = inBracket.Match(express);
                if (m.Success)
                    express = express.Replace(m.Groups[0].Value, calcExpressNoBracket(m.Groups[1].Value));
                else
                    break;
            }
            return express;
 
        }
        
        public string CalcExpress(string exp)
        {
            string express = exp;
            //去括号
            express = clearBracket(express);
            return calcExpressNoBracket(express);
        }

        public string runExpress(string exp)
        {
            functionRegxRegister();
            string express = exp.Trim();
            //转换科学计数法
            express = snReplace(express);
            //去函数
            express = calcFunction(express);
            return CalcExpress(express);
        }
    }
```

这个就可以运算这种表达式了
sin(cos(sqrt(2E2-0.5)+0.3))^2+cos(cos(sqrt(2E2-0.5)+0.3))^2

这个代码主要增加了科学计数法和自定义函数的支持，自定义函数用委托实现，幂运算的支持。

如果想增加自定义函数，只需要在

functionRegxRegister()中

加入两行代码

funRef = new FunctionReflect("sin", runFunctionSin); 

functions.Add(funRef);

FunctionReflect第一个参数为自定义函数名，比如sin

然后在类里面写一个

private string funname(string[] args)

形式的函数，args为参数比如sin(3)

那么args[0]就为3.

比如现在的sin只支持弧度，你可以添加一个degree()函数，把角度转换成弧度来使函数中的sin支持角度运算。
]]></description>
        <pubDate>Fri, 03 May 2013 14:45:36 +0800</pubDate>
        <guid>http://my.oschina.net/matrixc/blog/127218</guid>
    </item>
	</channel>
</rss>    