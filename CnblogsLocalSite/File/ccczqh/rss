<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">博客园_一个小兵兵的技术博客</title><subtitle type="text"></subtitle><id>uuid:27fc9aac-5a52-4f2d-9f21-2f058553e976;id=28638</id><updated>2013-02-18T03:23:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><generator>feed.cnblogs.com</generator><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915376.html</id><title type="text">Entity Framework对NULL值的处理 - ccczqh</title><summary type="text">今天拿Entity Framework改写早期的一个项目，涉及到对NULL值处理的时候，遇到了点问题，就是如何查询数据库中某字段为NULL的记录，写了几个测试用的例子，然后用SQL Server Profiler抓SQL。 测试1：直接使用null var clients = ctx.Clients.Where(c =&gt; c.ParentGUID == null); 对应的SQL是...</summary><published>2013-02-18T03:23:00Z</published><updated>2013-02-18T03:23:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915376.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915376.html" /><content type="html">&lt;p&gt;今天拿Entity Framework改写早期的一个项目，涉及到对NULL值处理的时候，遇到了点问题，就是如何查询数据库中某字段为NULL的记录，写了几个测试用的例子，然后用SQL Server Profiler抓SQL。&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;     &lt;br /&gt;测试1：直接使用null&lt;/strong&gt;&lt;/p&gt;  &lt;ol&gt;&lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.ParentGUID == null); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt; 对应的SQL是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;-- 执行正常 &lt;li&gt;SELECT&amp;#160; &lt;li&gt;[Extent1].[GUID] AS [GUID],&amp;#160; &lt;li&gt;[Extent1].[Name] AS [Name],&amp;#160; &lt;li&gt;[Extent1].[ParentGUID] AS [ParentGUID] &lt;li&gt;FROM [dbo].[Clients] AS [Extent1] &lt;li&gt;WHERE [Extent1].[ParentGUID] IS NULL &lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;测试2：使用等于null的变量：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;string parentGuid = null; &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.ParentGUID == parentGuid); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt; 对应的SQL是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;-- 使用了值为NULL的变量，但是用了等号，所以取不到值了 &lt;li&gt;exec sp_executesql N'SELECT&amp;#160; &lt;li&gt;[Extent1].[GUID] AS [GUID],&amp;#160; &lt;li&gt;[Extent1].[Name] AS [Name],&amp;#160; &lt;li&gt;[Extent1].[ParentGUID] AS [ParentGUID] &lt;li&gt;FROM [dbo].[Clients] AS [Extent1] &lt;li&gt;WHERE [Extent1].[ParentGUID] = @p__linq__0',N'@p__linq__0 varchar(8000)',@p__linq__0=NULL &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;测试3：加判断&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;string parentGuid = null; &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.ParentGUID == (string.IsNullOrEmpty(parentGuid) ? null : parentGuid)); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&amp;#160; 对应的SQL是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;-- 无语了，这也整得太复杂了吧，显然得不到正确结果 &lt;li&gt;exec sp_executesql N'SELECT&amp;#160; &lt;li&gt;[Extent1].[GUID] AS [GUID],&amp;#160; &lt;li&gt;[Extent1].[Name] AS [Name],&amp;#160; &lt;li&gt;[Extent1].[ParentGUID] AS [ParentGUID] &lt;li&gt;FROM [dbo].[Clients] AS [Extent1] &lt;li&gt;WHERE [Extent1].[ParentGUID] = ( &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; CASE&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; WHEN ((@p__linq__0 IS NULL) OR (( CAST(LEN(@p__linq__0) AS int)) = 0))&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; THEN CAST(NULL AS varchar(1))&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; ELSE @p__linq__1&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; END &lt;li&gt;)',N'@p__linq__0 nvarchar(4000),@p__linq__1 nvarchar(4000)',@p__linq__0=NULL,@p__linq__1=NULL &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;测试4：另一种方式加判断&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;string parentGuid = null; &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; string.IsNullOrEmpty(parentGuid) ? c.ParentGUID == null : c.ParentGUID == parentGuid); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt; 对应的SQL是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;--继续无语，比刚才的还复杂，同样得不到正确结果 &lt;li&gt;exec sp_executesql N'SELECT&amp;#160; &lt;li&gt;[Extent1].[GUID] AS [GUID],&amp;#160; &lt;li&gt;[Extent1].[Name] AS [Name],&amp;#160; &lt;li&gt;[Extent1].[ParentGUID] AS [ParentGUID] &lt;li&gt;FROM [dbo].[Clients] AS [Extent1] &lt;li&gt;WHERE ( &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; CASE&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; WHEN ((@p__linq__0 IS NULL) OR (( CAST(LEN(@p__linq__0) AS int)) = 0))&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; THEN cast(0 as bit)&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; WHEN ([Extent1].[ParentGUID] = @p__linq__1)&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; THEN cast(1 as bit)&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; WHEN ([Extent1].[ParentGUID] &amp;lt;&amp;gt; @p__linq__1)&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; THEN cast(0 as bit)&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; END &lt;li&gt;) = 1',N'@p__linq__0 nvarchar(4000),@p__linq__1 varchar(8000)',@p__linq__0=NULL,@p__linq__1=NULL &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;晕倒，看来把Linq的思想直接往EF上套是行不通的，某些情况下差异还是挺大的。&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2915376" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915376.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915376.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915373.html</id><title type="text">整理一下Entity Framework的查询 - ccczqh</title><summary type="text">Entity Framework是个好东西，虽然没有Hibernate功能强大，但使用更简便。今天整理一下常见SQL如何用EF来表达，Func形式和Linq形式都会列出来（本人更喜欢Func形式）。 1、简单查询： SQL： SELECT * FROM [Clients] WHERE Type=1 AND Deleted=0 ORDER BY ID EF：//Func形式 var cl...</summary><published>2013-02-18T03:21:00Z</published><updated>2013-02-18T03:21:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915373.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915373.html" /><content type="html">&lt;p&gt;&amp;#160;&lt;/p&gt;  &lt;p&gt;Entity Framework是个好东西，虽然没有Hibernate功能强大，但使用更简便。今天整理一下常见SQL如何用EF来表达，Func形式和Linq形式都会列出来（本人更喜欢Func形式）。&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;1、简单查询：&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;SQL：&lt;/p&gt;  &lt;ol&gt;&lt;li&gt;SELECT * FROM [Clients] WHERE Type=1 AND Deleted=0 ORDER BY ID &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.Type == 1 &amp;amp;&amp;amp; c.Deleted == 0) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .OrderBy(c =&amp;gt; c.ID) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .ToList(); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var clients = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.Type == 1 &amp;amp;&amp;amp; c.Deleted==0 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; orderby c.ID &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select c; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;2、查询部分字段：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;SELECT ID,Name FROM [Clients] WHERE Status=1 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.Status == 1) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Select(c =&amp;gt; new { c.ID, Name = c.ComputerName }) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .ToList(); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var clients = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.Status == 1 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select new { c.ID, Name = c.ComputerName }; &lt;strong&gt;：&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;3、查询单一记录：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;SELECT * FROM [Clients] WHERE ID=100 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var client = ctx.Clients.FirstOrDefault(c =&amp;gt; c.ID == 100); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var client = (from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.ID = 100 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select c).FirstOrDefault(); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;4、LEFT JOIN 连接查询&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;SELECT c.ID,c.ComputerName,g.Name GroupName&amp;#160; &lt;li&gt;FROM [Clients] c&amp;#160; &lt;li&gt;LEFT JOIN [Groups] g &lt;li&gt;ON c.GroupID = g.ID &lt;li&gt;WHERE c.Status=1 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.Status == 1) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Select(c =&amp;gt; new&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ID, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ComputerName, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; GroupName = ctx.Groups.FirstOrDefault(g =&amp;gt; g.ID == c.GroupID).Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .ToList(); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var clients = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.Status == 1 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select new &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ID, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ComputerName, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; GroupName = (from g in ctx.Groups &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where g.ID == c.GroupID &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select g.Name).FirstOrDefault() &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;5、INNER JOIN 连接查询：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;SELECT c.ID,c.ComputerName,g.Name GroupName&amp;#160; &lt;li&gt;FROM [Clients] c &lt;li&gt;INNER JOIN [Groups] g &lt;li&gt;ON c.GroupID = g.ID &lt;li&gt;WHERE c.Status=1 &lt;li&gt;ORDER BY g.Name &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.Status == 1) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Join(ctx.Group, c =&amp;gt; c.GroupID, g =&amp;gt; g.ID, (c,g) =&amp;gt;&amp;#160; &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ID, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ComputerName, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; GroupName = g.Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .OrderBy(item =&amp;gt; item.GroupName) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .ToList(); &lt;li&gt;&amp;#160;&lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式1 &lt;li&gt;var clients = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; from g in ctx.Groups &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.GroupID == g.ID &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; orderby g.Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select new &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ID, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ComputerName, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; GroupName = g.Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }; &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式2 &lt;li&gt;var clients = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; where c.Status == 1 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; join g in ctx.Group &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; on c.GroupID equals g.ID into result &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; from r in result &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; order by r.Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select new &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ID, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; c.ComputerName, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; GroupName = r.Name &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;    &lt;br /&gt;6、分页&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;-- 方案1 &lt;li&gt;SELECT TOP 10 * FROM [Clients] WHERE Status=1 &lt;li&gt;AND ID NOT IN&amp;#160; &lt;li&gt;( &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; SELECT TOP 20 ID FROM [Clients] WHERE Status=1 &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; ORDER BY ComputerName &lt;li&gt;) &lt;li&gt;ORDER BY ComputerName &lt;li&gt;&amp;#160;&lt;li&gt;--方案2 &lt;li&gt;SELECT * FROM &lt;li&gt;( &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; SELECT *, ROW_NUMBER() OVER(ORDER BY ComputerName) AS RowNo &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; FROM [Clients] &lt;li&gt;&amp;#160;&amp;#160;&amp;#160; WHERE Status=1 &lt;li&gt;)t &lt;li&gt;WHERE RowNo &amp;gt;= 20 AND RowNo &amp;lt; 30 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var clients = ctx.Clients.Where(c =&amp;gt; c.Status=1) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .OrderBy(c =&amp;gt; c.ComputerName) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Skip(20) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Take(10) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .ToList(); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var clients = (from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; orderby c.ComputerName &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select c).Skip(20).Take(10); &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;7、分组统计：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;SQL：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;SELECT Status,COUNT(*) AS Cnt FROM [Clients]&amp;#160; &lt;li&gt;GROUP BY Status &lt;li&gt;ORDER BY COUNT(*) DESC &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;EF：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;//Func形式 &lt;li&gt;var result = ctx.Clients.GroupBy(c =&amp;gt; c.Status) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .Select(s =&amp;gt; new &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Status = s.Key, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Cnt = s.Count() &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }) &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; .OrderByDescending(r =&amp;gt; r.Cnt); &lt;li&gt;&amp;#160;&lt;li&gt;//Linq形式 &lt;li&gt;var result = from c in ctx.Clients &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; group c by c.Status into r &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; orderby r.Count() descending &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; select new &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; { &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Status = r.Key, &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Cnt = r.Count() &lt;li&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;未完待续……&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2915373" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915373.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/18/2915373.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914740.html</id><title type="text">sqlhelper 使用事务实例 - ccczqh</title><summary type="text">string myConnectString = "Persist Security Info=False;Integrated Security=SSPI;database=northwind;server=mySQLServer;Connect Timeout=30"; SqlConnection myConnection = new SqlConnection(myConnectStrin...</summary><published>2013-02-17T12:54:00Z</published><updated>2013-02-17T12:54:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914740.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914740.html" /><content type="html">&lt;p&gt;string myConnectString = &amp;quot;Persist Security Info=False;Integrated Security=SSPI;database=northwind;server=mySQLServer;Connect Timeout=30&amp;quot;;&lt;/p&gt;  &lt;p&gt;SqlConnection myConnection = new SqlConnection(myConnectString);   &lt;br /&gt;myConnection.Open();    &lt;br /&gt;SqlTransaction st = myConnection .BeginTransaction();    &lt;br /&gt;try    &lt;br /&gt;{    &lt;br /&gt;...    &lt;br /&gt;SqlHelper.ExecuteDataset(st,...);    &lt;br /&gt;SqlHelper.ExecuteDataset(st,...);    &lt;br /&gt;...    &lt;br /&gt;st.Commit();    &lt;br /&gt;}    &lt;br /&gt;catch(SqlException ee)    &lt;br /&gt;{    &lt;br /&gt;st.Rollback();    &lt;br /&gt;throw ee;    &lt;br /&gt;}&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2914740" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914740.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914740.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914691.html</id><title type="text">SqlHelper 类实现详细信息 - ccczqh</title><summary type="text">SqlHelper 类实现详细信息 SqlHelper 类用于通过一组静态方法来封装数据访问功能。该类不能被继承或实例化，因此将其声明为包含专用构造函数的不可继承类。 在 SqlHelper 类中实现的每种方法都提供了一组一致的重载。这提供了一种很好的使用 SqlHelper 类来执行命令的模式，同时为开发人员选择访问数据的方式提供了必要的灵活性。每种方法的重载都支持不同的方法参数，因此...</summary><published>2013-02-17T11:46:00Z</published><updated>2013-02-17T11:46:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914691.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914691.html" /><content type="html">&lt;p&gt;SqlHelper 类实现详细信息   &lt;br /&gt;SqlHelper 类用于通过一组静态方法来封装数据访问功能。该类不能被继承或实例化，因此将其声明为包含专用构造函数的不可继承类。    &lt;br /&gt;在 SqlHelper 类中实现的每种方法都提供了一组一致的重载。这提供了一种很好的使用 SqlHelper 类来执行命令的模式，同时为开发人员选择访问数据的方式提供了必要的灵活性。每种方法的重载都支持不同的方法参数，因此开发人员可以确定传递连接、事务和参数信息的方式。在 SqlHelper 类中实现的方法包括：    &lt;br /&gt;ExecuteNonQuery。此方法用于执行不返回任何行或值的命令。这些命令通常用于执行数据库更新，但也可用于返回存储过程的输出参数。    &lt;br /&gt;ExecuteReader。此方法用于返回 SqlDataReader 对象，该对象包含由某一命令返回的结果集。    &lt;br /&gt;ExecuteDataset。此方法返回 DataSet 对象，该对象包含由某一命令返回的结果集。    &lt;br /&gt;ExecuteScalar。此方法返回一个值。该值始终是该命令返回的第一行的第一列。    &lt;br /&gt;ExecuteXmlReader。此方法返回 FOR XML 查询的 XML 片段。    &lt;br /&gt;除了这些公共方法外，SqlHelper 类还包含一些专用函数，用于管理参数和准备要执行的命令。不管客户端调用什么样的方法实现，所有命令都通过 SqlCommand 对象来执行。在 SqlCommand 对象能够被执行之前，所有参数都必须添加到 Parameters 集合中，并且必须正确设置 Connection、CommandType、CommandText 和 Transaction 属性。SqlHelper 类中的专用函数主要用于提供一种一致的方式，以便向 SQL Server 数据库发出命令，而不考虑客户端应用程序调用的重载方法实现。SqlHelper 类中的专用实用程序函数包括：    &lt;br /&gt;AttachParameters：该函数用于将所有必要的 SqlParameter 对象连接到正在运行的 SqlCommand。    &lt;br /&gt;AssignParameterValues：该函数用于为 SqlParameter 对象赋值。    &lt;br /&gt;PrepareCommand：该函数用于对命令的属性（如连接、事务环境等）进行初始化。    &lt;br /&gt;ExecuteReader：此专用 ExecuteReader 实现用于通过适当的 CommandBehavior 打开 SqlDataReader 对象，以便最有效地管理与阅读器关联的连接的有效期。    &lt;br /&gt;SqlHelper体验谈：    &lt;br /&gt;以下载自CEOCIO(MVP/CSDN_WEB开发版主)的Blog:    &lt;br /&gt;微软提供的Data Access Application Block中的SQLHelper类中封装了最常用的数据操作，各个使用者调用他而写的代码也有很大区别。    &lt;br /&gt;对于一个返回DataSet的方法我原来是这样写的：    &lt;br /&gt;public DataSet GetDepartmentMemberList(int departmentID)    &lt;br /&gt;...{    &lt;br /&gt;try    &lt;br /&gt;...{    &lt;br /&gt;string sql = &amp;quot;OA_Department_GetDepartment_Members&amp;quot;;    &lt;br /&gt;string conn = ConfigurationSettings.AppSettings[&amp;quot;strConnection&amp;quot;];    &lt;br /&gt;SqlParameter[] p =&amp;#160; &lt;br /&gt;...{    &lt;br /&gt;SqlHelper.MakeInParam(&amp;quot;@departmentID&amp;quot;,SqlDbType.Int,4,departmentID)    &lt;br /&gt;};    &lt;br /&gt;DataSet ds = SqlHelper.ExecuteDataset(conn,CommandType.StoredProcedure,sql,p);    &lt;br /&gt;return ds;    &lt;br /&gt;}    &lt;br /&gt;catch(System.Data.SqlClient.SqlException er)    &lt;br /&gt;...{    &lt;br /&gt;throw new Exception(er.Message);    &lt;br /&gt;}    &lt;br /&gt;}    &lt;br /&gt;现在我是这样来写的：    &lt;br /&gt;//连接字符串    &lt;br /&gt;private string _connectionString = ConfigurationSettings.AppSettings[&amp;quot;strConnection&amp;quot;];    &lt;br /&gt;public string ConnectionString    &lt;br /&gt;...{    &lt;br /&gt;get ...{return this._connectionString;}    &lt;br /&gt;set ...{this._connectionString = value;}    &lt;br /&gt;}    &lt;br /&gt;public DataSet GetNewsToIndexPage(int NewsTypeID)    &lt;br /&gt;...{    &lt;br /&gt;return GetDataSet(&amp;quot;yzb_GetNewsToIndexPage&amp;quot;,GetNewsToIndexPage_Parameters(NewsTypeID));    &lt;br /&gt;}    &lt;br /&gt;//设置存储过程参数    &lt;br /&gt;private SqlParameter[] GetNewsToIndexPage_Parameters(int NewsTypeID)    &lt;br /&gt;...{    &lt;br /&gt;SqlParameter[] p =&amp;#160; &lt;br /&gt;...{    &lt;br /&gt;SqlHelper.MakeInParam(&amp;quot;@NewsTypeID&amp;quot;,SqlDbType.Int,4,NewsTypeID)    &lt;br /&gt;};    &lt;br /&gt;return p;    &lt;br /&gt;}    &lt;br /&gt;//这里才真正调用SqlHelper    &lt;br /&gt;private DataSet GetDataSet(string sql, params SqlParameter[] p)    &lt;br /&gt;...{    &lt;br /&gt;return SqlHelper.ExecuteDataset(ConnectionString,CommandType.StoredProcedure,sql,p);    &lt;br /&gt;}    &lt;br /&gt;代码更加灵活，更加安全了：P    &lt;br /&gt;做为一个懒人，大笨狼我经常这样写：    &lt;br /&gt;System.Data.DataTable dt=SqlHelper.ExecuteDataset(SqlHelper.CONN_STRING_NON_DTC,CommandType.Text,sql).Tables[0];&amp;#160; &lt;br /&gt;直接返回DataTable， 返回表集合基本不用，只返回一个table用于绑定。    &lt;br /&gt;string conn = ConfigurationSettings.AppSettings[&amp;quot;strConnection&amp;quot;];&amp;#160; &lt;br /&gt;我写在SqlHelper.CONN_STRING_NON_DTC里面    &lt;br /&gt;MakeInParam代码烦琐，如果查询输入条件不可能有组合SQL,&amp;#160; &lt;br /&gt;我直接exec pronamr paraargs&amp;#160; &lt;br /&gt;如果查询输入条件存在安全问题，或者带返回参数    &lt;br /&gt;再用SqlParameter[] queryParam=new SqlParameter[] ...{&amp;#160; &lt;br /&gt;new SqlParameter(&amp;quot;@UserID&amp;quot;,SqlDbType.Int)&amp;#160; &lt;br /&gt;};&amp;#160; &lt;br /&gt;queryParam[0].Value=this.UserID;&amp;#160; &lt;br /&gt;组合sql语句用到@和string.Format技巧.例如：    &lt;br /&gt;sql=@&amp;quot;UPDATE Test_User_Statistic    &lt;br /&gt;SET&amp;#160; &lt;br /&gt;Test_User_Statistic.[IsQualified]={0},&amp;#160; &lt;br /&gt;Test_User_Statistic.[Reason]='{1}'    &lt;br /&gt;WHERE UserID={2}&amp;quot; ;    &lt;br /&gt;sql= string.Format(sql,IsQualified,Reason,userID);    &lt;br /&gt;SqlHelper.ExecuteNonQuery(SqlHelper.CONN_STRING_NON_DTC,CommandType.Text,sql);    &lt;br /&gt;其中sql语句可以借助SQL的查询分析器生成。    &lt;br /&gt;这么干要保证安全，如果有输入漏洞，建议还是用SqlParameter[]缓存参数，因为它会把攻击性的代码，比如带单引号分号的，当作普通字符处理。    &lt;br /&gt;superdullwolf(超级大笨狼,每天要自强) 于 2005-6-15 4:52:13&amp;#160; &lt;br /&gt;SqlHelper可以回滚事务，但是我觉得事务还是存储过程本身来解决比较好：    &lt;br /&gt;DBTransaction = CS.BeginTransaction();    &lt;br /&gt;SqlHelper.ExecuteNonQuery(DBTransaction, CommandType.StoredProcedure, &amp;quot;pro_T_Accredit_Create&amp;quot;, arParams);    &lt;br /&gt;p_intOutPut = Convert.ToInt32(arParams[3].Value.ToString());    &lt;br /&gt;if(p_intOutPut &amp;lt; 0)    &lt;br /&gt;...{    &lt;br /&gt;DBTransaction.Rollback(); //--回退事务    &lt;br /&gt;}    &lt;br /&gt;另外附采用存储过程回滚    &lt;br /&gt;CREATE PROCEDURE 。。。    &lt;br /&gt;@idint    &lt;br /&gt;。。。。    &lt;br /&gt;as    &lt;br /&gt;declare 。。。    &lt;br /&gt;begin transaction    &lt;br /&gt;insert 。。。    &lt;br /&gt;delete 。。。    &lt;br /&gt;if @@error &amp;lt;&amp;gt; 0 rollback transaction    &lt;br /&gt;commit transaction    &lt;br /&gt;GO    &lt;br /&gt;比较ASP回滚：    &lt;br /&gt;标题 在ASP中使用事务控制 julyclyde（原作）    &lt;br /&gt;关键字 ASP,事务,COM+&amp;#160; &lt;br /&gt;作者系2月份微软社区之星Microsoft China Community Star    &lt;br /&gt;在编程中，经常需要使用事务。所谓事务，就是一系列必须都成功的操作，只要有一步操作失败，所有其他的步骤也必须撤销。比如用ASP开发一个网络硬盘系统，其用户注册部分要做的事有：    &lt;br /&gt;将用户信息记入数据库    &lt;br /&gt;为用户开个文件夹用于存储    &lt;br /&gt;初始化用户操作日志    &lt;br /&gt;这三步必须使用事务，否则万一磁盘操作失败，而没有撤销数据库操作，就会造成只能登陆而不能操作的&amp;quot;死用户&amp;quot;现象。    &lt;br /&gt;由于数据库系统特殊的发展历史，小至Access，大到DB2,无不带有事务支持。因此上述步骤可以如下表示：    &lt;br /&gt;On Error Resume Next    &lt;br /&gt;第一步：    &lt;br /&gt;在事务环境下把用户信息记入数据库    &lt;br /&gt;If Err Then    &lt;br /&gt;关闭连接    &lt;br /&gt;退出    &lt;br /&gt;Else    &lt;br /&gt;第二步：创建文件夹    &lt;br /&gt;If Err Then    &lt;br /&gt;回滚第一步数据库操作，退出    &lt;br /&gt;Else    &lt;br /&gt;第三步：在事务环境下操作日志数据库    &lt;br /&gt;If Err Then    &lt;br /&gt;回滚第一步操作，删除第二步建立的文件夹    &lt;br /&gt;退出    &lt;br /&gt;End If    &lt;br /&gt;End If    &lt;br /&gt;End If    &lt;br /&gt;提交第一步数据库操作的事务    &lt;br /&gt;提交第二步数据库操作的事务    &lt;br /&gt;End    &lt;br /&gt;每一步都需要进行判断，如果失败，还需要手工回滚前面多步操作，使程序变得复杂、难懂。如果今后更新了程序，增加其他步骤，还需要嵌套更多层的If...Else...End If，使程序流程更加复杂。    &lt;br /&gt;正确的解决办法是使用ASP的事务控制功能。IIS通过和MTS服务联系，可以控制多种支持事务的系统，当程序发出&amp;quot;失败&amp;quot;的信号时，所有支持事务的系统均将自动回滚，即使操作已经正式完成；对不支持事务的操作也提供了方便的手工回滚方式。上面的例子用ASP事务控制功能重写如下：    &lt;br /&gt;&amp;lt;%@ TRANSACTION = Required %&amp;gt;    &lt;br /&gt;On Error Resume Next    &lt;br /&gt;Set Conn=Server.CreateObject(&amp;quot;ADODB.Connection&amp;quot;)    &lt;br /&gt;Conn.Open ....    &lt;br /&gt;Conn.Execute &amp;quot;INSERT....&amp;quot;    &lt;br /&gt;Conn.Close    &lt;br /&gt;Set Conn=Nothing    &lt;br /&gt;Set Conn2=Server.CreateObject(&amp;quot;ADODB.Connection&amp;quot;)    &lt;br /&gt;Conn2.Open ....    &lt;br /&gt;Conn2.Execute &amp;quot;INSERT....&amp;quot;    &lt;br /&gt;Conn2.Close    &lt;br /&gt;Set Conn2=Nothing    &lt;br /&gt;Set FSO=Server.CreateObject(&amp;quot;Scripting.FilesystemObject&amp;quot;)    &lt;br /&gt;FSO.CreateFolder &amp;quot;....&amp;quot;    &lt;br /&gt;If Err Then    &lt;br /&gt;ObjectContext.SetAbort '通知所有支持事务的组件回滚，并运行手工回滚代码    &lt;br /&gt;Else    &lt;br /&gt;ObjectContext.SetComplete    &lt;br /&gt;End If    &lt;br /&gt;Set FSO=Nothing    &lt;br /&gt;Sub OnTransactionAbort    &lt;br /&gt;Response.Write &amp;quot;错误&amp;quot;    &lt;br /&gt;FSO.DeleteFile Server.Mappath(&amp;quot;a.txt&amp;quot;) 'FSO的手工回滚——删除文件夹    &lt;br /&gt;End Sub    &lt;br /&gt;Sub OnTransactionCommit    &lt;br /&gt;Response.Write &amp;quot;胜利完成任务&amp;quot;    &lt;br /&gt;End Sub    &lt;br /&gt;%&amp;gt;    &lt;br /&gt;第一行的&amp;lt;%@ TRANSACTION = Required %&amp;gt;表示这一页ASP文件需要MTS的事务支持。中间的各个操作都按普通顺序书写，而不用考虑回滚问题。在程序最后判断是否有错误。如果有，调用ObjectContext的SetAbort方法，IIS会通过MTS服务通知所有支持事务的组件回滚（主要是数据库），并且运行Sub OnTransactionAbort对不支持事务的操作手工回滚；如果没有发生错误，调用ObjectContext的SetComplete方法，则会运行Sub OnTransactionCommit来显示成功的消息。    &lt;br /&gt;整个ASP程序不需要为判断错误和回滚操作书写多余的代码，只须在最后进行判断，即使今后增加了多步操作，也只需要在Sub OnTransactionAbort中进行控制即可，非常方便，程序员可以专注于过程编写而不是书写纠错代码。    &lt;br /&gt;其实ASP还提供了许多更有用的功能，等着我们使用，千万不要以为ASP使用脚本语言，功能就一定弱。    &lt;br /&gt;比较ADO回滚：    &lt;br /&gt;&amp;lt;%&amp;#160; &lt;br /&gt;'Asp中使用事务    &lt;br /&gt;Set conn=Server.CreateObject(&amp;quot;ADODB.Connection&amp;quot;)&amp;#160; &lt;br /&gt;conn.Open &amp;quot;course_dsn&amp;quot;,&amp;quot;course_user&amp;quot;,&amp;quot;course_password&amp;quot;&amp;#160; &lt;br /&gt;conn.begintrans '开始事务    &lt;br /&gt;sql=&amp;quot;delete from user_info&amp;quot;&amp;#160; &lt;br /&gt;set rs=server.createobject(&amp;quot;adodb.recordset&amp;quot;)&amp;#160; &lt;br /&gt;rs.open sql,conn,3,3&amp;#160; &lt;br /&gt;if conn.errors.count&amp;gt;0 then '有错误发生    &lt;br /&gt;conn.rollbacktrans '回滚    &lt;br /&gt;set rs=nothing&amp;#160; &lt;br /&gt;conn.close&amp;#160; &lt;br /&gt;set conn=nothing&amp;#160; &lt;br /&gt;response.write &amp;quot;交易失败，回滚至修改前的状态！&amp;quot;&amp;#160; &lt;br /&gt;response.end&amp;#160; &lt;br /&gt;else    &lt;br /&gt;conn.committrans '提交事务    &lt;br /&gt;set rs=nothing&amp;#160; &lt;br /&gt;conn.close&amp;#160; &lt;br /&gt;set conn=nothing&amp;#160; &lt;br /&gt;response.write &amp;quot;交易成功！&amp;quot;&amp;#160; &lt;br /&gt;response.end&amp;#160; &lt;br /&gt;end if    &lt;br /&gt;%&amp;gt;&amp;#160; &lt;br /&gt;SqlHelper最开始出现好像是在Microsoft PetShop 作为DAL层的核心。    &lt;br /&gt;另外关于SqlDataReader，我感觉这个东西和ADO里面的RecordSet类似，就是需要Close.    &lt;br /&gt;如果做为参数和返回值传递是比较危险的，因为你要传出去就Close(),而究竟在哪里关闭容易被以往和忽略，所以我觉得还是用强类型的DataSet做为参数和返回值传递纪录集比较好。    &lt;br /&gt;据说下面的写法不用Close也会自动资源回收，不知道真的假的：    &lt;br /&gt;using(SqlDataReader reader=SqlHelper.ExecuteReader(SqlHelper.CONN_STRING_NON_DTC,CommandType.Text,sql))    &lt;br /&gt;...{    &lt;br /&gt;if(reader.Read())    &lt;br /&gt;...{    &lt;br /&gt;arr[0]=reader.GetString(1);    &lt;br /&gt;。。。。}    &lt;br /&gt;} &lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2914691" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914691.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/17/2914691.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/16/2913716.html</id><title type="text">SQL Server 2008R2中增加了新的智能 - ccczqh</title><summary type="text">SQL Server 2008R2中增加了新的智能提示的功能简化了输入，非常方便。但突然有一天智能提示没有了，好郁闷！ 折腾了半天终于将智能提示找回来了，下面是我解决本问题的思路： 1.查看工具选项中Enable Intellisense是否打开？ 选择Tools--&gt;Options打开选项页面，依次展开Text Editor--&gt;Transact-SQL--&gt;IntelliSense显示如...</summary><published>2013-02-16T13:27:00Z</published><updated>2013-02-16T13:27:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/16/2913716.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/16/2913716.html" /><content type="html">&lt;p&gt;SQL Server 2008R2中增加了新的智能提示的功能简化了输入，非常方便。但突然有一天智能提示没有了，好郁闷！&lt;/p&gt;  &lt;p&gt;折腾了半天终于将智能提示找回来了，下面是我解决本问题的思路：&lt;/p&gt;  &lt;p&gt;1.查看工具选项中Enable Intellisense是否打开？&lt;/p&gt;  &lt;p&gt;选择Tools--&amp;gt;Options打开选项页面，依次展开Text Editor--&amp;gt;Transact-SQL--&amp;gt;IntelliSense显示如下图所示的配置页面，检查是否勾选了Enable IntelliSense选项。注意修改配置后要打开新的查询页面才起作用。&lt;/p&gt;  &lt;p&gt;如果勾选后仍旧不起作用则进行下一步。&lt;/p&gt;  &lt;p&gt;&lt;img title="在新窗口打开图片" alt="" src="http://files.jb51.net/file_images/article/201207/201207172212364.png" width="620" height="486" /&gt;&lt;/p&gt;  &lt;p&gt;2.如果前面的Enable IntelliSense已经勾选，则有可能是缓存被占满。&lt;/p&gt;  &lt;p&gt;选择菜单Edit--&amp;gt;IntelliSense--&amp;gt;Refresh Local Cash清空缓存。&lt;/p&gt;  &lt;p&gt;&lt;img title="在新窗口打开图片" alt="" src="http://files.jb51.net/file_images/article/201207/201207172212365.png" width="620" height="426" /&gt;&lt;/p&gt;  &lt;p&gt;3.一般来说经过以上两步就可以了，但我的仍旧不起作用。&lt;/p&gt;  &lt;p&gt;上网查询后发现有提示说如果安装了Visual Studio 2010 SP1的补丁后智能提示会消失，要求安装SQL Server 2008R2 SP1。&lt;/p&gt;  &lt;p&gt;我虽然没有安装Visual Studio 2010 SP1，但最近安装了Team Explorer 2008，想来是一样的问题。下载SQL Server 2008R2 SP1安装后问题果然解决。&lt;/p&gt;  &lt;p&gt;下载地址：&lt;a href="http://www.microsoft.com/en-us/download/details.aspx?id=26727"&gt;http://www.microsoft.com/en-us/download/details.aspx?id=26727&lt;/a&gt;&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2913716" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/16/2913716.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/16/2913716.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912802.html</id><title type="text">DateTime 数字型 - ccczqh</title><summary type="text">－－DateTime 数字型 System.DateTime currentTime=new System.DateTime(); 取当前年月日时分秒 currentTime=System.DateTime.Now; 取当前年 int 年=currentTime.Year; 取当前月 int 月=currentTime.Month; 取当前日 int 日=current...</summary><published>2013-02-15T07:24:00Z</published><updated>2013-02-15T07:24:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912802.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912802.html" /><content type="html">&lt;li&gt;－－DateTime 数字型 &lt;/li&gt;  &lt;li&gt;System.DateTime currentTime=new System.DateTime(); &lt;/li&gt;  &lt;li&gt;取当前年月日时分秒&amp;#160; currentTime=System.DateTime.Now; &lt;/li&gt;  &lt;li&gt;取当前年&amp;#160; int 年=currentTime.Year; &lt;/li&gt;  &lt;li&gt;取当前月&amp;#160; int 月=currentTime.Month; &lt;/li&gt;  &lt;li&gt;取当前日&amp;#160; int 日=currentTime.Day; &lt;/li&gt;  &lt;li&gt;取当前时&amp;#160; int 时=currentTime.Hour; &lt;/li&gt;  &lt;li&gt;取当前分&amp;#160; int 分=currentTime.Minute; &lt;/li&gt;  &lt;li&gt;取当前秒&amp;#160; int 秒=currentTime.Second; &lt;/li&gt;  &lt;li&gt;取当前毫秒&amp;#160; int 毫秒=currentTime.Millisecond; （变量可用中文） &lt;/li&gt;  &lt;li&gt;取中文日期显示——年月日时分&amp;#160; string strY=currentTime.ToString(&amp;quot;f&amp;quot;); //不显示秒&lt;/li&gt;  &lt;li&gt;取中文日期显示_年月&amp;#160; string strYM=currentTime.ToString(&amp;quot;y&amp;quot;); &lt;/li&gt;  &lt;li&gt;取中文日期显示_月日&amp;#160; string strMD=currentTime.ToString(&amp;quot;m&amp;quot;); &lt;/li&gt;  &lt;li&gt;取当前年月日，格式为：2003-9-23&amp;#160; string strYMD=currentTime.ToString(&amp;quot;d&amp;quot;); &lt;/li&gt;  &lt;li&gt;取当前时分，格式为：14：24&amp;#160; string strT=currentTime.ToString(&amp;quot;t&amp;quot;); &lt;/li&gt;  &lt;li&gt;DateTime.Now.ToString();//获取当前系统时间 完整的日期和时间&lt;/li&gt;  &lt;li&gt;DateTime.Now.ToLongDateString();//只显示日期 xxxx年xx月xx日 ，一个是长日期&lt;/li&gt;  &lt;li&gt;DateTime.Now.ToShortDateString();//只显示日期 xxxx-xx-xx 一个是短日期&lt;/li&gt;  &lt;li&gt;//今天&amp;#160; DateTime.Now.Date.ToShortDateString();&lt;/li&gt;  &lt;li&gt;//昨天 的&amp;#160; DateTime.Now.AddDays(-1).ToShortDateString();&lt;/li&gt;  &lt;li&gt;//明天 的&amp;#160; DateTime.Now.AddDays(1).ToShortDateString();&lt;/li&gt;  &lt;li&gt;&lt;/li&gt;  &lt;li&gt;//本周(注意这里的每一周是从周日始至周六止）&lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;//上周，上周就是本周再减去7天&lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;//下周&amp;#160; 本周再加上7天&lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString(); &lt;/li&gt;  &lt;li&gt;//本月&amp;#160; 本月的第一天是1号，最后一天就是下个月一号再减一天。&lt;/li&gt;  &lt;li&gt;DateTime.Now.Year.ToString() + DateTime.Now.Month.ToString() + &amp;quot;1&amp;quot;; //第一天&lt;/li&gt;  &lt;li&gt;DateTime.Parse(DateTime.Now.Year.ToString() + DateTime.Now.Month.ToString() + &amp;quot;1&amp;quot;).AddMonths(1).AddDays(-1).ToShortDateString();//最后一天&lt;/li&gt;  &lt;li&gt;另一种方法： &lt;/li&gt;  &lt;li&gt;DateTime now = DateTime.Now; &lt;/li&gt;  &lt;li&gt;DateTime d1 = new DateTime(now.Year, now.Month, 1); //本月第一天&lt;/li&gt;  &lt;li&gt;DateTime d2 = d1.AddMonths(1).AddDays(-1); //本月最后一天&lt;/li&gt;  &lt;li&gt;PS： &lt;/li&gt;  &lt;li&gt;DateTime.Now.DayOfWeek.ToString();//英文星期显示，Wednesday&lt;/li&gt;  &lt;li&gt;（int）DateTime.Now.DayOfWeek&amp;#160; 数字，若是周三，结果对应为3 &lt;/li&gt;  &lt;li&gt;DateTime.Now.ToString(&amp;quot;dddd&amp;quot;, new System.Globalization.CultureInfo(&amp;quot;zh-cn&amp;quot;)); //中文星期显示&lt;/li&gt;  &lt;li&gt;DateTime.Now.ToString(&amp;quot;dddd&amp;quot;);//中文星期显示&lt;/li&gt;  &lt;li&gt;DateTime.Now.ToString(&amp;quot;dddd,MMMM,dd ,yyyy&amp;quot;, new System.Globalization.DateTimeFormatInfo())；//显示日期格式Friday,July, 01,2009&lt;/li&gt;  &lt;li&gt;DateTime.Now.ToString(&amp;quot;dddd,dd MMMM,yyyy&amp;quot;) //输出&amp;#160; 星期三,30 一月,2008&lt;/li&gt;  &lt;li&gt;出处：http://msdn.microsoft.com/zh-cn/vstudio/bb762911(VS.95).aspx，如何：从特定日期中提取星期几&lt;/li&gt;  &lt;li&gt;datetime类型在tostring()format的格式设置 &lt;/li&gt;  &lt;li&gt;参数format格式详细用法 &lt;/li&gt;  &lt;li&gt; 格式字符 关联属性/说明 &lt;/li&gt;  &lt;li&gt; d ShortDatePattern &lt;/li&gt;  &lt;li&gt; D LongDatePattern &lt;/li&gt;  &lt;li&gt; f 完整日期和时间（长日期和短时间） &lt;/li&gt;  &lt;li&gt; F FullDateTimePattern（长日期和长时间） &lt;/li&gt;  &lt;li&gt; g 常规（短日期和短时间） &lt;/li&gt;  &lt;li&gt; G 常规（短日期和长时间） &lt;/li&gt;  &lt;li&gt; m、M MonthDayPattern &lt;/li&gt;  &lt;li&gt; r、R RFC1123Pattern &lt;/li&gt;  &lt;li&gt; s 使用当地时间的 SortableDateTimePattern（基于 ISO 8601） &lt;/li&gt;  &lt;li&gt; t ShortTimePattern &lt;/li&gt;  &lt;li&gt; T LongTimePattern &lt;/li&gt;  &lt;li&gt; u UniversalSortableDateTimePattern 用于显示通用时间的格式 &lt;/li&gt;  &lt;li&gt; U 使用通用时间的完整日期和时间（长日期和长时间） &lt;/li&gt;  &lt;li&gt; y、Y YearMonthPattern &lt;/li&gt;  &lt;li&gt;下表列出了可被合并以构造自定义模式的模式。这些模式是区分大小写的 &lt;/li&gt;  &lt;li&gt;d 月中的某一天。一位数的日期没有前导零。 &lt;/li&gt;  &lt;li&gt; dd 月中的某一天。一位数的日期有一个前导零。 &lt;/li&gt;  &lt;li&gt; ddd 周中某天的缩写名称，在 AbbreviatedDayNames 中定义。 &lt;/li&gt;  &lt;li&gt; dddd 周中某天的完整名称，在 DayNames 中定义。 &lt;/li&gt;  &lt;li&gt; M 月份数字。一位数的月份没有前导零。 &lt;/li&gt;  &lt;li&gt; MM 月份数字。一位数的月份有一个前导零。 &lt;/li&gt;  &lt;li&gt; MMM 月份的缩写名称，在 AbbreviatedMonthNames 中定义。 &lt;/li&gt;  &lt;li&gt; MMMM 月份的完整名称，在 MonthNames 中定义。 &lt;/li&gt;  &lt;li&gt; y 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示不具有前导零的年份。 &lt;/li&gt;  &lt;li&gt; yy 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示具有前导零的年份。 &lt;/li&gt;  &lt;li&gt; yyyy 包括纪元的四位数的年份。 &lt;/li&gt;  &lt;li&gt; gg 时期或纪元。如果要设置格式的日期不具有关联的时期或纪元字符串，则忽略该模式。 &lt;/li&gt;  &lt;li&gt;h 12 小时制的小时。一位数的小时数没有前导零。 &lt;/li&gt;  &lt;li&gt; hh 12 小时制的小时。一位数的小时数有前导零。 &lt;/li&gt;  &lt;li&gt; H 24 小时制的小时。一位数的小时数没有前导零。 &lt;/li&gt;  &lt;li&gt; HH 24 小时制的小时。一位数的小时数有前导零。 &lt;/li&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2912802" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912802.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912802.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912787.html</id><title type="text">C# tostring()汇总 - ccczqh</title><summary type="text">formatCode 是可选的格式化代码字符串。（详细内容请搜索“格式化字符串”查看） 必须用“{”和“}”将格式与其他字符分开。如果恰好在格式中也要使用大括号，可以用连续的两个大括号表示一个大括号，即： “{{”或者“}}”。 常用格式举例： （1） int i=12345; this.textBox1.Text=i.ToString(); //结果 12345...</summary><published>2013-02-15T07:06:00Z</published><updated>2013-02-15T07:06:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912787.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912787.html" /><content type="html">&lt;p&gt;formatCode 是可选的格式化代码字符串。（详细内容请搜索“格式化字符串”查看）    &lt;br /&gt;必须用“{”和“}”将格式与其他字符分开。如果恰好在格式中也要使用大括号，可以用连续的两个大括号表示一个大括号，即： “{{”或者“}}”。     &lt;br /&gt;常用格式举例：     &lt;br /&gt;（1） int i=12345;    &lt;br /&gt;this.textBox1.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;();    &lt;br /&gt;//结果 12345（this指当前对象，或叫当前类的实例）     &lt;br /&gt;this.textBox2.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;d8&amp;quot;);    &lt;br /&gt;//结果 00012345    &lt;br /&gt;（2） int i=123;    &lt;br /&gt;double j=123.45;    &lt;br /&gt;string s1=string.Format(&amp;quot;the value is {0,7:d}&amp;quot;,i);    &lt;br /&gt;string s2=string.Format(&amp;quot;the value is {0,7:f3}&amp;quot;,j);    &lt;br /&gt;this.textBox1.Text=s1 ;    &lt;br /&gt;//结果 the value is 123    &lt;br /&gt;this.textBox2.Text=s2;    &lt;br /&gt;//结果 the value is 123.450    &lt;br /&gt;（3）double i=12345.6789;    &lt;br /&gt;this.textBox1.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;f2&amp;quot;); //结果 12345.68    &lt;br /&gt;this.textBox2.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;f6&amp;quot;);    &lt;br /&gt;//结果 12345.678900    &lt;br /&gt;（4）double i=12345.6789;    &lt;br /&gt;this.textBox1.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;n&amp;quot;); //结果 12,345.68    &lt;br /&gt;this.textBox2.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(“n4”); //结果 12,345.6789    &lt;br /&gt;（5）double i=0.126;    &lt;br /&gt;string s=string.Format(&amp;quot;the value is {0:p}&amp;quot;,i);    &lt;br /&gt;this.textBox1.Text=i.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;p&amp;quot;); //结果 12.6%    &lt;br /&gt;this.textBox2.Text=s; //结果 the value is 12.6%    &lt;br /&gt;（6） DateTime dt =new DateTime(2003,5,25);    &lt;br /&gt;this.textBox1.Text=dt.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;yy.M.d&amp;quot;);    &lt;br /&gt;//结果 03.5.25    &lt;br /&gt;this.textBox2.Text=dt.&lt;strong&gt;ToString&lt;/strong&gt;(“yyyy年M月”);    &lt;br /&gt;//结果 2003年5月     &lt;br /&gt;Convert.ToDateTime(&amp;quot;2005/12/22 22:22:22&amp;quot;).&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;yyyy/MM/dd HH:mm:ss&amp;quot;)    &lt;br /&gt;&amp;quot;2005/12/22 22:22:22&amp;quot;     &lt;br /&gt;（7） int i=123;    &lt;br /&gt;double j=123.45;    &lt;br /&gt;string s=string.Format(&amp;quot;i:{0,-7},j:{1,7}&amp;quot;,i,j);    &lt;br /&gt;//-7表示左对齐，占7位     &lt;br /&gt;this.textBox1.Text=s ;    &lt;br /&gt;//结果i:123 ,j: 123.45     &lt;br /&gt;&lt;strong&gt;DateTime.&lt;/strong&gt;&lt;strong&gt;ToString&lt;/strong&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;strong&gt;用法详解&lt;/strong&gt;    &lt;br /&gt;我们经常会遇到对时间进行转换,达到不同的显示效果，默认格式为:2006-6-6 14:33:34     &lt;br /&gt;如果要换成成200606,06-2006,2006-6-6或更多的格式该怎么办呢？    &lt;br /&gt;这里将要用到:&lt;strong&gt;DateTime.ToString&lt;/strong&gt;的方法&lt;strong&gt;(String, IFormatProvider)     &lt;br /&gt;示例：      &lt;br /&gt;&lt;/strong&gt;using System;    &lt;br /&gt;using System.Globalization;    &lt;br /&gt;String format=&amp;quot;D&amp;quot;;    &lt;br /&gt;DateTime date=DataTime.Now;    &lt;br /&gt;Response.Write(date.&lt;strong&gt;ToString&lt;/strong&gt;(format, DateTimeFormatInfo.InvariantInfo));    &lt;br /&gt;结果输出    &lt;br /&gt;Thursday, June 16, 2006    &lt;br /&gt;在这里列出了参数format格式详细用法    &lt;br /&gt;=======================    &lt;br /&gt;格式字符 关联属性/说明     &lt;br /&gt;d ShortDatePattern     &lt;br /&gt;D LongDatePattern     &lt;br /&gt;f 完整日期和时间（长日期和短时间）     &lt;br /&gt;F FullDateTimePattern（长日期和长时间）     &lt;br /&gt;g 常规（短日期和短时间）     &lt;br /&gt;G 常规（短日期和长时间）     &lt;br /&gt;m、M MonthDayPattern     &lt;br /&gt;r、R RFC1123Pattern     &lt;br /&gt;s 使用当地时间的 SortableDateTimePattern（基于 ISO 8601）     &lt;br /&gt;t ShortTimePattern     &lt;br /&gt;T LongTimePattern     &lt;br /&gt;u UniversalSortableDateTimePattern 用于显示通用时间的格式     &lt;br /&gt;U 使用通用时间的完整日期和时间（长日期和长时间）     &lt;br /&gt;y、Y YearMonthPattern    &lt;br /&gt;下表列出了可被合并以构造自定义模式的模式    &lt;br /&gt;========================================    &lt;br /&gt;这些模式是区分大小写的；例如，识别“MM”，但不识别“mm”。如果自定义模式包含空白字符或用单引号括起来的字符，则输出字符串页也将包含这些字符。未定义为格式模式的一部分或未定义为格式字符的字符按其原义复制。     &lt;br /&gt;格式模式 说明 ：    &lt;br /&gt;d 月中的某一天。一位数的日期没有前导零。     &lt;br /&gt;dd 月中的某一天。一位数的日期有一个前导零。     &lt;br /&gt;ddd 周中某天的缩写名称，在 AbbreviatedDayNames 中定义。     &lt;br /&gt;dddd 周中某天的完整名称，在 DayNames 中定义。     &lt;br /&gt;M 月份数字。一位数的月份没有前导零。     &lt;br /&gt;MM 月份数字。一位数的月份有一个前导零。     &lt;br /&gt;MMM 月份的缩写名称，在 AbbreviatedMonthNames 中定义。     &lt;br /&gt;MMMM 月份的完整名称，在 MonthNames 中定义。     &lt;br /&gt;y 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示不具有前导零的年份。     &lt;br /&gt;yy 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示具有前导零的年份。     &lt;br /&gt;yyyy 包括纪元的四位数的年份。     &lt;br /&gt;gg 时期或纪元。如果要设置格式的日期不具有关联的时期或纪元字符串，则忽略该模式。     &lt;br /&gt;h 12 小时制的小时。一位数的小时数没有前导零。     &lt;br /&gt;hh 12 小时制的小时。一位数的小时数有前导零。     &lt;br /&gt;H 24 小时制的小时。一位数的小时数没有前导零。     &lt;br /&gt;HH 24 小时制的小时。一位数的小时数有前导零。     &lt;br /&gt;m 分钟。一位数的分钟数没有前导零。     &lt;br /&gt;mm 分钟。一位数的分钟数有一个前导零。     &lt;br /&gt;s 秒。一位数的秒数没有前导零。     &lt;br /&gt;ss 秒。一位数的秒数有一个前导零。     &lt;br /&gt;f 秒的小数精度为一位。其余数字被截断。     &lt;br /&gt;ff 秒的小数精度为两位。其余数字被截断。     &lt;br /&gt;fff 秒的小数精度为三位。其余数字被截断。     &lt;br /&gt;ffff 秒的小数精度为四位。其余数字被截断。     &lt;br /&gt;fffff 秒的小数精度为五位。其余数字被截断。     &lt;br /&gt;ffffff 秒的小数精度为六位。其余数字被截断。     &lt;br /&gt;fffffff 秒的小数精度为七位。其余数字被截断。     &lt;br /&gt;t 在 AMDesignator 或 PMDesignator 中定义的 AM/PM 指示项的第一个字符（如果存在）。     &lt;br /&gt;tt 在 AMDesignator 或 PMDesignator 中定义的 AM/PM 指示项（如果存在）。     &lt;br /&gt;z 时区偏移量（“+”或“-”后面仅跟小时）。一位数的小时数没有前导零。例如，太平洋标准时间是“-8”。     &lt;br /&gt;zz 时区偏移量（“+”或“-”后面仅跟小时）。一位数的小时数有前导零。例如，太平洋标准时间是“-08”。     &lt;br /&gt;zzz 完整时区偏移量（“+”或“-”后面跟有小时和分钟）。一位数的小时数和分钟数有前导零。例如，太平洋标准时间是“-08:00”。     &lt;br /&gt;: 在 TimeSeparator 中定义的默认时间分隔符。     &lt;br /&gt;/ 在 DateSeparator 中定义的默认日期分隔符。     &lt;br /&gt;% c 其中 c 是格式模式（如果单独使用）。如果格式模式与原义字符或其他格式模式合并，则可以省略“%”字符。     &lt;br /&gt;\ c 其中 c 是任意字符。照原义显示字符。若要显示反斜杠字符，请使用“\\”。     &lt;br /&gt;只有上面第二个表中列出的格式模式才能用于创建自定义模式；在第一个表中列出的标准格式字符不能用于创建自定义模式。自定义模式的长度至少为两个字符；例如，     &lt;br /&gt;DateTime.&lt;strong&gt;ToString&lt;/strong&gt;( &amp;quot;d&amp;quot;) 返回 DateTime 值；“d”是标准短日期模式。     &lt;br /&gt;DateTime.&lt;strong&gt;ToString&lt;/strong&gt;( &amp;quot;%d&amp;quot;) 返回月中的某天；“%d”是自定义模式。     &lt;br /&gt;DateTime.&lt;strong&gt;ToString&lt;/strong&gt;( &amp;quot;d &amp;quot;) 返回后面跟有一个空白字符的月中的某天；“d”是自定义模式。     &lt;br /&gt;比较方便的是,上面的参数可以随意组合,并且不会出错,多试试,肯定会找到你要的时间格式    &lt;br /&gt;如要得到2005年06月 这样格式的时间    &lt;br /&gt;可以这样写:    &lt;br /&gt;date.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;yyyy年MM月&amp;quot;, DateTimeFormatInfo.InvariantInfo)    &lt;br /&gt;如此类推.    &lt;br /&gt;下面列出一些Asp.net中具体的日期格式化用法：    &lt;br /&gt;============================================    &lt;br /&gt;1.绑定时格式化日期方法:     &lt;br /&gt;2.数据控件如DataGrid/DataList等的件格式化日期方法:     &lt;br /&gt;e.Item.Cell[0].Text = Convert.ToDateTime(e.Item.Cell[0].Text).ToShortDateString();    &lt;br /&gt;3.用String类转换日期显示格式:     &lt;br /&gt;String.Format( &amp;quot;yyyy-MM-dd &amp;quot;,yourDateTime);    &lt;br /&gt;4.用Convert方法转换日期显示格式:     &lt;br /&gt;Convert.ToDateTime(&amp;quot;2005-8-23&amp;quot;).&lt;strong&gt;ToString&lt;/strong&gt;    &lt;br /&gt;(&amp;quot;yyMMdd&amp;quot;,System.Globalization.DateTimeFormatInfo.InvariantInfo); //支持繁体数据库     &lt;br /&gt;5.直接用&lt;strong&gt;ToString&lt;/strong&gt;方法转换日期显示格式:     &lt;br /&gt;DateTime.Now.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;yyyyMMddhhmmss&amp;quot;);     &lt;br /&gt;DateTime.Now.&lt;strong&gt;ToString&lt;/strong&gt;(&amp;quot;yyyy/MM/dd hh:mm:ss&amp;quot;)    &lt;br /&gt;6.只显示年月     &lt;br /&gt;DataBinder.Eval(Container.DataItem,&amp;quot;starttime&amp;quot;,&amp;quot;{0:yyyy-M}&amp;quot;)    &lt;br /&gt;7.显示时间所有部分，包括：年月日时分秒     &lt;br /&gt;DataFormatString='{0:yyyy-MM-dd HH24:mm:ss}'&amp;gt;    &lt;br /&gt;用DateTime.&lt;strong&gt;ToString&lt;/strong&gt;(string format)输出不同格式的日期&lt;/p&gt;  &lt;p&gt;&amp;#160;&lt;a href="http://images.cnitblog.com/blog/14595/201302/15150537-97b3c1b1691847ebbce7fd9f9e316766.png"&gt;&lt;img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="应用中心截屏_2013-02-15T07-05-16.692Z" border="0" alt="应用中心截屏_2013-02-15T07-05-16.692Z" src="http://images.cnitblog.com/blog/14595/201302/15150540-1af5cbccff374ea9a315fb6a358b3878.png" width="378" height="376" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2912787" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912787.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/15/2912787.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911186.html</id><title type="text">DataGridView 列宽和行高自动调整的设定 - ccczqh</title><summary type="text">1) 设定行高和列宽自动调整 // 设定包括Header和所有单元格的列宽自动调整 DataGridView1.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells; // 设定包括Header和所有单元格的行高自动调整 DataGridView1.AutoSizeRowsMode = DataGridViewA...</summary><published>2013-02-14T04:07:00Z</published><updated>2013-02-14T04:07:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911186.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911186.html" /><content type="html">&lt;p&gt;1) 设定行高和列宽自动调整&lt;/p&gt;  &lt;p&gt;// 设定包括Header和所有单元格的列宽自动调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells;   &lt;br /&gt;// 设定包括Header和所有单元格的行高自动调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.AllCells;&lt;/p&gt;  &lt;p&gt;AutoSizeColumnsMode 属性的设定值枚举请参照 msdn 的 DataGridViewAutoSizeRowsMode 说明。&lt;/p&gt;  &lt;p&gt;2）指定列或行自动调整&lt;/p&gt;  &lt;p&gt;// 第一列自动调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.Columns[0].AutoSizeMode =&amp;#160; DataGridViewAutoSizeColumnMode.DisplayedCells;&lt;/p&gt;  &lt;p&gt;AutoSizeMode 设定为 NotSet&amp;#160; 时， 默认继承的是&amp;#160; DataGridView.AutoSizeColumnsMode 属性。&lt;/p&gt;  &lt;p&gt;3) 设定列头的高度和行头的宽度自动调整&lt;/p&gt;  &lt;p&gt; // 设定列头的宽度可以自由调整&lt;/p&gt;  &lt;p&gt; DataGridView1.ColumnHeadersHeightSizeMode =&amp;#160;&amp;#160; DataGridViewColumnHeadersHeightSizeMode.AutoSize;   &lt;br /&gt;// 设定行头的宽度可以自由调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.RowHeadersWidthSizeMode =&amp;#160; DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders;&lt;/p&gt;  &lt;p&gt;4） 随时自动调整&lt;/p&gt;  &lt;p&gt; a， 临时的，让列宽自动调整，这和指定AutoSizeColumnsMode属性一样。&lt;/p&gt;  &lt;p&gt;// 让 DataGridView1 的所有列宽自动调整一下。&lt;/p&gt;  &lt;p&gt;DataGridView1.AutoResizeColumns(DataGridViewAutoSizeColumnsMode.AllCells);   &lt;br /&gt;// 让 DataGridView1 的第一列的列宽自动调整一下。 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoResizeColumn(0, DataGridViewAutoSizeColumnMode.AllCells);&lt;/p&gt;  &lt;p&gt;上面调用的 AutoResizeColumns 和 AutoResizeColumn 当指定的是DataGridViewAutoSizeColumnMode.AllCells 的时候， 参数可以省略。即： DataGridView1.AutoResizeColumn(0) 和 DataGridView1.AutoResizeColumns()&lt;/p&gt;  &lt;p&gt;b，临时的，让行高自动调整&lt;/p&gt;  &lt;p&gt;// 让 DataGridView1 的所有行高自动调整一下。&lt;/p&gt;  &lt;p&gt; DataGridView1.AutoResizeRows(DataGridViewAutoSizeRowsMode.AllCells);   &lt;br /&gt;//让 DataGridView1 的第一行的行高自动调整一下。 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoResizeRow(0, DataGridViewAutoSizeRowMode.AllCells);&lt;/p&gt;  &lt;p&gt;上面调用的 AutoResizeRows 和 AutoResizeRow 当指定的是DataGridViewAutoSizeRowMode.AllCells 的时候， 参数可以省略。即：DataGridView1.AutoResizeRow (0) 和 DataGridView1.AutoResizeRows()&lt;/p&gt;  &lt;p&gt;c，临时的，让行头和列头自动调整&lt;/p&gt;  &lt;p&gt; // 列头高度自动调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoResizeColumnHeadersHeight();   &lt;br /&gt;// 行头宽度自动调整 &lt;/p&gt;  &lt;p&gt;DataGridView1.AutoResizeRowHeadersWidth(DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders);&lt;/p&gt;  &lt;p&gt;&lt;b&gt;关于性能：&lt;/b&gt;&lt;b&gt; &lt;/b&gt;通过 AutoSizeColumnsMode 或者 AutoSizeRowsMode 属性所指定的单元格进行自动调整时，如果调整次数过于多那么将可能导致性能下降，尤其是在行和列数比较多的情况下。在这时用 DisplayedCells 代替 AllCells 能减少非所见的单元格的调整，从而提高性能。&lt;/p&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/2911186" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911186.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911186.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911185.html</id><title type="text">datagridview,第一列前没有灰的一列 - ccczqh</title><summary type="text">不知道那是个不是datagridview,第一列前没有灰的一列，不知那是什么？如何做到答案1 ------其他回答（30分）--------- datagridview属性有个rowheadersvisible属性。 ------其他回答（5分）--------- 将datagridview属性的RowHeadersVisible = false ------其他回答（5分）----...</summary><published>2013-02-14T04:00:00Z</published><updated>2013-02-14T04:00:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911185.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911185.html" /><content type="html">&lt;p&gt;不知道那是个不是datagridview,第一列前没有灰的一列，不知那是什么？如何做到答案1&lt;/p&gt;  &lt;hr /&gt;  &lt;br /&gt;------其他回答（30分）---------  &lt;br /&gt;datagridview属性有个rowheadersvisible属性。  &lt;br /&gt;------其他回答（5分）---------  &lt;br /&gt;将datagridview属性的RowHeadersVisible = false  &lt;br /&gt;------其他回答（5分）---------  &lt;br /&gt;将datagridview的RowHeadersVisible属性设为false,在前台和后台设定都可以   &lt;img src="http://counter.cnblogs.com/blog/rss/2911185" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911185.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/14/2911185.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ccczqh/archive/2013/02/13/2911088.html</id><title type="text">DataGridView取消默认选中行 - ccczqh</title><summary type="text">最近用Winform的DataGridView遇到不少问题，昨晚就碰到个默认选中行的问题。DataGridView在添加数据后会默认选中第 一个单元格或者第一行，我就想取消它的默认选中行。于是就在绑定数据的地方加了dataGridView1.ClearSelection()这句代码， 启动窗体之后发现第一行还是被选中了。后来上网搜索，看到很多人都遇到这个问题，解决方法无非就是那几句代码。可我...</summary><published>2013-02-13T15:25:00Z</published><updated>2013-02-13T15:25:00Z</updated><author><name>ccczqh</name><uri>http://www.cnblogs.com/ccczqh/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ccczqh/archive/2013/02/13/2911088.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ccczqh/archive/2013/02/13/2911088.html" /><content type="html">&lt;p&gt;&lt;strong&gt;&amp;#160;&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;最近用Winform的DataGridView遇到不少问题，昨晚就碰到个默认选中行的问题。DataGridView在添加数据后会默认选中第 一个单元格或者第一行，我就想取消它的默认选中行。于是就在绑定数据的地方加了dataGridView1.ClearSelection()这句代码， 启动窗体之后发现第一行还是被选中了。后来上网搜索，看到很多人都遇到这个问题，解决方法无非就是那几句代码。可我试了几次都不管用，百思不得其解。。    &lt;br /&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 后来才知道得把它放到窗体的Load事件中，于是添加了form1_Load事件一试，终于没有默认选中的行了。不得如果更新DataGridView的数据之后又会默认选中第一行，所以我就在DataGridView绑定数据之后又加上了ClearSelection()。这样一来，不论是启动窗体之后还是重新更新数据，都不会有默认选中行了。 &lt;/p&gt;  &lt;img src="http://counter.cnblogs.com/blog/rss/2911088" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ccczqh/archive/2013/02/13/2911088.html" target="_blank"&gt;http://www.cnblogs.com/ccczqh/archive/2013/02/13/2911088.html&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry></feed>