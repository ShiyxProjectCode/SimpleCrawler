<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" title="XSL Formatting" href="/rss.xsl" media="all" ?>
<rss version="2.0">
<channel>
    <title>Scalzdp的专栏</title>
    <image>
    <link>http://blog.csdn.net</link>
    <url>http://static.blog.csdn.net/images/logo.gif</url>
    </image>
    <description></description>
	<link>http://blog.csdn.net/scalzdp</link>
	<language>zh-cn</language>
	<generator>http://blog.csdn.net</generator>
	<ttl>5</ttl>
	<copyright><![CDATA[Copyright &copy; Scalzdp]]></copyright> 
	<pubDate>2015/9/17 14:35:42</pubDate>
    <item>
        <title><![CDATA[[原]读《大数据》的三重大思维转变，有感]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/39369855</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/39369855</guid>
        <author>Scalzdp</author>
        <pubDate>2014/9/18 14:07:58</pubDate>
        <description><![CDATA[
            
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;大数据这个词语，这几年炙手可热。大数据在某些领域已经显示出了它的价&#20540;了，比如航空公司产品销售策略分析，淘宝用户逛店铺的途径是PC还是手机，Google曾经使用大数据就准确预测过流感病毒的传播和发源地。</span></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;前不久国务院总理李克强就针对大数据约见了浪潮等一些厂商，可见大数据在我们国家已被提升到了如此高度的重视了。我们不难预测在不久的将来大数据将广泛的应用到我们社会的各个方面。</span></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;那么面对这样一个大数据时代，不能在固守原来的一亩三分地了，我们要敞开思想放下原来的固执去迎接大数据时代的到来。</span></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;大数据与三个重大的思维转变有关，这三个转变是互相联系和互相作用的。</span></p>
<p><strong><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;首先，分析与某事物相关的所有数据，而不是依靠分析少量的数据样本。</span></strong></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;原来我们不具备手段或工具去分析所有的数据样本，而是采用抽样分析情况。这种以管窥豹的时代会照成分析结果不准确。我们现在拥有了大数据分析的手段和平台（hadoop 、ga 、spark 等）可以去分析某一事物的所有数据了。以前，每到过年新闻中都会纷纷报道各个省市的人均GDP，人均收入水平，几乎很少人信这个数据是准确的。为什么会出现民众对新闻报道的数据产生不信任呢？究其原因是数据不准确不实际，做数据调查的群体只是抽样了经济发展不错的城镇做出的结论。因为如果要获得相当精确的数据的代价是非常大的，要排多少调查人员，走访多少村镇，耗费多长的时间，想一想就是一个庞大的工程。但是在大数据时代，我们有了数据中心，我们就可以轻松高效全面的统计分析整个地区的结果，找出发达的地区和欠发达的地区，均衡整个地区的发展趋势。</span></p>
<p><strong><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;其次，要乐于接受数据的纷繁复杂，而不再最求数据的精确性。</span></strong></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;我们的工作生活会产生多少的数据呢？街道的摄像记录，小区的门禁监控记录，公司上下班的打卡记录，浏览网页的浏览历史，每一个人每一天不知不觉都会产生非常大的数据。更何况以后建立的智慧城市，这个数据的数量级我们难以想象了。我们不得不面临纷繁复杂的数据，所以再去考虑某一条数据是不是精确的代价已经变得得不偿失了，没有必要再去最求数据要多么的精确了。</span></p>
<p><strong><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;最后，重点不再去探求难以琢磨的因果关系，转而关注事物的相关关系。</span></strong></p>
<p><span style="font-family:FangSong_GB2312">&nbsp;&nbsp;&nbsp;&nbsp;最求事物的因果关系，我们从小就被这样的教育。在大数据面前去分析数据的因果关系，这是钻入数据之中，是一件非常困难的事情，因为任何一条数据的产生都可能是多种因素影响产生的，是不容易找到真正原因的。然而关注事物的相关关系，这是站在数据之上，关注数据之间的相关性，弄明白不同数据种类之间的关系型，通过这种数据类型之间的关系性就可以预测数据发展的未来。</span></p>
<p><span style="font-family:FangSong_GB2312">拿出手机扫一扫下面的二维码，关注微信号，分享读后感：</span><br>
<img src="http://img.blog.csdn.net/20140918140244974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2NhbHpkcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="100" height="100" alt=""><br>
</p>

            <div>
                作者：Scalzdp 发表于2014/9/18 14:07:58 <a href="http://blog.csdn.net/scalzdp/article/details/39369855">原文链接</a>
            </div>
            <div>
            阅读：377 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/39369855#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]如何提升测试质量？？]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/39077209</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/39077209</guid>
        <author>Scalzdp</author>
        <pubDate>2014/9/5 10:46:09</pubDate>
        <description><![CDATA[
            
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;测试的重要性我们就不在这里多说了，因为说测试重要的文章太多了。这里我只想从一个测试员的角度，提出如何提升测试的质量。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;编写一份详细的测试用例提高测试质量。详细的测试用例完全覆盖了代码的所有路径。把这样一份测试用例发放到测试人员手中，都能高质量的执行测试过程，测试用例完全覆盖所有需求，测试人员就不会因为不熟悉业务而遗漏需要测试的需求。但是一份详细的，覆盖所有需求的，测试用例虽然能够让测试的执行测试覆盖所有的需求，但是测试人员稀少，并不能可能多的在测试过程中发现更多的问题。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;投入大量的测试人员提高软件测试质量。更多人进行软件测试，每个人从自己关注的角度使用软件会发现不同的问题，弥补人手不够造成的测试BUG被忽视的问题。而且测试数量多，每个测试人员都可以从软件使用的易用性、易学性等方面提出软件改进的建议。但是人一多花在交流沟通的时间成本就会成几何次方的增加，多人合作如果没有制度管理或约束，这是软件的巨大风险。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建立一套完善的测试过程管理规范提高软件测试质量。一套完善的软件过程测试规范，对软件测试过程进行管控，不仅是对人员沟通问题进行管控，而且是对问题反映流程进行的约定，这样一个流程可以降低沟通成本，而且对软件测试流程进行了统一的管理。但是即使拥有了全面的管理规范，应用在一群测试技能底下的测试人员手中，并不会让测试的质量有本质的提高。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;重点落在了测试人员的能力提升。一个优秀的测试人员不仅可以写出高质量的测试用例，覆盖测试的所有需求，还能在测试过程中发挥个人主管意识，发现可能存在的问题，比如未规定的输入，页面响应的性能问题。提升了测试人员的技能，还可以真正发现测试过程管理中的问题，持续优化已有的测试过程管理。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:KaiTi_GB2312; font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;从软件公司的角度来看，软件的质量决定了公司的命运。测试是把控软件的最后一道防线，只要能够严防这道防线，就能为用户提供高可靠的软件产品了。测试人员是测试工作的具体执行者，测试人员的成长不仅需要自身的勤奋学习，还需要公司拥有远见，提供测试发展的大环境。</span></p>
</blockquote>

            <div>
                作者：Scalzdp 发表于2014/9/5 10:46:09 <a href="http://blog.csdn.net/scalzdp/article/details/39077209">原文链接</a>
            </div>
            <div>
            阅读：999 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/39077209#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]程序员小故事-战术上的勤奋和战略上的懒惰]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38865409</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38865409</guid>
        <author>Scalzdp</author>
        <pubDate>2014/8/27 10:32:16</pubDate>
        <description><![CDATA[
            
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几年的工作下来，大大小小的项目也接触过几个，但是突然对自己的产生了怀疑。我的应该怎样来规划我的生活，我不希望简单的工作就是我的事业全部，想去接触更加丰富的世界拓展更加广阔的视野。就如我这样的程序员，在这个社会上太多太多了，我应该用什么来立足于这个社会之上呢？这个问题引发了我对程序员人生的一个浅层次的思考。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说道战术和战略，这些词汇也许我们觉得他与我们的真实生活相差甚远，甚至无需去考虑，但是这样做会造成工作多年之后陷入不知道自己在忙啥的困境之中。就像在我大学毕业的时候我就问我身边考研的同学“你们为什么要去考研？”，他们回答的“工作一时不好找”，“是父母要求我去考研”。我又问“你们考完研究生怎么打算的呢？”，他们说“父母要求考博？”，“到那时候找工作压力不大了出来找一份稳定一点的工作。”。但是三年过去了他们也毕业了，社会的就业压力一样很大，而且考博的决心也开始动摇了。他们也就只重视了&#30524;前的的困境采用一些战术避过了当前的风险，但是战略上面并没有给自己一个很好的规划。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得程序人生应该是一个长期的规划和挑战，当时选择程序工作只是为了养家糊口吗？不敢说是要去改变世界，但是至少可以做一些东西，去方便周围人工作生活。如果有了这样的想法，我们的工作生活中所有接触到东西都能激发我们的创造潜能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序人生也需要着&#30524;整个市场社会&#26684;局，我们程序员容易就陷入我们自己的小圈子里面走不出来了。从来不去思考整个市场&#26684;局是怎么样的，每天研究的一些技术津津有味，但不知行业中已经出现了可以快速解决的开源方案了，再也不需要你设计编写别人已经实现过了的功能。程序人生也需要兼备产品能力，判断自己选择的行业是否有前景。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序人生需要明确的发展方向，这个发展方向不仅是描绘出以后的发展方向和以后要走上的岗位所肩负的责任，这是是促使不断创新，不断拼搏的源动力和跌倒之后爬起来的勇气。</p>

            <div>
                作者：Scalzdp 发表于2014/8/27 10:32:16 <a href="http://blog.csdn.net/scalzdp/article/details/38865409">原文链接</a>
            </div>
            <div>
            阅读：822 评论：2 <a href="http://blog.csdn.net/scalzdp/article/details/38865409#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]程序员小故事-注定献身给程序]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38826561</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38826561</guid>
        <author>Scalzdp</author>
        <pubDate>2014/8/25 21:50:02</pubDate>
        <description><![CDATA[
            
<p><span style="font-family:Comic Sans MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几年前一个农村的小伙拿到高考的成绩的时候，面对大学的抉择的问题，他看着自己高考的分数在仔细的对比着厚厚的高校简介的书籍，真是一头雾水太多的选择了。和中国广大农村家庭一样父母不能给你任何的建议，但是父母永远支持他的儿子或女子选择的方向，就像两座大山一样毫不动摇。小伙子终于选定了他接下来四年的大学生涯，就是一无所知的计算机科学与技术专业，小伙心底善良抱着实现自己梦想的包袱踏上了大学的旅程。小伙开始对大学的一切产生了强烈的兴趣，学期考试每次都是靠着临考前报佛脚通过的，大一对他来说是漫长的每天都会抽时间到图书馆吸收从未接触过的各种知识。他也想在大学遇到一份期待已久的恋情，大一就在期待和盼望中过去了。转&#30524;大二了，小伙有了自己的一台电脑，电脑配置还算可以的，这是他最贵重的物品了。所以他非常的爱惜，不想有任何问题发生在上面，甚至电脑用了超过一个小时都于心不忍。但是有了电脑对他来说是一个灾难，他并没有在程序开发设计上面有多好的进步，电脑慢慢的变成了他的娱乐工具了。</span></p>
<p><span style="font-family:Comic Sans MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四年的大学生活也让他迷茫过焦虑过，他大学广泛的接触了很多他长这么大都没有接触过的新东西和新人，大学里面的各种新鲜的编程活动和那些来自城市的朋友们他们很小就能编写程序了，小伙羡慕不已拼命的学习技能希望自己也能拥有这样的成就。但是小伙没有坚持多久就放弃了这个梦想了。小伙转而接触了一些理财的知识，曾经一度要放弃从事有关IT方面的工作，小伙也没有闲着，利用周末和暑假的时候去兼职了很多种类的工作终于明白除了本职工作其他都不能很好的胜任的，不是他预期设想的那么美好。</span></p>
<p><span style="font-family:Comic Sans MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转&#30524;四年的大学生活流失于指缝之间，小伙耍过朋友、买过醉、挂过科、逃过课、当过干部、带过队唯独技术这一块比较空白。小伙运气不错刚出道公司就遇到一个很好的导师带领他，接触了敏捷用过scrum，结果队，xp编过程。这些他都不知道的新奇东西，重新点燃了他内心的求知欲望，他暗自下定决心要现身软件行业，要在这个行业中干出一番属于自己的事业。他利用业余时间不短的学习新知识和接触IT业界的大佬们，建立他IT圈的人脉。他也开发过自己的博客，发布过自己的O2O网站，虽然一切现在都看起来不起&#30524;还没有达到成功的彼岸，但是一个抱有雄心的小伙不甘于一身就这样碌碌无为的了此余生了。他还会不断在圈子里面混不断尝试一些新想法新出路，希望他能早点把自己的事业建立牢固。愿上天保佑这位小伙，不要让外界的打击，浇灭了他内心的奋斗的激情<img alt="奋斗" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/struggle.gif"></span></p>

            <div>
                作者：Scalzdp 发表于2014/8/25 21:50:02 <a href="http://blog.csdn.net/scalzdp/article/details/38826561">原文链接</a>
            </div>
            <div>
            阅读：327 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/38826561#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]NEO的程序中过分亲密的类关系]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38817615</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38817615</guid>
        <author>Scalzdp</author>
        <pubDate>2014/8/25 11:36:17</pubDate>
        <description><![CDATA[
            
<p><span style="font-family:FangSong_GB2312"><span style="white-space:pre"></span>&nbsp;&nbsp;NEO是开发的网上蜂蜜商城中常常会让几个类有说不清道不明的关系，NEO即使付出再大的代价调试，他也不去拆分明确这些类的关系。系统终于在NEO的巨大付出下上线了。小朱是一个网购达人，她想去买一瓶优质的蜂蜜，浏览了jd和taobao这些网上商城都没有找到自己心仪的，突然在一个不经意的地方发现了NEO的商城链接，小朱进去之后购买了一瓶蜂蜜之后留下了建议，希望网站能做到最新蜂蜜信息能够通过邮箱、手机、微信等方式及时推送到我的手上。</span></p>
<p><span style="font-family:FangSong_GB2312"><span style="white-space:pre"></span>&nbsp;&nbsp;NEO下班回来看到了这个消息觉得小朱的建议很有价&#20540;，这样可以更多的留住回头客。NEO开始设计代开发，这个网站建设都过了一些时间了，当时写的逻辑都忘记的差不多了，NEO读着代码发现有关客户的资料信息在很多类里面都有描述，比如在客户类中有客户喜好，但是在客户偏好里面有客户联系的信息，这几个类就像连体人一样，其中一个类小人的一个动作会让其他类小人做出一些反映，比如维护我的基本资料我会涉及到偏好的维护，但这不是必须的。NEO多次组合这些类小人关系，都不能达到目标，他这时第一次变得力不从心了，因为就连他现在也不能确定哪些变了会影响哪些类行为<img alt="哭" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/cry.gif">。</span></p>
<p><span style="font-family:FangSong_GB2312"><span style="white-space:pre"></span>&nbsp;&nbsp;NEO的师傅知道这件事之后专程抽了一个周末去看望他，指出了NEO的程序中没有将类的职责分离的清晰明确，这时NEO的师傅建议他大动手术把这个连体人进行分离，这个连体人已经长成了一起了，其中血脉盘根错节，进行分离不是一件易事，手术刀一不小心就会照成大出血.....</span></p>
<p><span style="font-family:FangSong_GB2312"><span style="white-space:pre"></span>&nbsp;&nbsp;其实我们学过设计模式也知道，我们把系统中的每一个类，比喻成系统中需要顶一项职责的人，当我们设计这些类小人的时候就设计成连体人，那么我们就无法单独调用某一个类小人，干一件只属于他的事情了，牵一发而动全身。所以建议在设计类小人的时候，反复问自己这个类小人的职责应不应该包含这个职责？？在出现连体类小人的苗头的时候，就进行手术分离，不仅风险小而且很快就完成了。。。。</span></p>

            <div>
                作者：Scalzdp 发表于2014/8/25 11:36:17 <a href="http://blog.csdn.net/scalzdp/article/details/38817615">原文链接</a>
            </div>
            <div>
            阅读：230 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/38817615#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码坏味道之令人迷惑的暂时字段]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38732167</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38732167</guid>
        <author>Scalzdp</author>
        <pubDate>2014/8/21 17:32:14</pubDate>
        <description><![CDATA[
            
<h4><span style="font-family:FangSong_GB2312">为什么我们随意命名变量会是灾难性的决定？</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">随意命名变量是编写代码的灾难性决定，我这里说的比较严重，但是为了强调编程过程中不要随意命名我们的变量。因为从以下三方面的理由是不允许我们在程序中随意命名变量的。首先在编程过程中，随意命名的变量会导致我们编写代码中弄乱数据传输的关系，因为人们通过混乱的字段会把字段的本意理解错误的，理解错误字段的意思就会把该字段用在本不该她使用的地方。其次，当你费尽千辛万苦程序终于能够运行了，但是面对需求变更或代码给其他人阅读的时候，会给阅读人带来很大的难度，因为当别人来阅读的时候在令人迷惑字段上面耗费很大的精力去理解。最后，当你是一个老员工使用这么不规范的编码习惯，你带出来的徒弟也会随意命名，因为初入职场的新人是对技术上混了几年的老鸟有一种敬佩之情，作为老鸟的我们不能给新员工模范错误的榜样。</span></p>
<p><span style="font-family:FangSong_GB2312">随意命名不仅是自己对代码的不负责任，而且还会让自己带出来的程序员对你怀恨在心，说以随意命名是灾难性的。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">为什么要把变量集中管理或通过配置来管理呢？</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们可以采取的办法有哪些呢？通常我们可以采用以下两种方式进行管理。首先可以使用Extract Class给这些孤儿创造一个家，然后把所有和这个这个变量相关的代码都放进这个新家里，当然在放入新家的成员能够给这些字段赋予明确意义的名称，名称可以通过字段的职责抽象进行命名，做到见名知意的效果。其次，可以把这些字段放入固定的资源文件或配置文件，为什么要这样做呢？因为通过配置文件程序在不停机的情况下可以修改变量的&#20540;，同时也做到了把字段进行了集中管理，但是字段放在配置文件中每一次程序都需要进行文件操作，读取相应的字段里面的变量&#20540;。在以上两种解决方案中应该综合利弊权衡优劣采取相应的策略。</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/8/21 17:32:14 <a href="http://blog.csdn.net/scalzdp/article/details/38732167">原文链接</a>
            </div>
            <div>
            阅读：266 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/38732167#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码坏味道之夸夸其谈的未来性]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38511279</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38511279</guid>
        <author>Scalzdp</author>
        <pubDate>2014/8/12 10:55:27</pubDate>
        <description><![CDATA[
            
<h4><span style="font-family:FangSong_GB2312">1.为什么会有夸夸奇谈的未来性呢？</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">当我们谈到这个问题的时候，我们就要反思在需求理解和设计的时候对程序变动性的理解出现了偏差。“哦，我想我们总有一天炫耀做这事儿的”常常是一念之差导致的代码坏味道。总结有以下四点原因是经常导致出现夸夸奇谈未来性的原因。第一、经常在理解需求的时候主观的认为需求变动非常大，那么在设计过程中就会出现过度的设计。第二、追求设计模式的使用，经常对程序的不必要的地方进行设计模式的使用，导致代码不易理解。第三、程序的设计过程中封装变化混乱，没有将封装变化进行到底。最后、过度考虑了程序的未来性，但这些未来性并不明确。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">2.为什么夸夸其谈的未来性不好呢？</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">过度的设计导致代码不易理解和错误不易定位，也许还会降低代码执行的效率。当程序中过量的使用设计模式，导致在代码的阅读过程中很难找到主要的逻辑走向。放置过量的钩子或特殊情况来处理一些非必要的事情，可能在代码的编写调试过程中加深跟踪Bug的难度。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">3.面对夸夸奇谈的未来性的最佳实践</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">那么我们怎么处理呢？面对一个需求点的时候尽量使用最小的改动最少的变化满足需求的功能点，那么我们的程序要怎样面对变化呢？首先要明确一点这个变不变，不单单是来自设计师的合理思考设计最主要还是来自用户的业务需求。如果面对一个业务需求的变化，在进行了需求访谈之后用户明确这一部分需求变化很大而且明确的变化点，那么再重构程序使用设计模式、放置钩子或特殊处理装置来应对他的未来性。一定要注意不要使用过量的人力物力过量的钩子或特殊装置来处理那些自己认为的变化点。变不变化主要还是要看用户的业务需要的。</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/8/12 10:55:27 <a href="http://blog.csdn.net/scalzdp/article/details/38511279">原文链接</a>
            </div>
            <div>
            阅读：445 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/38511279#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码坏味道之过长的参数列]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38303523</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38303523</guid>
        <author>Scalzdp</author>
        <pubDate>2014/7/31 10:32:16</pubDate>
        <description><![CDATA[
            
<h4>1.为什么会出现过长的参数的函数呢？</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p>出现过长的参数列，我们在编写程序的时候职责划分不清晰，一个函数做了太多的事情，可能会让调用者传入更多的参数进行功能的实现。第二函数封装不合理，导致调用函数的内部变量成为封装函数的参数。</p>
</blockquote>
<p></p>
<h4>2.当我们遇上了过长的参数函数怎么办？</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p>当我们遇上了过长的参数列的函数有两种方法来解决，第一，通过重载参数把程序中暂时不需要的函数的参数进行封装，减少过长的参数列。第二，通过封装参数列对象，在封装的时候尽量将职责相近的参数放在一起，这样做提高了封装对象的内聚性。</p>
</blockquote>
<p></p>
<h4>3.怎样避免在平时的编码中出现过长的参数列？</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p>那么我们怎样来避免我们在编码中出现过长的参数列呢？在使用SSH或者Spring MVC的时候我们都会接触到很多的O，我们可以将过长的参数列封装成为一个数据传输对象，这样做即减少了参数列又提升了代码 的重用性。</p>
<p>其次我们合理的封装函数，我经常采用的方式就是编写完成一个函数之后回过头来看看这个函数的职责范围，将多余一个职责的函数进行剥离，让每一个函数都只具有单一的一个职责，这样做了之后，在需要封装参数对象的时候就可以提炼出内聚性很高的代码了。</p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/7/31 10:32:16 <a href="http://blog.csdn.net/scalzdp/article/details/38303523">原文链接</a>
            </div>
            <div>
            阅读：594 评论：3 <a href="http://blog.csdn.net/scalzdp/article/details/38303523#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码坏味道之过大的类]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/38272233</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/38272233</guid>
        <author>Scalzdp</author>
        <pubDate>2014/7/29 17:20:03</pubDate>
        <description><![CDATA[
            
<h4><span style="font-family:FangSong_GB2312">1.为什么会出现过大的类</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们的编码过程中，不知不觉的就把一个类编写的非常的庞大。为什么会这样子呢？我想无非由两个理由，首先是编码过程中为了贪图一时的方面不想动手去添加一个类用来管理不属于原先这个类的职责。其次整个系统使用了太多的继承关系，无形中就会造成子类变得异常庞大。总之，如果想利用一个类做太多的事情，往往就会造成这个类变得异常庞大。8</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">2.过大的类会照成什么严重后果</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">既然出现了过大的类，那么他到底会造成什么严重的后果呢？首先很明显一点过大的类在开发中难以调试并且在后期维护中可能因为功能的变更会导致类变得更大且更容易出现BUG。其次过大的类给代码的阅读理解造成了，对类的职责理解不清晰，不易阅读修改的困境。其次，类写的大其往往就会出现太多实例变量，一旦如此，就会出现更多的冗余代码，出现了冗余代码出现BUG调试都是非常的困难的。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">3.遇到了过大的类我们该怎么办</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">当我们面临过大的类的时候咋办啊？当遇到过大的类的时候我们可以运用Extract Class 将几个变量一起提炼至新类中，提炼的时候选择彼此相关的变量，将它们放在一起，这样做提高类的内聚性。提炼类的过程中发现有可提炼出继承关系的就是用Extract Subclass。</span></p>
<p><span style="font-family:FangSong_GB2312">类如果有太多的代码，也是代码复制、混乱并最终走向死亡的源头。最简单的方案，就是把多余的东西消弭在类内部。一个类如果拥有的代码太多，往往也适合使用Extract Class 和 Extract Subclass。如果要做的更好，先确定客户端如何使用它们，然后运用Extract Interface 为每一个使用方式提炼出一个接口。这样做可以帮助你看清楚如何分解这个类。</span></p>
<p><span style="font-family:FangSong_GB2312">那么我们怎样才能做得更好呢？这里涉及到程序员需要熟悉业务知识提炼出领域对象，将一个大的类的不同的职责分解到不同的领域对象里面，这样我们也完成了分解这个大类的目标了。</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/7/29 17:20:03 <a href="http://blog.csdn.net/scalzdp/article/details/38272233">原文链接</a>
            </div>
            <div>
            阅读：325 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/38272233#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码坏味道特征重复的代码]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/37656845</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/37656845</guid>
        <author>Scalzdp</author>
        <pubDate>2014/7/10 15:50:03</pubDate>
        <description><![CDATA[
            
<p><span style="font-family:FangSong_GB2312">重复的代码开发，在作为初级的程序员是经常遇见的，因为被要求做一些很固定且比较简单通用的模块，所以很容易就遇上功能相同的代码进行重复的开发了。</span></p>
<h4><span style="font-family:FangSong_GB2312">1.为什么会有重复的代码</span></h4>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">重复的代码可能会出现编写人员抽象公有模块抽象公有功能的能力，可能来自我们开发方式过于老化固定了类之间的相互应用所以导致编写的某一个功能只适用一个特定的系统使用，可能来自我们的设计人员对项目框架设计考虑不够仔细，没有重用性的设计过程。</span></p>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">2.怎样避免出现重复的代码</span></h4>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">使用完善的SOA框架，我认为至少在我们内网程序开发中可以节约一大部分的工作，比如在一个大的公司里面一个文件同时会涉及到被多个领导经过多级审阅才能最终完成，所以我认为可以吧这样审阅的功能做成可以配置的服务发布在内网系统之中，只要有这样的一种思想经过长期的积累与改进，一两年之后再某一个领域的相应的服务或中间件几乎覆盖了主要的业务流程，开发人员可以像搭建积木一样的快速搭建出功能模块，开发人员的主要工作就是把页面做的更加的美观，更加的实用方便。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">第二种方法就是建立主键库，把我们编码中出现的公用功能进行不断的收集封装成为dll文件每当下一个项目需要的时候可以直接进行引用该封装的中间件。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">第三种方法就是在具体开发过程中无论你是实用java或C#这些语言都是支持泛型和反射的能够熟悉的使用这种编程方法可以极大的减低代码的耦合性提高代码的重用性。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">以上就是从三个方面架构设计，主键库和具体编码方法中总结了避免重复代码的方法，以后再项目建设中不断优化不断完善。</span></p>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">3.遇到重复的代码该怎么办</span></h4>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">但是在编程中遇到重复的代码功能不可避免的，做项目的程序员和做产品的程序员两个的理解各不一样，做项目的程序员重点不会是重构抽象让代码做的足够的精细，为什么呢？因为做项目之后再程序员主要看进度，程序员没日没夜的推进着项目功能的不断建设，他们只希望项目能够快速做完快速得到验收然后拿钱......因为他们做完一个项目就会转向做另外的项目，不断做项目他们才能有不断的收获。但是做产品的兄弟可能一辈子就投入到一两个产品之中他们的一身就是为了把一个产品做的足够的完美，所以在代码层面上要做的足够的完美，如果代码做的不仔细那没后面的维护代价都得自己来抗，有一点得不偿失，所以他宁愿功能开发推迟两周出来也要保证退出来的产品能够做到足够的稳健漂亮且令人赏心悦目。</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">所以在遇到重复的代码的时候应该衡量自己所处的位置评价去抽象达到代码公用的代价，找到一个衡量点然后再采取行动——消不消灭这样的重复的代码。</span></p>
</blockquote>

            <div>
                作者：Scalzdp 发表于2014/7/10 15:50:03 <a href="http://blog.csdn.net/scalzdp/article/details/37656845">原文链接</a>
            </div>
            <div>
            阅读：412 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/37656845#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]代码的坏味道]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/36636021</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/36636021</guid>
        <author>Scalzdp</author>
        <pubDate>2014/7/3 14:42:22</pubDate>
        <description><![CDATA[
            
<h4><span style="font-family:FangSong_GB2312">1.重构和核心思想</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们一直在强调，程序中我们要不断的进行代码的重构，但是重构作为一种高度的脑力活动确实不易。为什么重构在一般的团队中不易推进呢？究其原因我认为有两方面的原因，第一、项目执行计划中不包括，团队只想更快的看到结果，没有规定时间用来重构，程序员可能有这方面的意识但是做了又不加入绩效所以也没有主动去重构的行动了。第二、没有一个统一的标准，每一个具体的开发人员都会按照自己认为的标准去编写代码实现功能，导致了编写出来的程序代码水平不一致。我认为这两方面原因是阻碍重构的主要原因。</span></p>
<p><span style="font-family:FangSong_GB2312">为什么要做重构呢？站在项目长远发展的角度来看重构可以保持项目不被频繁的修改腐化了架构，确保在下一次需求变更的时候能够更加灵活快速的实现功能而会不引起过多的改变。那么我们进行重构工作应该遵循的原则是，“在不改变功能的前提下，优化其内部结构。”。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">2.代码的坏味道</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。那么我们怎样进行代码重构呢？要进行代码重构前提是能够找到适应的切入点，敏锐的嗅觉闻到代码的坏味道。什么是敏锐的嗅觉呢？前提条件是我们对设计模式的6大原则比较清楚了并且熟悉业务需求。</span></p>
<p><span style="font-family:FangSong_GB2312">我们可以从架构和代码两个方面来发现代码坏味道了，怎样发现架构的坏味道呢？一般来说架构设计是程序搭建的基本骨架，在架构层面，要对系统功能的划分，数据存储方案设计，物理部署设计，运行设计和开发使用的架构这五方面进行设计。如果程序在开发过程中发现现有系统的逻辑功能已经超出了原先界定的范围，那么我们就发现一处坏味道了。如果开发架构中原本规定使用三层架构，但是开发中却出现了两层或直接访问数据库的情况都是不符合规范的坏味道。另一方面就是从代码编写上面，我们要把代码写的尽可能轻易被阅读，代码的编写应该使用设计模式6大原则进行检验。项目的坏味道及早发现及早修改保持项目在预期设计范围之内。</span></p>
<p><span style="font-family:FangSong_GB2312"><br>
</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">3.重构的步骤<span style="white-space:pre">
</span></span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">差劲的系统是很难修改的，因为很难找到修改点。如果很难找到修改点，程序员就很有可能犯错，从而引入Bug。重构这件事让那些已经能够运行的差劲的系统是没有人愿意去进行内部结构的优化。如果非得重构这样子的富有挑战性的系统，那么采用这几个步骤可以极大的降低重构中引入新的BUG。</span></p>
<p><span style="font-family:FangSong_GB2312">每当我要进行重构的时候，第一个步骤永远相同，得为即将修改的代码建立一组可靠的测试环境。因为我们都是人，我们要把自己当人看，是人就不可避免会犯错，所以我需要可靠的测试（自我检验能力）。</span></p>
<p><span style="font-family:FangSong_GB2312">当建立完一套完善的测试环境之后，我们以可以一步一步进行代码内部结构的优化了，不要追求一步能够把代码优化得非常成功，保持小步快走的不断对代码进行优化。</span></p>
<p><span style="font-family:FangSong_GB2312"><br>
</span></p>
</blockquote>
<span style="font-family:FangSong_GB2312">重构是一件非常繁琐的事情，程序员要不断的提升自己的语言能力，让编写的代码能够被别人读懂。有持续不断的重构意识，并且付诸实施让我们的代码保持清爽整洁易于阅读，不要做傻瓜一样的程序员，要做优秀的程序员。</span>
<p></p>
<p><br>
</p>

            <div>
                作者：Scalzdp 发表于2014/7/3 14:42:22 <a href="http://blog.csdn.net/scalzdp/article/details/36636021">原文链接</a>
            </div>
            <div>
            阅读：442 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/36636021#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]C#程序性能优化]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/34421639</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/34421639</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/25 11:55:20</pubDate>
        <description><![CDATA[
            
<p><span style="font-family:FangSong_GB2312">程序中我们每一丝动作都会加大程序运行的负担，当刚开始学习程序的时候常常不会去考虑程序运行的效率，大多数情况是为了实现功能，只要功能达到我想要的那么就算是达成了此项目标。当大部分功能的编码实现对我们来说都不是大的问题的时候，我们要提升就要考虑怎样把程序写的更加规范更加高效。怎样写的高效，我们不说整体架构的设计，仅仅分享一下C#自身程序中的一些会影响性能的点。</span></p>
<h4><span style="font-family:FangSong_GB2312">1.垃圾回收</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">.NET Framework垃圾回收的成本高，每次回收垃圾的时候调用最久未被使用的算法，找出最久未被使用的对象然后把这个对象分配的内存进行回收。进行这样的算法会非常消耗计算机的运算能力，所以在C#程序编码中避免创建不必要的对象。</span></p>
<p><span style="font-family:FangSong_GB2312">1.1避免在循环中创建对象</span></p>
</blockquote>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">高效的做法是将对象的创建置于循环之外。但是如果每一次循环需要实例化一个对象加入到对象列表中这个就避免不了在循环内部创建对象，如果把这个对象创建在对象之外那么会导致循环多次加入到列表中的对象是循环最后一次对象的数据了。</span></p>
</blockquote>
<span style="font-family:FangSong_GB2312">1.2在需要的地方才创建对象</span>
<p></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">如果对象只有在某些分支逻辑中才会被使用到，那么把具体创建对象的操作放在逻辑分支中。尽量避免在函数之前创建出函数所要使用到的所有对象。</span></p>
</blockquote>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">2.String操作</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">String字符串操作，我们多次使用到的。所以在操作String的时候采用不高效的处理会一定程度上影响到程序的执行效率。</span></p>
<p><span style="font-family:FangSong_GB2312">2.1. 我们认识一下String</span></p>
</blockquote>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">String是不变类，如果我们使用“&#43;”来连接字符串，会导致创建一个新的空间来存储连接后的字符串，在多次循环中使用“&#43;”会导致内存循环被开辟。这个时候应该使用StringBuilder。StringBuilder内部有一个StringBuffer，连接操作不会每一次都分配新的字符串空间。</span></p>
<p></p>
<pre code_snippet_id="405432" snippet_file_name="blog_20140625_1_483489"  code_snippet_id="405432" snippet_file_name="blog_20140625_1_483489" name="code" class="csharp">&lt;span style=&quot;font-family:FangSong_GB2312;&quot;&gt;StringBuilder sb = new StringBuilder(256 );
for ( int i = 0 ; i &lt; Results.Count; i ++ )
{
	sb.Append (Results[i]);
}&lt;/span&gt;</pre>
<p></p>
</blockquote>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">2.2.字符串String对象的Length与0比较最快的，其次是String.Empty或空串</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">C#在编译时将程序集中声明的所有字符串常量放到保留池中（intern pool），相同常量就不会重复分配了。</span></p>
</blockquote>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">3.线程同步</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">3.1.线程同步粒度</span></p>
</blockquote>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">C#线程同步通过Lock锁定对象，我们可以锁定一个方法，也可以锁定方法中的某一段代码。</span></p>
<p><span style="font-family:FangSong_GB2312"><br>
</span></p>
<p><span style="font-family:FangSong_GB2312">通常情况下，应该减小同步的范围，使系统获得更好的性能。</span></p>
</blockquote>
<span style="font-family:FangSong_GB2312">3.2.同步策略</span>
<p></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">使用lock锁定对象应该注意一下两点</span></p>
<p><span style="font-family:FangSong_GB2312">第一、避免使用锁定Type，锁定Type对象会影响进程中所有该锁定对象都不能被他人使用，可能会导致无厘头的错误，他的锁定范围太大了。</span></p>
<p><span style="font-family:FangSong_GB2312">第二、避免使用锁定this，程序中this表示当前对象，锁定了改对象实例会影响其他使用到该示例的方法。</span></p>
<p><span style="font-family:FangSong_GB2312">第三、建议，如果要同步，找到需要锁定的最小范围，然后实例化一个object对象，该对象只为了实现同步的目的。</span></p>
</blockquote>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">4.CLR，C#的中间语言</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">CLR是C#语言被编译之后的程序集，他是微软设计的一款中间语言。</span></p>
<p><span style="font-family:FangSong_GB2312">4.1.ValueType和ReferenceType</span></p>
</blockquote>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">value类型是从栈上面分配的，引用类型是从堆上面分配的。当&#20540;类型作为方法参数时，默认会进行参数&#20540;赋&#20540;。所以使用引用类型传递数据要比&#20540;类型传递数据效率高。</span></p>
</blockquote>
<p></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">4.2.避免装箱和拆箱</span></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">简单来说装箱就是把&#20540;类型转化为引用类型，拆箱就是把引用类型转化为&#20540;类型。</span></p>
</blockquote>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">5.异常处理</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">5.1 程序中该抛出异常的地方一定要跑出异常，使用try....catch...模块包裹，这与性能无关，但是与程序排错非常必要。<br>
5.2 程序在抛出异常和捕获异常会消耗比较大的操作，在程序编写的情况下，通过完善程序逻辑尽量避免抛出不<br>
</span></p>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">6.反射的使用</span></h4>
<p></p>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">他是将编译期间的静态绑定延迟到运行期间的动态绑定。反射带来了很多设计的灵活性，但是与静态绑定相比，动态绑定对性能有较大的影响。<br>
</span></p>
<p><span style="font-family:FangSong_GB2312">1. Type.InvokeMember<br>
　　2. ContructorInfo.Invoke<br>
　　3. Activator.CreateInstance(Type)<br>
　　4. Activator.CreateInstance(assemblyName, typeName)<br>
　　5. Assembly.CreateInstance(typeName)<br>
<span style="white-space:pre"></span>性能最快的是3，最慢的是4<br>
<span style="white-space:pre"></span>建议：<br>
<span style="white-space:pre"></span>1.如果可能，避免使用反射和动态绑定。<br>
<span style="white-space:pre"></span>2.使用接口调用方式，将动态绑定改造为早期绑定<br>
<span style="white-space:pre"></span>3.Activator.CreateInstance(Type)方式动态创建对象<br>
<span style="white-space:pre"></span>4.使用typeof操作符替代GetType调用。<br>
</span></p>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">7.普遍规律</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">推荐使用as</span></p>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">8.性能优化策略</span></h4>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="font-family:FangSong_GB2312">8.1.现在的存储设备越来越便宜，所以，实践中大部分的优化工作都是想方设法用空间换时间。</span></blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="font-family:FangSong_GB2312">8.2.性能瓶颈诊断：使用专业的工具进行代码性能的诊断，或者使用C#的StopWatch统计处程序代码执行的时间消耗。</span></blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="font-family:FangSong_GB2312">8.3.性能优化实践，性能优化方法主要有：优化系统结构、使用缓存、延后执行、优化算法和异步/多线程编程</span></blockquote>
<span style="font-family:FangSong_GB2312"><span style="white-space:pre"></span><br>
</span>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><br>
</p>
</blockquote>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
</blockquote>

            <div>
                作者：Scalzdp 发表于2014/6/25 11:55:20 <a href="http://blog.csdn.net/scalzdp/article/details/34421639">原文链接</a>
            </div>
            <div>
            阅读：452 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/34421639#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]C#批量数据处理SqlBulkCopy]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/30055935</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/30055935</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/11 15:32:20</pubDate>
        <description><![CDATA[
            
<h4><span style="font-family:FangSong_GB2312">1.什么是SqlbulkCopy，解决的问题</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">在程序处理中经常会遇见大数据量的批量操作，比如我们要把一个文本&#26684;式的数据批量插入数据库。如果按照传统的逻辑只会将从文件中读出的数据以轮询的方式一条一条的插入到目标数据库里面，这样反复连接打开数据库执行插入命令效率极其低下。所以很多程序在处理这样的插入操作的时候都是在半夜用户低风期处理，以免影响正常用户的使用。</span></p>
<p><span style="font-family:FangSong_GB2312">.Net Framework提供的SqlbulkCopy函数就可以将原来一条一条处理的数据进行批量处理，不需要在一条一条的长时间处于一件插入的操作了。</span></p>
</blockquote>
<p></p>
<h4><span style="font-family:FangSong_GB2312">2.SqlbulkCopy使用方法</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">SqlbulkCopy，首先我们需要获取到源数据源，然后连接到目标数据库建立SqlbulkCopy对应视图，最后执行插入命令。瞬间就能插入百万条数据到SqlServer数据库里面去。</span></p>
<h5><span style="font-family:FangSong_GB2312">2.1获取数据源数据</span></h5>
</blockquote>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">获取数据源数据这个可能是一个长时间的过程，因为我们的数据源来自多种类型比如，数据库、扁平文件、接口数据等等各种各样。具体的获取数据根据具体数据源需要制定解决方案。</span></p>
</blockquote>
<h5><span style="font-family:FangSong_GB2312">2.2 连接到目标数据库</span></h5>
<p></p>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">这里的SqlbulkCopy，我只用来向SqlServer数据库里面批量写入数据。能否向Oracle数据库写入数据还需要具体的研究。</span></p>
</blockquote>
<h5><span style="font-family:FangSong_GB2312">2.3 建立SqlbulkCopy对应视图和插入数据</span></h5>
</blockquote>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p></p>
<pre code_snippet_id="387296" snippet_file_name="blog_20140611_1_1562388"  code_snippet_id="387296" snippet_file_name="blog_20140611_1_1562388" name="code" class="csharp"> using (SqlBulkCopy bulkCopy = new SqlBulkCopy(trans.Connection, SqlBulkCopyOptions.KeepIdentity, trans))
&#160; &#160; &#160; &#160; &#160; &#160; {
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bulkCopy.BatchSize = 100000;
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bulkCopy.BulkCopyTimeout = 1800;


&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;//将DataTable表名作为待导入库中的目标表名&#160;
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;bulkCopy.DestinationTableName = destinationTable;


&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //将数据集合和目标服务器库表中的字段对应 &#160;
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; for (int i = 0; i &lt; sourceTable.Columns.Count; i++)
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;//列映射定义数据源中的列和目标表中的列之间的关系
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;//bulkCopy
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;bulkCopy.ColumnMappings.Add(sourceTable.Columns[i].ColumnName, sourceTable.Columns[i].ColumnName);
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //SqlBulkCopyMapping(bulkCopy);
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; try
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bulkCopy.WriteToServer(sourceTable);
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; trans.Commit();
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; catch (Exception ex)
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; Console.WriteLine(ex.Message);
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; trans.Rollback();
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
&#160; &#160; &#160; &#160; &#160; &#160; }</pre><span style="font-family:FangSong_GB2312"><br>
以上的代码指定了每一次插入数据库的数据量的大小为100000条，每一次插入数据的最大时间为1800毫秒，并且指定了插入的目标表名称。</span>
<p></p>
<p><span style="font-family:FangSong_GB2312">由于在插入过程中可能会有失败，我们为了保证插入数据的完整性，在插入过程中带上数据库事务。只有在完全插入之后提交事务，插入操作成功。</span></p>
<p><span style="font-family:FangSong_GB2312">由于我们把数据源组织成为DataTable的所以我们可以通过</span></p>
<span style="font-family:FangSong_GB2312">bulkCopy.ColumnMappings.Add(sourceTable.Columns[i].ColumnName, sourceTable.Columns[i].ColumnName);来建立DataTable和数据库里面字段之间的对应关系——通过字段名称进行对应的。最后一步通过bulkCopy.WriteToServer(sourceTable);就可以把数据源数据sourceTable插入到数据库里面了。</span>
<p></p>
<pre></pre>
<p></p>
</blockquote>
</blockquote>
<h4><span style="font-family:FangSong_GB2312">3.SqlbulkCopy需要注意的性能问题</span></h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">在使用SqlbulkCopy中需要注意的问题，要把某个数据源批量插入数据库，首先需要把这个数据源完全加载到内存之中，然后进行插入操作，这样就会占用大量的内存，如果在进行下一次插入操作的时候没有释放内存中的数据那么整个机器的运行效率会被严重的拖慢，所以建议把源数据加载成为DataTable&#26684;式然后进行插入操作之后将这个DataTable所占用的内存主动释放，然后再去处理下一个数据源。</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/6/11 15:32:20 <a href="http://blog.csdn.net/scalzdp/article/details/30055935">原文链接</a>
            </div>
            <div>
            阅读：1099 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/30055935#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]一个小程序能够反映的能力]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/29817739</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/29817739</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/10 14:11:53</pubDate>
        <description><![CDATA[
            
<p>程序员小郑刚步入岗位，但是在公司编码过程中没有受到专业的编码规范的培训，编写出来的程序虽然能够完成指定的功能但是比较不统一，偶尔会别出心裁的设计出自己的简化方法。老王这是从事了软件编码十多年了，现在都快到不惑的年龄了，在软件行业摸爬滚打十多年从事过多个行业，接触过不同公司的编码的规范，在软件代码编写中有独到的认识。</p>
<p>有一天有一个小功能的改动，由于这是一个非常重要的基础系统的功能变动，所以即便是一个小的功能变动公司上上下下都投入了非常高的重视程度。这天老王找到小郑告诉了需要修改这个系统并详细的描述了变动需求，他们两花了一个多小时进行了设计，老王并把需要修改的地方都详细的讲述给小郑，做了非常仔细的设计了。小郑按照老王的设计进行类设计编码设计，单元测试最终实现了功能。以下是他的第一个版本，同样把程序分为了经典的三层基业务逻辑层，数据服务层。</p>
<p>这是业务逻辑层</p>
<p></p>
<pre code_snippet_id="385421" snippet_file_name="blog_20140610_1_8594028"  code_snippet_id="385421" snippet_file_name="blog_20140610_1_8594028" name="code" class="csharp">   &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;/// &lt;summary&gt;
&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;/// xxxxx
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;xx队列&lt;/param&gt;
        /// &lt;param name=&quot;route&quot;&gt;xx队列&lt;/param&gt;
        /// &lt;returns&gt;返回联系人的电话号码&lt;/returns&gt;
        public static string ReplaceVirtualTel(CQueue_SC qsc, CQueue_SCRoute route)
        {
            CooperateServicesDAL dal = new CooperateServicesDAL();
            return dal.GetOrderContactMobilePhone(qsc, route);
        }</pre><br>
<br>
<p></p>
<p>这时数据逻辑层,</p>
<p></p>
<pre code_snippet_id="385421" snippet_file_name="blog_20140610_2_3642775"  code_snippet_id="385421" snippet_file_name="blog_20140610_2_3642775" name="code" class="csharp">        /// &lt;summary&gt;
&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;/// xxxxxx
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;乘客队列&lt;/param&gt;
        /// &lt;param name=&quot;route&quot;&gt;航班队列&lt;/param&gt;
        /// &lt;returns&gt;返回联系人的电话号码&lt;/returns&gt;
        public string GetOrderContactMobilePhone(CQueue_SC qsc, CQueue_SCRoute route)
        {
            try
            {
                //判断接口返回的数据里面的电话是不是虚拟电话
                if (IsTelViturl(qsc.Tel))
                {
                    //如果是虚拟电话调用接口返回数据
                    XmlDocument result = InvokeGetRealTel(qsc, route);
                    //判断接口中联系人是否正确
                    if (IsContactPersonRight(result, qsc))
                    {
                        return result.SelectSingleNode(@&quot;/Root/Return/ContactMobilePhone&quot;).InnerText.Trim();
                    }
                }
                return qsc.Tel;
            }
            catch(Exception ex) 
            {
                return qsc.Tel;
            }
        }

        /// &lt;summary&gt;
        /// 判断条件：只要联系人1和联系人2有一个人相同那么就认为是正确的。如果没有相同的姓名就认为是错误的。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;result&quot;&gt;调用联系人1数据&lt;/param&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;来自联系人2的数据&lt;/param&gt;
        /// &lt;returns&gt;返回true，乘客一致。返回false，乘客不一致&lt;/returns&gt;
        private bool IsContactPersonRight(XmlDocument result, CQueue_SC qsc) 
        {
            XmlNodeList nodes = result.SelectNodes(@&quot;/Root/Return/PassengerList/Passenger&quot;);
            List&lt;string&gt; name = qsc.Name.ToString().Split(&#39; &#39;).ToList();
            List&lt;string&gt; nameReturn = new List&lt;string&gt;();
            foreach (XmlNode xn in nodes)
            {
                string namert = xn.SelectSingleNode(&quot;PsgName&quot;).InnerText.Trim();
                nameReturn.Add(namert);
            }
            var commonNumbers = name.Intersect(nameReturn);
            if (commonNumbers.Count() &gt; 0) 
            {
                return true;
            }
            return false;
        }

        /// &lt;summary&gt;
        /// 判断返回的旅客电话是不是就是虚拟的电话
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tel&quot;&gt;旅客电话&lt;/param&gt;
        /// &lt;returns&gt;如果是虚拟电话返回true，否则返回false&lt;/returns&gt;
        private bool IsTelViturl(string tel)
        {
            List&lt;string&gt; virtualTel = ConfigurationManager.AppSettings[&quot;VirtualTel&quot;].ToString().Split(&#39; &#39;).ToList();
            if (virtualTel.Contains(tel)) {
                return true;
            }
            return false;
        }


        /// &lt;summary&gt;
        /// 调用旅客的真实电话号码
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;队列信息&lt;/param&gt;
        /// &lt;param name=&quot;route&quot;&gt;队列信息&lt;/param&gt;
        /// &lt;returns&gt;返回调用接口返回的数据&lt;/returns&gt;
        private XmlDocument InvokeGetRealTel(CQueue_SC qsc, CQueue_SCRoute route)
        {
            try
            {
                SCAirlinesZoneService.Services service = new SCAirlinesZoneService.Services();
                string command = string.Format(requestXML);
                string result = service.GetOrderContactMobilePhone(command);
                XmlDocument xmldoc = new XmlDocument();
                xmldoc.LoadXml(result);
                if (xmldoc.SelectSingleNode(@&quot;/Root/Error/Code&quot;).InnerText.Trim() != &quot;0000&quot;) 
                {
                    throw new Exception(&quot;系统异常或未找到相应数据&quot;);
                }
                return xmldoc;
            }
            catch(Exception ex) 
            {
                throw ex;
            }
        }</pre><br>
<br>
<p></p>
<p>小郑第一版本的实现过程，他将逻辑层做了非常简单的封装几乎将所有的业务都放入了数据层里面，是不合理的，这对一个有刚入职的员工来说，一不小心图方便就会把代码业务不严&#26684;按照分层的原理进行分成编写。老王看见小郑的第一个版本给小郑提出了一些修改的意见，主要思想是让小郑把程序严&#26684;按照程序的分层原理将程序严&#26684;分层，业务逻辑都放入逻辑层面，数据访问都放入数据层。这样做的好处在哪里呢，如果按照小郑第一个版本那样做，虽然能够实现功能但是如果接口一变化那么从头到尾几乎所有的程序都不再适用新的变化了。需要重新开发一套流程来让新的业务符合条件，程序的可扩展性非常局限。</p>
<p>小郑按照老王的建议进行了第二个版本的编写：</p>
<p>业务逻辑层</p>
<p></p>
<pre code_snippet_id="385421" snippet_file_name="blog_20140610_3_6324970"  code_snippet_id="385421" snippet_file_name="blog_20140610_3_6324970" name="code" class="csharp">#region 内部变量定义
        //虚拟号码存储
        private static string[] _virtualTels = null;
        #endregion

        #region 方法定义
        /// &lt;summary&gt;
        ///xxxxxx
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;队列1&lt;/param&gt;
        /// &lt;param name=&quot;route&quot;&gt;队列2&lt;/param&gt;
        /// &lt;returns&gt;返回联系人的电话号码&lt;/returns&gt;
        public static string ReplaceContactTel(CQueue_SC qsc, CQueue_SCRoute route)
        {
            try
            {
                CQueuePassenger pnrQPsg = new CQueuePassenger();
                pnrQPsg.NUM = qsc.NUM;
                pnrQPsg.ContactTel = qsc.Tel;
                pnrQPsg.PassengerNames = qsc.Name.Split(&#39; &#39;);

                //判断输入值中的联系人电话，是否虚拟电话。
                if (!IsVirtualTel(pnrQPsg.ContactTel))
                    return pnrQPsg.ContactTel; //如果不是虚拟电话，那么返回（原联系电话）。

                //获取原始订单中的数据
                CQueuePassenger orderQPsg = CooperateServicesDAL.InvokeGetRealPassenger(qsc, route);

  
                //因此通过比对旅客姓名来决定是否同一份数据。
                if (pnrQPsg.AreSame(orderQPsg))
                    return orderQPsg.ContactTel; //如果是同一份数据，那么返回从订单提取的联系人电话。

                //返回真实联系人电话。
                return qsc.Tel;
            }
            catch (Exception ex)
            {
                //可添加日志记录服务器连接失败
                return qsc.Tel; 
            }
        }

        /// &lt;summary&gt;
        /// 判旅客电话是不是就是虚拟的电话
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tel&quot;&gt;数据的旅客电话&lt;/param&gt;
        /// &lt;returns&gt;如果是虚拟电话返回true，否则返回false&lt;/returns&gt;
        public static bool IsVirtualTel(string tel)
        {
            if (_virtualTels == null)
            {
                //ConfigurationManager.AppSettings[&quot;VirtualTel&quot;].ToString().Split(&#39; &#39;);
                _virtualTels = ConfigurationManager.AppSettings[&quot;VirtualTels&quot;].ToString().Split(&#39;,&#39;); //从配置文件获取虚拟电话列表
            }

            return _virtualTels.Contains(tel.Trim());
        }
        #endregion
    }</pre><br>
数据层的代码
<p></p>
<p></p>
<pre code_snippet_id="385421" snippet_file_name="blog_20140610_4_1756184"  code_snippet_id="385421" snippet_file_name="blog_20140610_4_1756184" name="code" class="csharp">/// &lt;summary&gt;
        /// 调用方法获取旅客的电话号码
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;qsc&quot;&gt;队列信息1&lt;/param&gt;
        /// &lt;param name=&quot;route&quot;&gt;队列信息2&lt;/param&gt;
        /// &lt;returns&gt;返回调用接口返回的数据CQueuePassenger对象&lt;/returns&gt;
        public static CQueuePassenger InvokeGetRealPassenger(CQueue_SC qsc, CQueue_SCRoute route)
        {
            try
            {
                CQueuePassenger queuePassenger = new CQueuePassenger();
                SCAirlinesZoneService.Services service = new SCAirlinesZoneService.Services();
                service.Timeout = 2000;
                string command = string.Format(RequestXML);
                  string result = service.GetOrderContactMobilePhone(command);
           &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;XmlDocument xmldoc = new XmlDocument();
                xmldoc.LoadXml(result);
                if (xmldoc.SelectSingleNode(@&quot;/Root/Error/Code&quot;).InnerText.Trim() != &quot;0000&quot;)
                {
                    throw new Exception(xmldoc.SelectSingleNode(@&quot;/Root/Error/Message&quot;).InnerText.Trim());
                }
                
                XmlNodeList nodes = xmldoc.SelectNodes(@&quot;/Root/Return/PassengerList/Passenger&quot;);
                string passengers = &quot;&quot;;
                foreach (XmlNode xn in nodes)
                {
                    passengers += xn.SelectSingleNode(&quot;PsgName&quot;).InnerText.Trim();

                    passengers += &quot; &quot;;

                }
                if (!string.IsNullOrEmpty(passengers))
                {
                    passengers = passengers.Trim();
                    queuePassenger.PassengerNames = passengers.Split(&#39; &#39;);
                }
                queuePassenger.ContactTel = xmldoc.SelectSingleNode(@&quot;/Root/Return/ContactMobilePhone&quot;).InnerText.Trim();
                queuePassenger.Num = qsc.Num;
                return queuePassenger;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }</pre><br>
这里个版本我们可以明显看出业务逻辑判断都封装到了业务逻辑层了，然而数据层只负责获取数据，然后把数据封装成为一个对象。这样做的目的在于如果需要替换接口我们只需要更换数据层里面的获取数据的方法，业务逻辑层可以使用工厂方法进行相应逻辑判断，一定程度上面我们获得了程序的重用性，并在程序的可扩展性上面获得了提升。带来的另外一个好处就是提升了代码可测试性。
<p></p>
<p>基本上可以满足老王的要求了，其实我们发现变动并不是很大，最大的问题就是我们有没有意识将自己的程序编写得足够灵活，这样的代码还有修改的余地，还可以编写得更加的灵活通用，理想的情况可以做到非常的通用，比如使用泛型以及反射进行扩展。到了这一步我们的代码编写完了，我们需要考虑如何去测试这个功能的正确性，为了测试我们编写的代码，我们需要拿出当初当初设计这个逻辑的逻辑处理图。</p>
<p><img src="http://img.blog.csdn.net/20140610141340312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2NhbHpkcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<pre name="code" class="csharp"></pre>
<p>从这幅流程图里面我们可以明确测试点，以增量方式测试我们的程序是否正确。</p>
<p>1.测试接口完整性以及正确性。</p>
<p>2.测试我们的程序是否满足了要求。</p>
<p>根据这两个要求我们的可以得出测试点如下有7点：</p>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p>1.调用接口成功的情况。</p>
<p>2.调用接口失败的情况。</p>
<p>3.调用接口超时的情况。</p>
<p>4.有虚拟号且姓名匹配的测试。</p>
<p>5.有虚拟号但姓名不匹配的测试。</p>
<p>6.无虚拟号码。</p>
<p>7.配置了多个虚拟号码的情况。</p>
</blockquote>
在这里我们的测试用例的设计是按照系统流程图来的，覆盖流程图的每一个分支，而且我们的覆盖到每一个可能出现的异常。比如接口我们就考虑测试他的三个方面，目的是为了保证接口这个部件经过测试之后能够被我们完全信任。第二，顺序性测试，先测试了接口然后在测试调用的代码，因为我们的代码建立在接口调用所获取的数据，如果接口未被测试通过，我们可以模拟接口返回的数据进行代码逻辑的测试。
<p></p>
<p>所以小郑在这一次的收获就是“如何以最小的代价做到代码的易扩展性和可测试性”。</p>
<p><br>
</p>
<p><br>
</p>

            <div>
                作者：Scalzdp 发表于2014/6/10 14:11:53 <a href="http://blog.csdn.net/scalzdp/article/details/29817739">原文链接</a>
            </div>
            <div>
            阅读：361 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/29817739#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]架构设计]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/28627211</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/28627211</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/5 16:52:21</pubDate>
        <description><![CDATA[
            
<h4>1.每个人都可以做成为架构设计师</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">不懂软件的和刚入行的人们一听到架构设计，都认为是非常的高大上课题，是一个遥不可及的领域，一般人是不能做的。听起来云里雾里的，第一印象除了来自微软，阿里这些NB的公司里面的人其余的都不能做出架构&#20284;的，这是一种先入为主的思想，因为大家都在强调架构师的重要性，他的薪资有多么的高，在整个社会对他的认定导致很多人对架构设计望而生畏。放正自己的心态其实架构设计并没有多么的复杂。我们是从编码入行的，在编码实现功能的过程中我们或多或少的设计了属于自己的软件架构了。</span></p>
<p><span style="font-family:FangSong_GB2312">为什么说软件架构师需要多少年的工作经验，因为软件架构就是系统的草图，不仅是代</span></p>
<br>
<p><span style="font-family:FangSong_GB2312">码编写而且包括部署，运行、开发等这些方面进行设计，目的是为了保证软件开发、运行、扩展、性能、安全、伸缩等等质量的一个保证。只要在编码过程中不仅仅要提升编码的质量而且要留心其他方面的知识积累与学习，用不了多久你也能成为一位优秀的架构设计师。</span></p>
</blockquote>
<p></p>
<h4>2.什么是架构设计</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们要成为架构设计师我们需要了解什么是架构设计。简单一点，架构设计就是一个系统的草图，描述了构成系统的抽象组件，以及各个组件之间的是如何进行通讯的，这些组件在实现过程中可以被细化为实际的组件比如类或者对象。在面向对象领域中，组件之间的联通通常面向于接口实现的。</span></p>
<p><span style="font-family:FangSong_GB2312">在“软件架构简介”中David Garlan 和Mary Shaw 认为软件架构师有关如下问题进行设计的：“计算的算法和数据结构之外，设计并确定系统整体结构，结构问题包括总体组织结构和全局控制结构；通信、同步和数据访问的协议；设计元素功能分配；物理分布；设计元素的组成；定标与性能；备选设计的选择。”</span></p>
<p><span style="font-family:FangSong_GB2312">架构和结构会难以区分，明确一点架构不是结构，IEEE把架构定义为“系统在其环境中的最高层概念”架构还包括系统完整性、经济约束条件、审美需求和样式等。在Rational Unified Process 中对软件架构的解释：软件架构指系统重要构建的组织或结构，这些重要的构建通过接口与其他构建进行交互。</span></p>
<p><span style="font-family:FangSong_GB2312">总体来说软件架构对软件从整体到部分的描述，从开发到运行再到后期扩展的描述，从性能和安全可靠性进行描述。</span></p>
</blockquote>
<p></p>
<h4>3.架构设计为了解决什么问题</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">开发之初逻辑设计阶段要确定系统如何开发，整个系统融合为一个系统开发还是从业务角度将系统拆分为几个独立的子系统。</span></p>
<p><span style="font-family:FangSong_GB2312">在即将进入开发的时候关注了数据是如何持久化的，以及数据库选型、以及非数据库文件的存储&#26684;式，等这些存储方案的确定。</span></p>
<p><span style="font-family:FangSong_GB2312">在开发过程中我们要关注如何保证开发质量，如何分层，代码可扩展性，使用的设计模式，依赖了那些框架，开发语言这些方向的确定。</span></p>
<p><span style="font-family:FangSong_GB2312">开发完成之后进入运行阶段，如何在架构设计的时候保证运行期间的质量属性、性能、可伸展性等，主要是系统运行进程的划分，以及进程之间通过线程来通信。</span></p>
<p><span style="font-family:FangSong_GB2312">同时如果系统并非是单机运行，还需考虑系统的物理部署，系统部署在那个服务器上，这些服务器配置性能怎样能否胜任系统的运行，操作系统选型，以及系统部署的网络拓扑图，还有就是保证数据安全的数据备份怎样设计的。</span></p>
<p><span style="font-family:FangSong_GB2312">以上五个问题是从五个角度来确定架构以及架构设计需要解决的问题。</span></p>
</blockquote>
<p></p>
<h4>4.架构设计的五视图法</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们刚才从五个不同的角度知道架构设计需要解决的问题，那么使用五视图法就更加系统的分析设计我们架构了</span></p>
<h4><img src="http://img.blog.csdn.net/20140605165523453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2NhbHpkcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></h4>
<p><img src="" alt=""><br>
</p>
<p><span style="font-family:FangSong_GB2312">从这幅图里面我们可以看出架构设计五视图中各个角度需要解决的问题了，并且可以看出他们之间的联系了。</span></p>
</blockquote>
<p></p>
<h4>5.后期如何使用使用架构设计</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">无论多么好的架构如果只是为了设计完成任务都是毫无意义的，我们设计出来的架构无论是好或不好我们首先需要按照架构设计来完成系统的开发，作为项目的Leader就需要严&#26684;按照架构设计出来的标准进行检查，无论我们的开发模式敏不敏捷，到一定时间都有一个里程碑的阶段，到了这个阶段Leader牵头严&#26684;按照架构设计文档中相应的章节对开发出来的系统进行检查，及早发现问题及早解决，不要把问题向后面推。</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/6/5 16:52:21 <a href="http://blog.csdn.net/scalzdp/article/details/28627211">原文链接</a>
            </div>
            <div>
            阅读：342 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/28627211#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]计划制定与分解]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/28395879</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/28395879</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/4 13:59:20</pubDate>
        <description><![CDATA[
            
<h4>1.为什么我们要制定计划</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">老师从小就教导我们一年之计在于春，一日之计在于晨，就是说每当一个新的开始做好这计划的重要性。一个没有计划人生总是对一件事情浅尝辄止，无法深入。做好一个计划也是避免自己被社会上面的各种利诱所诱导，能够坚持的去做一件事情，并且把这件事情做好的源动力和精神支撑。没有计划的晚上我们是这样过的，每当看见别人的成功备受振奋，鼓舞自己内心的梦想之火再次熊熊燃烧，但是都是晚上想了千条路，早上起来走老路。这样的生活无论过活多久都不能有任何的突破和成就。然而那些会做计划的人们他们就会做到心静不受外界事物的冲击，能够坚持自己的梦想向着自己的目标坚实的走下去。如果你已经有了做计划的意识，那么一个好的计划或者一个难以实施的计划会决定你是不是会最终达到你的目标。这里我们一个好的计划制定的目标都是我们跳一下都能达到的，然而一个不好的计划就是每一个计划都是比较困难而且达到目标都要花费九牛二虎之力，可能的能把问题解决还包含了一些偶然性，就连自己也不知道是怎样解决的呢..</span></p>
</blockquote>
<p></p>
<h4>2.达成一个目标的五个步骤</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们要达到一个目标的五个步骤，包括当初萌生一个想法，要把这个想法清晰化不断的问自己想要达到什么样的结果或者产出什么成果，在有了明确的目标之后就可以开始制定计划，然后就列出计划的实施提纲，针对这个计划的实施提纲进行每一个大的节点的分解，直到把这个节点分解到难度适中我自己或我们组内人员都能跳一下就能达到的目标，在有了目标之后我们就可以按照制定的计划进行实施了，在这个过程中我们同样需要一个对计划监控的监控点，通过这个监控点发现我们工作中的问题和计划安排不恰当的问题，在完成计划之后进行一次总结作为计划改进的持续过程改进。</span></p>
</blockquote>
<p></p>
<h4>3.启动</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">做任何事情首先需要树立坚实的信心能够把它做出来而且做好。有了一个梦想，需要把梦想清晰化，不断问自己需要一个什么，这一步需要把自己的目标明确清晰出来，不能再是模糊&#31548;统的梦想了。明确了梦想，评定一下这个梦想是否可行，自己的能力是否能够做出来，如果自己的明确的目标是在是对自己高不可攀，我建议不要一次性完成这么宏大的理想，尽量分阶段每一个阶段明确目标，而且这个目标是可以达成的，然后一个阶段一个阶段的朝着自己梦想迈进。</span></p>
</blockquote>
<p></p>
<h4>4.接地气的计划制定</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">在明确了目标之后，列出达到这个目标的实施提纲，然后对这个提纲的每一个节点进行任务的分解仔细分解到每一个小的任务都能够快速的完成而且难度适中都是能够快速达到的。当分离细化加工每一个步骤之后，我就可以对每一个小的步骤进行耗时的评估，这个耗时是在全神贯注的工作，当然这个评估按照自己的能力和自己对任务的理解而定可能不是很准确，但是能够尽量的描述出完成的耗时，只有这样详细的加工分解之后才能比较准确的知道整个要到达的目标所要花费的时间是多长，当然这个时间需要灵活一些哈，加上一些休息时间，走神的时间，精力不集中的时间，这样的考虑更加富有人情味，如果没有人情味就不把自己当人看了。</span></p>
</blockquote>
<p></p>
<h4>5.计划的实施</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">在完成了计划制定之后就可以照着执行了，一步一步的为达到的目标迈进，严&#26684;按照计划做到不能拖延计划，可以赶一点领先计划千万不要拖延，因为一旦拖延就会把计划不当回事了。每当完成计划的一个里程碑的时候给自己一个奖励，这样的奖励鼓励者自己不断在实现梦想的道路上不断的前进，这个非常重要，比如完成一个里程碑请自己去吃一顿一直舍不得吃的大餐或请自己去看一场珍藏了很久的电影等等。</span></p>
</blockquote>
<p></p>
<h4>6.计划的监控</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">当然计划的实施还不能缺少对实施结果的监控和计划的监控，怕麻烦我一般是按照时间点和里程碑的方式进行监控的，当达到一段的时间和完成一个里程碑那么我就对自己这一段时间的实践过程进行一个小的总结。依据这个总结出来的问题可以微调一下下一阶段的计划，总结出来的经验可以不断的继承发扬出去，为以后制定计划作出经验的指导，不断的积累。</span></p>
</blockquote>
<p></p>
<h4>7.总结</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">总结是比不可少的步骤，一味的做事不去总结成长是有限的，但是不断的总结回顾，才能发现问题。这是一个发现问题和总结经验的过程，在这个过程中发现的问题持续的改进我们的每一个过程的制定，积累下来的经验就可以不断的丰富我们的阅历提升我们的能力。</span></p>
<p><span style="font-family:FangSong_GB2312">好的计划不仅仅是能够列在纸上的一个一个步骤，而是需要一步一步能够被执行的指令..</span></p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/6/4 13:59:20 <a href="http://blog.csdn.net/scalzdp/article/details/28395879">原文链接</a>
            </div>
            <div>
            阅读：388 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/28395879#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]PMP项目管理学习心得]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/28260335</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/28260335</guid>
        <author>Scalzdp</author>
        <pubDate>2014/6/3 15:31:11</pubDate>
        <description><![CDATA[
            
<h4>1.什么是项目管理</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">我们的工作和生活中普遍存在的都是一个项目的结束紧接着另一个项目的开始。达到修建一栋时尚的商业大厦，小到晚饭需要做一个番茄煎蛋，这些我们进行的每一个事情都可以理解为进行了一个项目，所以项目就在 我们身边，我们每一个人都是项目管理人员，区别好的管理人员和不好的管理人员的方式只有判断他们的成果的质量了，高效的管理能够在规定的时间使用预定的资源完成目标。</span></p>
<p><span style="font-family:FangSong_GB2312">项目是为了创造独特的产品和服务而进行的一种临时性，并且具有渐进性特点的工作。包含了三方面特点，第一特征，目标范围明确。第二约束条件，所占有的资源。第三生命周期，处于项目的不同阶段。从这三方面更能深刻的理解到进行一个项目工作的需要达到的目标，我在进行项目的时候我拥有的资源（成本，时间，人员，信息，授权范围），和项目处于的阶段的控制。</span></p>
<p><span style="font-family:FangSong_GB2312">那么什么是项目管理呢？依据PMBOK定义，项目管理通过使用知识、技能、工具和方法来组织、计划、实施并监控项目活动，使之满足项目需要。那么项目管理的特点第一、需要确定清楚且能够实现的目标，不要虚无缥缈的提出不切实际的目标进行。第二、权能资源产出（包括质量、范围、时间和费用）方面取得最佳的平衡。第三、是技术、计划和方法使得最终实现的项目结果适合项目组成员的需求与期望。</span></p>
<p><span style="font-family:FangSong_GB2312">所以在项目管理的核心理念就是首先是做正确的事，然后再把事情做正确，最后是一次就把事情做好不要反反复复的进行修改——PMBOK。</span></p>
</blockquote>
<h4>2.OPM3的要素</h4>
<p></p>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">OPM3用户衡量软件项目管理的质量，OPM3成熟模型的三大要素工具、过程和人的行为因素。</span></p>
</blockquote>
<p></p>
<h4>3.PMI项目管理的知识体系与管理过程结合OPM3的五个过程和九个领域</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p>
<table border="1" cellpadding="0" cellspacing="0" width="794">
<colgroup><col width="109"><col width="138"><col width="150"><col width="149"><col width="138"><col width="109"></colgroup>
<tbody>
<tr>
<td>
<p></p>
</td>
<td>
<p><span style="color:rgb(95,95,95)"><span style="font-family:FangSong_GB2312">启动过程组</span></span></p>
</td>
<td>
<p><span style="color:rgb(95,95,95)"><span style="font-family:FangSong_GB2312">计划过程组</span></span></p>
</td>
<td>
<p><span style="color:rgb(95,95,95)"><span style="font-family:FangSong_GB2312">执行过程组</span></span></p>
</td>
<td>
<p><span style="color:rgb(95,95,95)"><span style="font-family:FangSong_GB2312">监控过程组</span></span></p>
</td>
<td>
<p><span style="color:rgb(95,95,95)"><span style="font-family:FangSong_GB2312">收尾过程组</span></span></p>
</td>
</tr>
<tr height="62">
<td>
<p><span style="font-family:FangSong_GB2312">项目整体管理</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">制定项目章程</span></p>
<p><span style="font-family:FangSong_GB2312">初步项目范围定义</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">制定项目管理计划</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">指导与项目管理执行</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">监控项目工作</span></p>
<p><span style="font-family:FangSong_GB2312">整体变更控制</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">结束项目</span></p>
</td>
</tr>
<tr height="65">
<td>
<p><span style="font-family:FangSong_GB2312">项目范围管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">范围规划</span></p>
<p><span style="font-family:FangSong_GB2312">范围定义</span></p>
<p><span style="font-family:FangSong_GB2312">创建WBS </span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">范围核定</span></p>
<p><span style="font-family:FangSong_GB2312">范围控制</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="122">
<td>
<p><span style="font-family:FangSong_GB2312">项目进度管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">活动定义</span></p>
<p><span style="font-family:FangSong_GB2312">活动资源估算</span></p>
<p><span style="font-family:FangSong_GB2312">活动持续时间估算</span></p>
<p><span style="font-family:FangSong_GB2312">活动排序</span></p>
<p><span style="font-family:FangSong_GB2312">制定进度表</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">进度控制</span></p>
<p></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="45">
<td>
<p><span style="font-family:FangSong_GB2312">项目成本管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">费用估算</span></p>
<p><span style="font-family:FangSong_GB2312">费用预算</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">成本控制</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="41">
<td>
<p><span style="font-family:FangSong_GB2312">项目质量管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">质量规划</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">实施质量保证</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">实施质量控制</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="62">
<td>
<p><span style="font-family:FangSong_GB2312">人力资源管理</span></p>
<p></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">人力资源规划</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">项目团队组建</span></p>
<p><span style="font-family:FangSong_GB2312">项目团队建设</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">项目团队管理</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="45">
<td>
<p><span style="font-family:FangSong_GB2312">项目沟通管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">沟通规划</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">信息分发</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">绩效报告</span></p>
<p><span style="font-family:FangSong_GB2312">项目干系人管理</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="105">
<td>
<p><span style="font-family:FangSong_GB2312">项目风险管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">风险管理规划</span></p>
<p><span style="font-family:FangSong_GB2312">风险识别</span></p>
<p><span style="font-family:FangSong_GB2312">定性风险分析</span></p>
<p><span style="font-family:FangSong_GB2312">定量风险分析</span></p>
<p><span style="font-family:FangSong_GB2312">风险应对规划</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">风险监控</span></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr height="45">
<td>
<p><span style="font-family:FangSong_GB2312">项目采购管理</span></p>
</td>
<td>
<p></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">采购规划</span></p>
<p><span style="font-family:FangSong_GB2312">发包规划</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">询价</span></p>
<p><span style="font-family:FangSong_GB2312">供应方选择</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">合同管理</span></p>
</td>
<td>
<p><span style="font-family:FangSong_GB2312">合同收尾</span></p>
</td>
</tr>
</tbody>
</table>
</p>
</blockquote>
<p></p>
<h4>4.项目管理的九大知识领域</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">项目管理的求大知识领域可分为以下四个方面进行把控</span></p>
<p><span style="font-family:FangSong_GB2312">首先基准计划，包括项目范围的管理、花费时间管理、花费金钱管理、质量管理。</span></p>
<p><span style="font-family:FangSong_GB2312">其次协调资源，包括人力资源管理、采购管理和沟通管理。</span></p>
<p><span style="font-family:FangSong_GB2312">目标一致的综合管理。</span></p>
<p><span style="font-family:FangSong_GB2312">最后防范于未然的风险管理。</span></p>
</blockquote>
<p></p>
<h4>5.项目管理的五大过程关系</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">一般一个项目的开展包含了一下五个子过程，启动、计划、执行、控制、收尾。</span></p>
<p><span style="font-family:FangSong_GB2312">在项目启动中需要了解用户的问题以及包含的潜在机会，然后建立项目需要达成的目标，识别项目成功的标识，列出初步的假设、风险和障碍。</span></p>
<p><span style="font-family:FangSong_GB2312">在项目计划过程中，确定工作范围、进度、成本和质量目标，分析项目风险，确定项目资源并可以制定项目的计划了。</span></p>
<p><span style="font-family:FangSong_GB2312">在项目执行过程，依据计划执行项目，组织团队，平衡项目资源并进行文档管理。</span></p>
<p><span style="font-family:FangSong_GB2312">于此同时项目监管同时监控计划的执行和项目的质量，项目的变更控制，问题上报过程，以及修订项目的计划。</span></p>
<p><span style="font-family:FangSong_GB2312">最后就是收尾工作，首先需要获得用户的认可，为用户提供可交付的成果，完成相应的文档，完成项目评价，以及发布最终项目报告 这些工作。</span></p>
<p><span style="font-family:FangSong_GB2312">能够在完成每一个项目之后总结一下参与项目过程中的得与失会是在后面参加工作中积累经验和形成自己特有的解决问题的方法论是非常必要的。</span></p>
</blockquote>
<p></p>
<h4>6.一个成功项目管理人员所需要技巧</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">一个项目管理中需要的技能主要有以下两个方面，能够写出来形成执行过程的硬性技巧和不能写出来只能在项目管理操作中灵活使用的软技巧。</span></p>
<p><span style="font-family:FangSong_GB2312">硬技巧包括了方法梳理、过程制定以及技能培训。包括了计划、跟踪以及控制。</span></p>
<p><span style="font-family:FangSong_GB2312">软技巧是作为人员管理技能，领导团队做正确的事，团队的组织与建立，团队内部出现矛盾冲突的解决，激励团队成员，训练团队成员掌握更多的技能，以及协商利益，沟通困难和倾听问题。</span></p>
<p><span style="font-family:FangSong_GB2312">总之要成为一个成功的项目管理人员需要内外兼修，内修于心，外修于形。需要站在跟高的角度去看待项目的建设，重于战略也重于战术，是一个不择不扣的战略战术家。</span></p>
</blockquote>
<p></p>
<p><br>
</p>

            <div>
                作者：Scalzdp 发表于2014/6/3 15:31:11 <a href="http://blog.csdn.net/scalzdp/article/details/28260335">原文链接</a>
            </div>
            <div>
            阅读：777 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/28260335#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]软件的质量保证]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/27659409</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/27659409</guid>
        <author>Scalzdp</author>
        <pubDate>2014/5/30 13:51:41</pubDate>
        <description><![CDATA[
            
<h4>1.什么是软件的质量管理</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">工作质量这个词常常用来衡量体力工作者，所做的工作的有效性的评定。计件的工作自从工业革命发展以来已经拥有了一整套体系和流程来把控质量了。但是从事软件行业大部分是由脑力劳动，有几位工作多年的员工每次走过Boss的办公室看着Boss脚放在办公桌上脑袋耷拉在靠椅上嘴里叼着古巴雪茄“&#39740;才知道他是不是再思考公司的发展呢..”这就是思考的脑力劳动者我们没有一个用于衡量质量的标准。</span></p>
<p><span style="font-family:FangSong_GB2312">回过头来，我们的软件质量就是在规定时间内，使用现有能够支配的资源，做出能够满足用户需求的软件系统，我认为这样已经做到了很好的质量把控了。</span></p>
<p><span style="font-family:FangSong_GB2312">从质量的经济作用，我们常说无商不奸，商人都希望投入最小的资本产出最大的利益，在这上面他们无时无刻(ˇˍˇ） 想～从劳动者那里榨取丰盛的果汁。个人英雄时代已经过去，资本家通过思考发明各种工作流程，用以提高工人的产出。《国富论》作者亚当斯密一次走入生产大头针的小作坊里面发现分工合作流水线生产能有最大的团队产出，这种产出要比任何个人组成的团队产出都要高很多。</span></p>
<p><span style="font-family:FangSong_GB2312">在生产过程中能够建立分工合作的前提在于团队里面每一个成员的工作成果的质量都相当，促进团队内部和团队之间的交换成本降低。</span></p>
<p><span style="font-family:FangSong_GB2312">在这个过程中一位有效的管理者应该促进团队内部分工合作，降低团队内部或团队之间的交换成本。</span></p>
</blockquote>
<p></p>
<h4>2.质量管理体系包含哪些东西</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">质量管理包含以下五个方面：</span></p>
<p><span style="font-family:FangSong_GB2312">建立良好的质量文件，一个战壕的战友共同拥有高质量的意识才会做出良好的战绩，质量组织，质量计划，质量控制以及质量改进。</span></p>
<p><span style="font-family:FangSong_GB2312">建立质量文化，形成组织内部的文化基因，每一位新加入的成员都可以被培训，养成好的习惯。</span></p>
<p><span style="font-family:FangSong_GB2312">形成质量计划和质量控制，主要是监督把控质量的进程，该走到哪里或哪里出现问题可以及时发现反馈已得到高效的改进。</span></p>
<p><span style="font-family:FangSong_GB2312">日积月累之后形成自我的方法工具库、数据库和文档库这些质量资产。</span></p>
</blockquote>
<p></p>
<h4>3.软件开发中我们要做到的质量保证</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">质量的建设需要不断的长期坚持与不断的过程改进。</span></p>
<p><span style="font-family:FangSong_GB2312">从没有到有是一个基础搭建过程，从有了到高质量是一个内部深入改革问题，没有哪一个过程是简单的一触而就的。</span></p>
<p><span style="font-family:FangSong_GB2312">第一层：交警式的管理：根据规则，指出问题。</span></p>
<p><span style="font-family:FangSong_GB2312">第二层：医生式的管理：诊断问题，开出药方。</span></p>
<p><span style="font-family:FangSong_GB2312">第三层：老师式的刮泥：预测问题，提供指导。</span></p>
<p><span style="font-family:FangSong_GB2312">如果你第一层还没有达到，那么就去收集吧，可能收集的被人的规则有不适合你的那么能够持续改进那么也能建立良好的规则体系。如果已经步入了第一层，提高自己能够诊断质量问题就是下一个进阶目标了。进入第三层，恭喜你已顺利通关，不过这一层可不是那么容易达到的哦~。</span></p>
<p><span style="font-family:FangSong_GB2312">质量保证的过程通过制定质量计划，执行过程与产品检查其中可能包含了技术评审和测试工作，最后根据问题跟踪进行持续改进的过程。</span></p>
</blockquote>
<p></p>
<h4>4.质量管理中的智慧</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">质量“越高越好”，不是质量管理的追求的真理，根据商业目标决定质量目标。企业的根本目标是为了获取更多的利润，所以不要再纠结那么几个不会影响真正系统使用上面的微小缺陷了吧！做质量管理需要衡量质量、效率、成本，做出的产品恰好能够满足广大用户利益，能够满足80%的人使用就算是好产品了。</span></p>
<p><span style="font-family:FangSong_GB2312">在质量管理当一开始接手的时候会出现层出不穷各种各样的缺陷，千万不要一股脑的要把出现的缺陷全部修正正确才罢休，这时收集出来的缺陷只有20%的缺陷是80%的用户所真正关心的，能够集中80%的力量完美的修改好这20%的缺陷让80%的用户满意。</span></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/5/30 13:51:41 <a href="http://blog.csdn.net/scalzdp/article/details/27659409">原文链接</a>
            </div>
            <div>
            阅读：285 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/27659409#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]C# HashSet集合类型使用介绍]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/27346427</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/27346427</guid>
        <author>Scalzdp</author>
        <pubDate>2014/5/28 17:00:24</pubDate>
        <description><![CDATA[
            
<h4>1.HashSet集合</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">HashSet是以数学Set集合为基础的，使用HashSet可以提高集合的运算。使用HashSet集合不自带排序方法，如果需要排序的需求可以参考使用List&lt;T&gt;集合配合Sort方法。</span></p>
<p><span style="font-family:FangSong_GB2312">HashSet的优势在与运算快，作为一种存放在内存的数据，可以很快的进行设置和取&#20540;的操作。HashSet无法向里面添加重复的数据，避免添加HashSet&lt;T&gt;里面的数据重复。我们使用HashSet常常在集合相加集合相减这些集合与集合之间的操作之中。</span></p>
<p><span style="font-family:FangSong_GB2312">使用HashSet作为内存存储的快速数据库，这个需要随时跟新HashSet里面的数据，因为在HashSet中一个长时间未被访问的数据，将被系统自动回收掉，那么就会导致失败，那么如何才能保证HashSet里面的&#20540;是长存在的而且达到不断的更新里面的&#20540;呢？</span></p>
<p><span style="font-family:FangSong_GB2312">首先程序过来访问我们HashSet里面有没有需要的数据，如果有我们需要的数据就直接返回给用户，不用调用查询数据库的操作。如果HashSet里面没有我们需要的数据，程序再去查询一次数据库是否有该Query数据，如果有返回给用户同时把查询的结果添加到HashSet里面，这么做可以一定程度的降低查询数据库所带来的不便，但是不能根除，需要进一步提升性能，可以查看前面的缓存策略使用memcached来提高网站查询和访问。</span></p>
<p><span style="font-family:FangSong_GB2312"><strong>1.1.我们要求两个集合的并集</strong></span></p>
<p><pre code_snippet_id="367381" snippet_file_name="blog_20140528_1_1158767"  name="code" class="csharp">HashSet&lt;int&gt; numbers1;
HashSet&lt;int&gt; numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.UnionWith(numbers2);//求两个集合的并集。</pre><br>
<span style="font-family:FangSong_GB2312"><strong>1.2.求两个集合的交集</strong></span></p>
<p><pre code_snippet_id="367381" snippet_file_name="blog_20140528_2_6937862"  name="code" class="csharp">HashSet&lt;int&gt; numbers1;
HashSet&lt;int&gt; numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.IntersectWith(numbers2);//求两个集合的交集。</pre></p>
<p><strong><span style="font-family:FangSong_GB2312">1.3.求两个集合的差集</span></strong></p>
<p><pre code_snippet_id="367381" snippet_file_name="blog_20140528_3_4669587"  name="code" class="csharp">HashSet&lt;int&gt; numbers1;
HashSet&lt;int&gt; numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.ExceptWith(numbers2);//求两个集合的差集。</pre><br>
</p>
<p><strong><span style="font-family:FangSong_GB2312">1.4.求两个集合的对称差集</span></strong></p>
<p><pre code_snippet_id="367381" snippet_file_name="blog_20140528_4_241722"  name="code" class="csharp">HashSet&lt;int&gt; numbers1;
HashSet&lt;int&gt; numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.SymmetricExceptWith(numbers2);//求两个集合的对称差集。</pre><br>
</p>
</blockquote>
<p></p>
<h4>2.HashSet常用扩展方法</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">2.1.Add,将项目添加到HashSet之中。</span></p>
<p><span style="font-family:FangSong_GB2312">2.2.Clear,清空HashSet里面的&#20540;。</span></p>
<p><span style="font-family:FangSong_GB2312">2.3.Remove,从HashSet中移除&#20540;。</span></p>
<p><span style="font-family:FangSong_GB2312">2.4Contains，判断HashSet是否包含指定项目。</span></p>
<p><span style="font-family:FangSong_GB2312">2.4Equals(Object),判断是否相等。</span></p>
</blockquote>
<p></p>
<h4>3.HashSet与Linq操作</h4>
<p></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p><span style="font-family:FangSong_GB2312">HashSet&lt;T&gt;与LINQ的对等的方法</span></p>
<p><span style="font-family:FangSong_GB2312">UnionWith &nbsp; &nbsp; &nbsp; ==&gt; &nbsp;Union</span></p>
<p><span style="font-family:FangSong_GB2312">IntersectWith &nbsp;==&gt; &nbsp;Interset</span></p>
<p><span style="font-family:FangSong_GB2312">ExceptWith &nbsp; &nbsp; ==&gt; &nbsp;Except</span></p>
<p><span style="font-family:FangSong_GB2312">不提供排序 &nbsp; &nbsp; ==&gt; &nbsp;Distinct</span></p>
<p><span style="font-family:FangSong_GB2312">那么我们已经有很多的集合类型如List&lt;T&gt; ,Dictionary&lt;TKey,TValue&gt;或Hashtable等这些集合类型，我们该如何选定我应该采用的哪一个集合类型呢？</span></p>
<p><span style="font-family:FangSong_GB2312">“如果你必须建立新的设定，或则如果应用程序只需要存取提供的任务，那么使用任何的IEnumerable&lt;T&gt;集合都已经足够了。但是，如果应用程序需要存取其他&#20540;，或则不建议不需要建立新的集合，这时可使用HashSet&lt;T&gt;.”——摘自MSDN</span></p>
<p><a target="_blank" href="http://msdn.microsoft.com/zh-tw/library/bb397728(v=vs.110).aspx"><span style="font-family:FangSong_GB2312">http://msdn.microsoft.com/zh-tw/library/bb397728(v=vs.110).aspx</span></a></p>
<p><br>
</p>
<p><br>
</p>
</blockquote>
<p></p>

            <div>
                作者：Scalzdp 发表于2014/5/28 17:00:24 <a href="http://blog.csdn.net/scalzdp/article/details/27346427">原文链接</a>
            </div>
            <div>
            阅读：3041 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/27346427#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[转]C# Socket编程]]></title>
        <link>http://blog.csdn.net/scalzdp/article/details/27109549</link>
        <guid>http://blog.csdn.net/scalzdp/article/details/27109549</guid>
        <author>Scalzdp</author>
        <pubDate>2014/5/26 20:40:26</pubDate>
        <description><![CDATA[
            
<div id="topics" style="margin:0px; padding:0px 0px 10px; width:716px; min-height:800px; float:left; text-overflow:ellipsis; overflow:hidden; word-break:break-all">
<div class="post" style="margin:0px; padding:0px">
<div class="postBody" style="margin:0px; padding:24px 2px 5px 5px; line-height:2em; color:rgb(64,50,38); border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:black">
<div id="cnblogs_post_body" style="margin:0px 0px 20px; padding:0px">Microsoft.Net&nbsp;Framework为应用程序访问Internet提供了分层的、可扩展的以及受管辖的网络服务，其名字空间System.Net和System.Net.Sockets包含丰富的类可以开发多种网络应用程序。.Net类采用的分层结构允许应用程序在不同的控制级别上访问网络，开发人员可以根据需要选择针对不同的级别编制程序，这些级别几乎囊括了Internet的所有需要--从socket套接字到普通的请求/响应，更重要的是，这种分层是可以扩展的，能够适应Internet不断扩展的需要。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;抛开ISO/OSI模型的7层构架，单从TCP/IP模型上的逻辑层面上看，.Net类可以视为包含3个层次：请求/响应层、应用协议层、传输层。WebReqeust和WebResponse&nbsp;代表了请求/响应层，支持Http、Tcp和Udp的类组成了应用协议层，而Socket类处于传输层。&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;传输层位于这个结构的最底层，当其上面的应用协议层和请求/响应层不能满足应用程序的特殊需要时，就需要使用这一层进行Socket套接字编程。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;而在.Net中，System.Net.Sockets&nbsp;命名空间为需要严密控制网络访问的开发人员提供了&nbsp;Windows&nbsp;Sockets&nbsp;(Winsock)&nbsp;接口的托管实现。System.Net&nbsp;命名空间中的所有其他网络访问类都建立在该套接字Socket实现之上，如TCPClient、TCPListener&nbsp;和&nbsp;UDPClient&nbsp;类封装有关创建到&nbsp;Internet&nbsp;的&nbsp;TCP&nbsp;和&nbsp;UDP&nbsp;连接的详细信息；NetworkStream类则提供用于网络访问的基础数据流等，常见的许多Internet服务都可以见到Socket的踪影，如Telnet、Http、Email、Echo等，这些服务尽管通讯协议Protocol的定义不同，但是其基础的传输都是采用的Socket。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;其实，Socket可以象流Stream一样被视为一个数据通道，这个通道架设在应用程序端（客户端）和远程服务器端之间，而后，数据的读取（接收）和写入（发送）均针对这个通道来进行。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;可见，在应用程序端或者服务器端创建了Socket对象之后，就可以使用Send/SentTo方法将数据发送到连接的Socket,或者使用Receive/ReceiveFrom方法接收来自连接Socket的数据；&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;针对Socket编程，.NET&nbsp;框架的&nbsp;Socket&nbsp;类是&nbsp;Winsock32&nbsp;API&nbsp;提供的套接字服务的托管代码版本。其中为实现网络编程提供了大量的方法，大多数情况下，Socket&nbsp;类方法只是将数据封送到它们的本机&nbsp;Win32&nbsp;副本中并处理任何必要的安全检查。如果你熟悉Winsock&nbsp;API函数，那么用Socket类编写网络程序会非常容易，当然，如果你不曾接触过，也不会太困难，跟随下面的解说，你会发觉使用Socket类开发windows&nbsp;网络应用程序原来有规可寻，它们在大多数情况下遵循大致相同的步骤。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;在使用之前，你需要首先创建Socket对象的实例，这可以通过Socket类的构造方法来实现：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;Socket(AddressFamily&nbsp;addressFamily,SocketType&nbsp;socketType,ProtocolType&nbsp;protocolType);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;其中，addressFamily&nbsp;参数指定&nbsp;Socket&nbsp;使用的寻址方案，socketType&nbsp;参数指定&nbsp;Socket&nbsp;的类型，protocolType&nbsp;参数指定&nbsp;Socket&nbsp;使用的协议。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;下面的示例语句创建一个&nbsp;Socket，它可用于在基于&nbsp;TCP/IP&nbsp;的网络（如&nbsp;Internet）上通讯。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket&nbsp;s&nbsp;=&nbsp;new&nbsp;Socket(AddressFamily.InterNetwork,&nbsp;SocketType.Stream,&nbsp;ProtocolType.Tcp);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;若要使用&nbsp;UDP&nbsp;而不是&nbsp;TCP，需要更改协议类型，如下面的示例所示：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket&nbsp;s&nbsp;=&nbsp;new&nbsp;Socket(AddressFamily.InterNetwork,&nbsp;SocketType.Dgram,&nbsp;ProtocolType.Udp);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;一旦创建&nbsp;Socket，在客户端，你将可以通过Connect方法连接到指定的服务器，并通过Send/SendTo方法向远程服务器发送数据，而后可以通过Receive/ReceiveFrom从服务端接收数据；而在服务器端，你需要使用Bind方法绑定所指定的接口使Socket与一个本地终结点相联，并通过Listen方法侦听该接口上的请求，当侦听到用户端的连接时，调用Accept完成连接的操作，创建新的Socket以处理传入的连接请求。使用完&nbsp;Socket&nbsp;后，记住使用&nbsp;Shutdown&nbsp;方法禁用&nbsp;Socket，并使用&nbsp;Close&nbsp;方法关闭&nbsp;Socket。其间用到的方法/函数有：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Connect方法:建立到远程设备的连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Connect(EndPoint&nbsp;remoteEP)（有重载方法）&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Send&nbsp;方法:从数据中的指示位置开始将数据发送到连接的&nbsp;Socket。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;int&nbsp;Send(byte[],&nbsp;int,&nbsp;SocketFlags);(有重载方法)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.SendTo&nbsp;方法&nbsp;将数据发送到特定终结点。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;int&nbsp;SendTo(byte[],&nbsp;EndPoint);（有重载方法）&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Receive方法:将数据从连接的&nbsp;Socket&nbsp;接收到接收缓冲区的特定位置。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;int&nbsp;Receive(byte[],int,SocketFlags);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.ReceiveFrom方法：接收数据缓冲区中特定位置的数据并存储终结点。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;int&nbsp;ReceiveFrom(byte[],&nbsp;int,&nbsp;SocketFlags,&nbsp;ref&nbsp;EndPoint);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Bind&nbsp;方法：使&nbsp;Socket&nbsp;与一个本地终结点相关联：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Bind(&nbsp;EndPoint&nbsp;localEP&nbsp;);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Listen方法：将&nbsp;Socket&nbsp;置于侦听状态。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Listen(&nbsp;int&nbsp;backlog&nbsp;);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Accept方法:创建新的&nbsp;Socket&nbsp;以处理传入的连接请求。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;Socket&nbsp;Accept();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Shutdown方法:禁用某&nbsp;Socket&nbsp;上的发送和接收&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Shutdown(&nbsp;SocketShutdown&nbsp;how&nbsp;);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket.Close方法:强制&nbsp;Socket&nbsp;连接关闭&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;可以看出，以上许多方法包含EndPoint类型的参数，在Internet中，TCP/IP&nbsp;使用一个网络地址和一个服务端口号来唯一标识设备。网络地址标识网络上的特定设备；端口号标识要连接到的该设备上的特定服务。网络地址和服务端口的组合称为终结点，在&nbsp;.NET&nbsp;框架中正是由&nbsp;EndPoint&nbsp;类表示这个终结点，它提供表示网络资源或服务的抽象，用以标志网络地址等信息。.Net同时也为每个受支持的地址族定义了&nbsp;EndPoint&nbsp;的子代；对于&nbsp;IP&nbsp;地址族，该类为&nbsp;IPEndPoint。IPEndPoint&nbsp;类包含应用程序连接到主机上的服务所需的主机和端口信息，通过组合服务的主机IP地址和端口号，IPEndPoint&nbsp;类形成到服务的连接点。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;用到IPEndPoint类的时候就不可避免地涉及到计算机IP地址，.Net中有两种类可以得到IP地址实例：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPAddress类：IPAddress&nbsp;类包含计算机在&nbsp;IP&nbsp;网络上的地址。其Parse方法可将&nbsp;IP&nbsp;地址字符串转换为&nbsp;IPAddress&nbsp;实例。下面的语句创建一个&nbsp;IPAddress&nbsp;实例：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPAddress&nbsp;myIP&nbsp;=&nbsp;IPAddress.Parse(&quot;192.168.1.2&quot;);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Dns&nbsp;类：向使用&nbsp;TCP/IP&nbsp;Internet&nbsp;服务的应用程序提供域名服务。其Resolve&nbsp;方法查询&nbsp;DNS&nbsp;服务器以将用户友好的域名（如&quot;host.contoso.com&quot;）映射到数字形式的&nbsp;Internet&nbsp;地址（如&nbsp;192.168.1.1）。Resolve方法&nbsp;返回一个&nbsp;IPHostEnty&nbsp;实例，该实例包含所请求名称的地址和别名的列表。大多数情况下，可以使用&nbsp;AddressList&nbsp;数组中返回的第一个地址。下面的代码获取一个&nbsp;IPAddress&nbsp;实例，该实例包含服务器&nbsp;host.contoso.com&nbsp;的&nbsp;IP&nbsp;地址。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPHostEntry&nbsp;ipHostInfo&nbsp;=&nbsp;Dns.Resolve(&quot;host.contoso.com&quot;);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPAddress&nbsp;ipAddress&nbsp;=&nbsp;ipHostInfo.AddressList[0];&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;你也可以使用GetHostName方法得到IPHostEntry实例：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPHosntEntry&nbsp;hostInfo=Dns.GetHostByName(&quot;host.contoso.com&quot;)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;在使用以上方法时，你将可能需要处理以下几种异常：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;SocketException异常：访问Socket时操作系统发生错误引发&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;ArgumentNullException异常：参数为空引用引发&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;ObjectDisposedException异常：Socket已经关闭引发&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;在掌握上面得知识后，下面的代码将该服务器主机（&nbsp;host.contoso.com的&nbsp;IP&nbsp;地址与端口号组合，以便为连接创建远程终结点：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPEndPoint&nbsp;ipe&nbsp;=&nbsp;new&nbsp;IPEndPoint(ipAddress,11000);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;确定了远程设备的地址并选择了用于连接的端口后，应用程序可以尝试建立与远程设备的连接。下面的示例使用现有的&nbsp;IPEndPoint&nbsp;实例与远程设备连接，并捕获可能引发的异常：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;try&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;s.Connect(ipe);//尝试连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//处理参数为空引用异常&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(ArgumentNullException&nbsp;ae)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;ArgumentNullException&nbsp;:&nbsp;{0}&quot;,&nbsp;ae.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//处理操作系统异常&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(SocketException&nbsp;se)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;SocketException&nbsp;:&nbsp;{0}&quot;,&nbsp;se.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;Unexpected&nbsp;exception&nbsp;:&nbsp;{0}&quot;,&nbsp;e.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;需要知道的是：Socket&nbsp;类支持两种基本模式：同步和异步。其区别在于：在同步模式中，对执行网络操作的函数（如&nbsp;Send&nbsp;和&nbsp;Receive）的调用一直等到操作完成后才将控制返回给调用程序。在异步模式中，这些调用立即返回。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;另外，很多时候，Socket编程视情况不同需要在客户端和服务器端分别予以实现，在客户端编制应用程序向服务端指定端口发送请求，同时编制服务端应用程序处理该请求，这个过程在上面的阐述中已经提及；当然，并非所有的Socket编程都需要你严&#26684;编写这两端程序；视应用情况不同，你可以在客户端构造出请求字符串，服务器相应端口捕获这个请求，交由其公用服务程序进行处理。以下事例语句中的字符串就向远程主机提出页面请求：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;string&nbsp;Get&nbsp;=&nbsp;&quot;GET&nbsp;/&nbsp;HTTP/1.1\r\nHost:&nbsp;&quot;&nbsp;&#43;&nbsp;server&nbsp;&#43;&nbsp;&quot;\r\nConnection:&nbsp;Close\r\n\r\n&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;远程主机指定端口接受到这一请求后，就可利用其公用服务程序进行处理而不需要另行编制服务器端应用程序。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;综合运用以上阐述的使用Visual&nbsp;C#进行Socket网络程序开发的知识，下面的程序段完整地实现了Web页面下载功能。用户只需在窗体上输入远程主机名（Dns&nbsp;主机名或以点分隔的四部分表示法&#26684;式的&nbsp;IP&nbsp;地址）和预保存的本地文件名，并利用专门提供Http服务的80端口，就可以获取远程主机页面并保存在本地机指定文件中。如果保存&#26684;式是.htm&#26684;式，你就可以在Internet浏览器中打开该页面。适当添加代码，你甚至可以实现一个简单的浏览器程序。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;实现此功能的主要源代码如下：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//&quot;开始&quot;按钮事件&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;private&nbsp;void&nbsp;button1_Click(object&nbsp;sender,&nbsp;System.EventArgs&nbsp;e)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//取得预保存的文件名&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;fileName=textBox3.Text.Trim();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//远程主机&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;hostName=textBox1.Text.Trim();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//端口&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;int&nbsp;port=Int32.Parse(textBox2.Text.Trim());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//得到主机信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPHostEntry&nbsp;ipInfo=Dns.GetHostByName(hostName);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//取得IPAddress[]&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddress[]&nbsp;ipAddr=ipInfo.AddressList;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//得到ip&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddress&nbsp;ip=ipAddr[0];&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//组合出远程终结点&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPEndPoint&nbsp;hostEP=new&nbsp;IPEndPoint(ip,port);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//创建Socket&nbsp;实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Socket&nbsp;socket=new&nbsp;Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//尝试连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;socket.Connect(hostEP);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;se)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;连接错误&quot;&#43;se.Message,&quot;提示信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;,MessageBoxButtons.RetryCancel,MessageBoxIcon.Information);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//发送给远程主机的请求内容串&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;string&nbsp;sendStr=&quot;GET&nbsp;/&nbsp;HTTP/1.1\r\nHost:&nbsp;&quot;&nbsp;&#43;&nbsp;hostName&nbsp;&#43;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&quot;\r\nConnection:&nbsp;Close\r\n\r\n&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//创建bytes字节数组以转换发送串&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;byte[]&nbsp;bytesSendStr=new&nbsp;byte[1024];&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//将发送内容字符串转换成字节byte数组&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;bytesSendStr=Encoding.ASCII.GetBytes(sendStr);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//向主机发送请求&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;socket.Send(bytesSendStr,bytesSendStr.Length,0);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;catch(Exception&nbsp;ce)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;发送错误:&quot;&#43;ce.Message,&quot;提示信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;,MessageBoxButtons.RetryCancel,MessageBoxIcon.Information);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//声明接收返回内容的字符串&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;recvStr=&quot;&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//声明字节数组，一次接收数据的长度为1024字节&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;byte[]&nbsp;recvBytes=new&nbsp;byte[1024];&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//返回实际接收内容的字节数&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;int&nbsp;bytes=0;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//循环读取，直到接收完所有数据&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;while(true)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;bytes=socket.Receive(recvBytes,recvBytes.Length,0);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//读取完成后退出循环&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;if(bytes〈=0)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;break;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//将读取的字节数转换为字符串&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;recvStr&#43;=Encoding.ASCII.GetString(recvBytes,0,bytes);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//将所读取的字符串转换为字节数组&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;byte[]&nbsp;content=Encoding.ASCII.GetBytes(recvStr);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//创建文件流对象实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;FileStream&nbsp;fs=new&nbsp;FileStream(fileName,FileMode.OpenOrCreate,FileAccess.ReadWrite);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//写入文件&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;fs.Write(content,0,content.Length);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;catch(Exception&nbsp;fe)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;文件创建/写入错误:&quot;&#43;fe.Message,&quot;提示信息&quot;,MessageBoxButtons.RetryCancel,MessageBoxIcon.Information);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//禁用Socket&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;socket.Shutdown(SocketShutdown.Both);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//关闭Socket&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;socket.Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;程序在WindowsXP中文版、.Net&nbsp;Frameworkd&nbsp;中文正式版、Visual&nbsp;Studio.Net中文正式版下调试通过&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;关于作者&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;宋华，96年毕业于承德石油学院电子与电气系计算机应用专业，同年进入中国石油天然气集团公司吐哈油田工作，一直从事网络规划与建设、网站架构与设计，现专门从事Internet应用程序开发及Windows应用程序开发。<br style="margin:0px; padding:0px">
<br style="margin:0px; padding:0px">
<br style="margin:0px; padding:0px">
Visual&nbsp;C#.Net网络程序开发-Tcp篇<br style="margin:0px; padding:0px">
<br style="margin:0px; padding:0px">
前一篇《Visual&nbsp;C#.Net网络程序开发-Socket篇》中说到：支持Http、Tcp和Udp的类组成了TCP/IP三层模型(请求响应层、应用协议层、传输层)的中间层-应用协议层，该层的类比位于最底层的Socket类提供了更高层次的抽象，它们封装&nbsp;TCP&nbsp;和&nbsp;UDP&nbsp;套接字的创建，不需要处理连接的细节，这使得我们在编写套接字级别的协议时，可以更多地尝试使用&nbsp;TCPClient&nbsp;、&nbsp;UDPClient和TcpListener，而不是直接向&nbsp;Socket&nbsp;中写。它们之间的这种层次关系示意如下：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;可见，&nbsp;TcpClient&nbsp;类基于&nbsp;Socket&nbsp;类构建，这是它能够以更高的抽象程度提供&nbsp;TCP&nbsp;服务的基础。正因为这样，许多应用层上的通讯协议，比如FTP(File&nbsp;Transfers&nbsp;Protocol)文件传输协议、HTTP(Hypertext&nbsp;Transfers&nbsp;Protocol)超文本传输协议等都直接创建在TcpClient等类之上。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;TCPClient&nbsp;类使用&nbsp;TCP&nbsp;从&nbsp;Internet&nbsp;资源请求数据。TCP&nbsp;协议建立与远程终结点的连接，然后使用此连接发送和接收数据包。TCP&nbsp;负责确保将数据包发送到终结点并在数据包到达时以正确的顺序对其进行组合。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;从名字上就可以看出，TcpClient类专为客户端设计，它为&nbsp;TCP&nbsp;网络服务提供客户端连接。TcpClient&nbsp;提供了通过网络连接、发送和接收数据的简单方法。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;若要建立&nbsp;TCP&nbsp;连接，必须知道承载所需服务的网络设备的地址(IPAddress)以及该服务用于通讯的&nbsp;TCP&nbsp;端口&nbsp;(Port)。Internet&nbsp;分配号码机构&nbsp;(Internet&nbsp;Assigned&nbsp;Numbers&nbsp;Authority,&nbsp;IANA)&nbsp;定义公共服务的端口号（你可以访问&nbsp;<a target="_blank" href="http://www.iana.org/assignments/port-numbers" target="_blank" style="margin:0px; padding:0px; color:rgb(90,90,90)">http://www.iana.org/assignments/port-numbers</a>获得这方面更详细的资料）。IANA&nbsp;列表中所没有的服务可使用&nbsp;1,024&nbsp;到&nbsp;65,535&nbsp;这一范围中的端口号。要创建这种连接，你可以选用TcpClient类的三种构造函数之一：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;1、public&nbsp;TcpClient()当使用这种不带任何参数的构造函数时，将使用本机默认的ip地址并将使用默认的通信端口号0。这样情况下，如果本机不止一个ip地址，将无法选择使用。以下语句示例了如何使用默认构造函数来创建新的&nbsp;TcpClient：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;TcpClient&nbsp;tcpClientC&nbsp;=&nbsp;new&nbsp;TcpClient();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;2、public&nbsp;TcpClient(IPEndPoint)使用本机IPEndPoint创建TcpClient的实例对象。上一篇介绍过了，IPEndPoint将网络端点表示为IP地址和端口号，在这里它用于指定在建立远程主机连接时所使用的本地网络接口（IP&nbsp;地址）和端口号，这个构造方法为使用本机IPAddress和Port提供了选择余地。下面的语句示例了如何使用本地终结点创建&nbsp;TcpClient&nbsp;类的实例：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPHostEntry&nbsp;ipInfo=Dns.GetHostByName(&quot;www.tuha.net&quot;);//主机信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddressList[]&nbsp;ipList=ipInfo.AddressList;//IP地址数组&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddress&nbsp;ip=ipList[0];//多IP地址时一般用第一个&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPEndPoint&nbsp;ipEP=new&nbsp;IPEndPoint(ip,4088);//得到网络终结点&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;TcpClient&nbsp;tcpClientA&nbsp;=&nbsp;new&nbsp;TcpClient(ipLocalEndPoint);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e&nbsp;)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(e.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;到这里，你可能会感到困惑，客户端要和服务端创建连接，所指定的IP地址及通信端口号应该是远程服务器的呀！事实上的确如此，使用以上两种构造函数，你所实现的只是TcpClient实例对象与IP地址和Port端口的绑定，要完成连接，你还需要显式指定与远程主机的连接，这可以通过TcpClient类的Connect方法来实现，&nbsp;Connet方法使用指定的主机名和端口号将客户端连接到&nbsp;远程主机：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;1)、public&nbsp;void&nbsp;Connect(IPEndPoint);&nbsp;使用指定的远程网络终结点将客户端连接到远程&nbsp;TCP&nbsp;主机。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Connect(IPAddress,&nbsp;int);&nbsp;使用指定的&nbsp;IP&nbsp;地址和端口号将客户端连接到&nbsp;TCP&nbsp;主机。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Connect(string,&nbsp;int);&nbsp;将客户端连接到指定主机上的指定端口。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;需要指出的是，Connect方法的所有重载形式中的参数IPEndPoint网络终&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;结点、IPAddress以及表现为string的Dns主机名和int指出的Port端口均指的是远程服务器。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;以下示例语句使用主机默认IP和Port端口号0与远程主机建立连接：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;TcpClient&nbsp;tcpClient&nbsp;=&nbsp;new&nbsp;TcpClient();//创建TcpClient对象实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;tcpClient.Connect(&quot;www.contoso.com&quot;,11002);//建立连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e&nbsp;){&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(e.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;3、public&nbsp;TcpClient(string,&nbsp;int);初始化&nbsp;TcpClient&nbsp;类的新实例并连接到指定主机上的指定端口。与前两个构造函数不一样，这个构造函数将自动建立连接，你不再需要额外调用Connect方法，其中string类型的参数表示远程主机的Dns名，如：www.tuha.net。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;以下示例语句调用这一方法实现与指定主机名和端口号的主机相连：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;TcpClient&nbsp;tcpClientB&nbsp;=&nbsp;new&nbsp;TcpClient(&quot;www.tuha.net&quot;,&nbsp;4088);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e&nbsp;)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Console.WriteLine(e.ToString());&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;前面我们说,TcpClient类创建在Socket之上，在Tcp服务方面提供了更高层次的抽象,体现在网络数据的发送和接受方面,是TcpClient使用标准的Stream流处理技术，使得它读写数据更加方便直观，同时，.Net框架负责提供更丰富的结构来处理流，贯穿于整个.Net框架中的流具有更广泛的兼容性，构建在更一般化的流操作上的通用方法使我们不再需要困惑于文件的实际内容（HTML、XML&nbsp;或其他任何内容），应用程序都将使用一致的方法（Stream.Write、Stream.Read）&nbsp;发送和接收数据。另外，流在数据从&nbsp;Internet&nbsp;下载的过程中提供对数据的即时访问，可以在部分数据到达时立即开始处理，而不需要等待应用程序下载完整个数据集。.Net中通过NetworkStream类实现了这些处理技术。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;NetworkStream&nbsp;类包含在.Net框架的System.Net.Sockets&nbsp;命名空间里，该类专门提供用于网络访问的基础数据流。NetworkStream&nbsp;实现通过网络套接字发送和接收数据的标准.Net&nbsp;框架流机制。NetworkStream&nbsp;支持对网络数据流的同步和异步访问。NetworkStream&nbsp;从&nbsp;Stream&nbsp;继承，后者提供了一组丰富的用于方便网络通讯的方法和属性。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;同其它继承自抽象基类Stream的所有流一样，NetworkStream网络流也可以被视为一个数据通道，架设在数据来源端(客户Client)和接收端（服务Server）之间，而后的数据读取及写入均针对这个通道来进行。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;.Net框架中，NetworkStream流支持两方面的操作：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;1、&nbsp;写入流。写入是从数据结构到流的数据传输。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;2、读取流。读取是从流到数据结构（如字节数组）的数据传输。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;与普通流Stream不同的是，网络流没有当前位置的统一概念，因此不支持查找和对数据流的随机访问。相应属性CanSeek&nbsp;始终返回&nbsp;false，而&nbsp;Seek&nbsp;和&nbsp;Position&nbsp;方法也将引发&nbsp;NotSupportedException。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;基于Socket上的应用协议方面，你可以通过以下两种方式获取NetworkStream网络数据流：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;1、使用NetworkStream构造函数：public&nbsp;NetworkStream(Socket,&nbsp;FileAccess,&nbsp;bool);（有重载方法）,它用指定的访问权限和指定的&nbsp;Socket&nbsp;所属权为指定的&nbsp;Socket&nbsp;创建&nbsp;NetworkStream&nbsp;类的新实例，使用前你需要创建Socket对象实例，并通过Socket.Connect方法建立与远程服务端的连接，而后才可以使用该方法得到网络传输流。示例如下：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;Socket&nbsp;s=new&nbsp;Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);//创建客户端Socket对象实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;s.Connect(&quot;www.tuha.net&quot;,4088);//建立与远程主机的连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e){&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.show(&quot;连接错误：&quot;&nbsp;&#43;e.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;NetworkStream&nbsp;stream=new&nbsp;NetworkStream(s,FileAccess.ReadWrite,false);//取得网络传输流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;2、通过TcpClient.GetStream方法：public&nbsp;NetworkStream&nbsp;etStream();它返回用于发送和接收数据的基础网络流NetworkStream。GetStream&nbsp;通过将基础&nbsp;Socket&nbsp;用作它的构造函数参数来创建&nbsp;NetworkStream&nbsp;类的实例。使用前你需要先创TcpClient对象实例并建立与远程主机的连接，示例如下：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;TcpClient&nbsp;tcpClient&nbsp;=&nbsp;new&nbsp;TcpClient();//创建TcpClient对象实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;Try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;tcpClient.Connect(&quot;www.tuha.net&quot;,4088);//尝试与远程主机相连&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e){&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;连接错误:&quot;&#43;e.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;NetworkStream&nbsp;stream=tcpClient.GetStream();//获取网络传输流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;TcpClient错误：&quot;&#43;e.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;通过以上方法得到NetworkStream网络流之后,你就可以使用标准流读写方法Write和Read来发送和接受数据了。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;以上是.Net下使用TcpClient类实现客户端编程的技术资料，为了向客户端提供这些服务，我们还需要编制相应的服务端程序，前一篇《Visual&nbsp;C#.Net网络程序开发-Socket篇》上曾经提到，&nbsp;Socket作为其他网络协议的基础，既可以面向客户端开发，也可以面向服务端开发，在传输层面上使用较多，而在应用协议层面上，客户端我们采用构建于Socket类之上的TcpClient取代Socket；相应地，构建于Socket之上的TcpListener提供了更高理念级别的&nbsp;TCP&nbsp;服务，使得我们能更方便地编写服务端应用程序。正是因为这样的原因，像FTP&nbsp;和&nbsp;HTTP&nbsp;这样的应用层协议都是在&nbsp;TcpListener&nbsp;类的基础上建立的。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;.Net中的TCPListener&nbsp;用于监视TCP&nbsp;端口上的传入请求，通过绑定本机IP地址和相应端口（这两者应与客户端的请求一致）创建TcpListener对象实例,并由Start方法启动侦听；当TcpListener侦听到用户端的连接后，视客户端的不同请求方式，通过AcceptTcpClient&nbsp;方法接受传入的连接请求并创建&nbsp;TcpClient&nbsp;以处理请求，或者通过AcceptSocket&nbsp;方法接受传入的连接请求并创建&nbsp;Socket&nbsp;以处理请求。最后，你需要使用&nbsp;Stop&nbsp;关闭用于侦听传入连接的&nbsp;Socket，你必须也关闭从&nbsp;AcceptSocket&nbsp;或&nbsp;AcceptTcpClient&nbsp;返回的任何实例。这个过程详细解说如下：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;首先，创建TcpListener对象实例，这通过TcpListener类的构造方法来实现：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;TcpListener(port);//指定本机端口&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;TcpListener(IPEndPoint)//指定本机终结点&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;TcpListener(IPAddress,port)//指定本机IP地址及端口&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;以上方法中的参数在前面多次提到，这里不再细述，唯一需要提醒的是，这些参数均针对服务端主机。下面的示例演示创建&nbsp;TcpListener&nbsp;类的实例：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;IPHostEntry&nbsp;ipInfo=Dns.Resolve(&quot;127.0.0.1&quot;);//主机信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddressList[]&nbsp;ipList=ipInfo.IPAddressList;//IP数组&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;IPAddress&nbsp;ip=ipList[0];//IP&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;TcpListener&nbsp;tcpListener&nbsp;=&nbsp;new&nbsp;TcpListener(ipAddress,&nbsp;4088);//创建TcpListener对象实例以侦听用户端连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch&nbsp;(&nbsp;Exception&nbsp;e){&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;TcpListener错误：&quot;&#43;e.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;随后，你需要调用Start方法启动侦听：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;void&nbsp;Start();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;其次，当侦听到有用户端连接时，需要接受挂起的连接请求，这通过调用以下两方法之一来完成连接：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;Socket&nbsp;AcceptSocket();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;public&nbsp;TcpClient&nbsp;AcceptTcpClient();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;前一个方法返回代表客户端的Socket对象，随后可以通过Socket&nbsp;类的&nbsp;Send&nbsp;和&nbsp;Receive&nbsp;方法与远程计算机通讯；后一个方法返回代表客户端的TcpClient对象，随后使用上面介绍的&nbsp;TcpClient.GetStream&nbsp;方法获取&nbsp;TcpClient&nbsp;的基础网络流&nbsp;NetworkStream，并使用流读写Read/Write方法与远程计算机通讯。&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;最后，请记住关闭侦听器：public&nbsp;void&nbsp;Stop();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;同时关闭其他连接实例：public&nbsp;void&nbsp;Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;下面的示例完整体现了上面的过程：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;bool&nbsp;done&nbsp;=&nbsp;false;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;TcpListener&nbsp;listener&nbsp;=&nbsp;new&nbsp;TcpListener(13);//&nbsp;创建TcpListener对象实例(13号端口提供时间服务)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;listener.Start();//启动侦听&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;while&nbsp;(!done)&nbsp;{//进入无限循环以侦听用户连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;TcpClient&nbsp;client&nbsp;=&nbsp;listener.AcceptTcpClient();//侦听到连接后创建客户端连接TcpClient&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;NetworkStream&nbsp;ns&nbsp;=&nbsp;client.GetStream();//得到网络传输流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;byte[]&nbsp;byteTime&nbsp;=&nbsp;Encoding.ASCII.GetBytes(DateTime.Now.ToString());//预发送的内容(此为服务端时间)转换为字节数组以便写入流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;ns.Write(byteTime,&nbsp;0,&nbsp;byteTime.Length);//写入流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;ns.Close();//关闭流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;client.Close();//关闭客户端连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;流错误:&quot;&#43;e.Message)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合运用上面的知识，下面的实例实现了简单的网络通讯-双机互连，针对客户端和服务端分别编制了应用程序。客户端创建到服务端的连接，向远程主机发送连接请求连接信号，并发送交谈内容；远程主机端接收来自客户的连接，向客户端发回确认连接的信号，同时接收并显示客户端的交谈内容。在这个基础上，发挥你的创造力，你完全可以开发出一个基于程序语言(C#)级的聊天室！&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;客户端主要源代码：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;SendMeg()//发送信息&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;int&nbsp;port=Int32.Parse(textBox3.Text.ToString());//远程主机端口&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;tcpClient=new&nbsp;TcpClient(textBox1.Text,port);//创建TcpClient对象实例&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;le)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;TcpClient&nbsp;Error:&quot;&#43;le.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;string&nbsp;strDateLine=DateTime.Now.ToShortDateString()&#43;&quot;&nbsp;&quot;&#43;DateTime.Now.ToLongTimeString();//得到发送时客户端时间&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;netStream=tcpClient.GetStream();//得到网络流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;sw=new&nbsp;StreamWriter(netStream);//创建TextWriter,向流中写字符&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;words=textBox4.Text;//待发送的话&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;content=strDateLine&#43;words;//待发送内容&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;sw.Write(content);//写入流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;sw.Close();//关闭流写入器&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;netStream.Close();//关闭网络流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;tcpClient.Close();//关闭客户端连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;catch(Exception&nbsp;ex)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;Sending&nbsp;Message&nbsp;Failed!&quot;&#43;ex.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;textBox4.Text=&quot;&quot;;//清空&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;服务器端主要源代码：&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;StartListen()//侦听特定端口的用户请求&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//ReceiveMeg();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;isLinked=false;&nbsp;//连接标志&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;int&nbsp;port=Int32.Parse(textBox1.Text.ToString());//本地待侦听端口&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;serverListener=new&nbsp;TcpListener(port);//创建TcpListener对象实例&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;serverListener.Start();&nbsp;//启动侦听&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;ex)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;Can‘t&nbsp;Start&nbsp;Server&quot;&#43;ex.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;return;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;isLinked=true;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;while(true)//进入无限循环等待用户端连接&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;try&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;tcpClient=serverListener.AcceptTcpClient();//创建客户端连接对象&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;netStream=tcpClient.GetStream();//得到网络流&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;sr=new&nbsp;StreamReader(netStream);//流读写器&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;re)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;MessageBox.Show(re.Message);&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;string&nbsp;buffer=&quot;&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;string&nbsp;received=&quot;&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;received&#43;=sr.ReadLine();//读流中一行&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;while(received.Length!=0)&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;{&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;buffer&#43;=received;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;buffer&#43;=&quot;\r\n&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;//received=&quot;&quot;;&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;received=sr.ReadLine();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;listBox1.Items.Add(buffer);//显示&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;//关闭&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;sr.Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;netStream.Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;tcpClient.Close();&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;<br style="margin:0px; padding:0px">
&nbsp;&nbsp;}&nbsp;&nbsp;<br style="margin:0px; padding:0px">
</div>
<div id="MySignature" style="margin:0px; padding:0px"></div>
<div class="clear" style="margin:0px; padding:0px; clear:both"></div>
<div id="blog_post_info_block" style="margin:20px 0px 0px; padding:0px">
<div id="blog_post_info" style="margin:0px; padding:0px">
<div id="BlogPostCategory" style="margin:0px 0px 10px; padding:0px"></div>
<div id="EntryTag" style="margin:20px 0px 0px; padding:0px; font-size:9pt; color:rgb(102,102,102)">
</div>
<div id="green_channel" style="margin:10px 0px 0px; padding:10px 5px; border:1px dashed silver; font-size:9pt; width:430px">
<br>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="comment_form" class="commentform" style="margin:0px; padding:0px"><a target="_blank" name="commentform" style="margin:0px; padding:0px; font-family:verdana,'ms song',宋体,Arial,微软雅黑,Helvetica,sans-serif"></a><span style="font-family:verdana,'ms song',宋体,Arial,微软雅黑,Helvetica,sans-serif"></span>
<div id="divCommentShow" style="margin:0px; padding:0px; font-family:verdana,'ms song',宋体,Arial,微软雅黑,Helvetica,sans-serif">
</div>
</div>

            <div>
                作者：Scalzdp 发表于2014/5/26 20:40:26 <a href="http://blog.csdn.net/scalzdp/article/details/27109549">原文链接</a>
            </div>
            <div>
            阅读：267 评论：0 <a href="http://blog.csdn.net/scalzdp/article/details/27109549#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
</channel>
</rss>
