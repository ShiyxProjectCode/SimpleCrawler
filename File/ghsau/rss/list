<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" title="XSL Formatting" href="/rss.xsl" media="all" ?>
<rss version="2.0">
<channel>
    <title>高爽|Coder </title>
    <image>
    <link>http://blog.csdn.net</link>
    <url>http://static.blog.csdn.net/images/logo.gif</url>
    </image>
    <description>在通向架构师的路上</description>
	<link>http://blog.csdn.net/ghsau</link>
	<language>zh-cn</language>
	<generator>http://blog.csdn.net</generator>
	<ttl>5</ttl>
	<copyright><![CDATA[Copyright &copy; ghsau]]></copyright> 
	<pubDate>2015/9/17 14:30:14</pubDate>
    <item>
        <title><![CDATA[[原]CiscoVPNClient不支持WIN10]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/47682787</link>
        <guid>http://blog.csdn.net/ghsau/article/details/47682787</guid>
        <author>ghsau</author>
        <pubDate>2015/8/15 16:09:09</pubDate>
        <description><![CDATA[
            <p>最近系统由WIN8.1升级到了WIN10，几乎所有软件都不存在兼容问题，唯独CiscoVPNClient不能使用了。幸好找到了替代品Shrew Soft VPNClient，免费，并且支持pcf导入，下载地址：<a href="https://www.shrew.net/download/vpn/vpn-client-2.2.2-release.exe">https://www.shrew.net/download/vpn/vpn-client-2.2.2-release.exe</a>。</p>

<p>安装时选择Standard Edition，不用谢。</p>
            <div>
                作者：ghsau 发表于2015/8/15 16:09:09 <a href="http://blog.csdn.net/ghsau/article/details/47682787">原文链接</a>
            </div>
            <div>
            阅读：815 评论：1 <a href="http://blog.csdn.net/ghsau/article/details/47682787#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Java线程(十一)：Fork/Join-Java并行计算框架]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/46287769</link>
        <guid>http://blog.csdn.net/ghsau/article/details/46287769</guid>
        <author>ghsau</author>
        <pubDate>2015/7/22 21:12:51</pubDate>
        <description><![CDATA[
            <p>并行计算在处处都有大数据的今天已经不是一个新鲜的词汇了，现在已经有单机多核甚至多机集群并行计算，注意，这里说的是并行，而不是并发。严格的将，<strong>并行是指系统内有多个任务同时执行</strong>，而<strong>并发是指系统内有多个任务同时存在</strong>，不同的任务按时间分片的方式切换执行，由于切换的时间很短，给人的感觉好像是在同时执行。 <br>
Java在JDK7之后加入了并行计算的框架Fork/Join，可以解决我们系统中大数据计算的性能问题。Fork/Join采用的是分治法，Fork是将一个大任务拆分成若干个子任务，子任务分别去计算，而Join是获取到子任务的计算结果，然后合并，这个是递归的过程。子任务被分配到不同的核上执行时，效率最高。伪代码如下：</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">Result solve(Problem problem) {
    <span class="hljs-keyword">if</span> (problem is small)
        directly solve problem
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">split</span> problem <span class="hljs-keyword">into</span> independent parts
        fork <span class="hljs-built_in">new</span> subtasks <span class="hljs-built_in">to</span> solve <span class="hljs-keyword">each</span> part
        join all subtasks
        compose <span class="hljs-built_in">result</span> <span class="hljs-built_in">from</span> subresults
    }
}</code></pre>

<p>Fork/Join框架的核心类是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，它能够接收一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a>，并得到计算结果。ForkJoinTask有两个子类，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html">RecursiveTask</a>（有返回值）和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html">RecursiveAction</a>（无返回结果），我们自己定义任务时，只需选择这两个类继承即可。类图如下： <br>
<img src="http://img.blog.csdn.net/20150712202533055" alt="这里写图片描述" title=""><img src="http://img.blog.csdn.net/20150712202117816" alt="这里写图片描述" title=""> <br>
下面来看一个实例：计算一个超大数组所有元素的和。代码如下：</p>



<pre class="prettyprint"><code class=" hljs cs">import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

<span class="hljs-comment">/**
 * @author: shuang.gao  Date: 2015/7/14 Time: 8:16
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SumTask extends RecursiveTask&lt;Integer&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">6196480027075657316</span>L;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-keyword">int</span> THRESHOLD = <span class="hljs-number">500000</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] array;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> low;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> high;

    <span class="hljs-keyword">public</span> <span class="hljs-title">SumTask</span>(<span class="hljs-keyword">long</span>[] array, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high) {
        <span class="hljs-keyword">this</span>.array = array;
        <span class="hljs-keyword">this</span>.low = low;
        <span class="hljs-keyword">this</span>.high = high;
    }

    @Override
    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span>() {
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (high - low &lt;= THRESHOLD) {
            <span class="hljs-comment">// 小于阈值则直接计算</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt; high; i++) {
                sum += array[i];
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 1. 一个大任务分割成两个子任务</span>
            <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;
            SumTask left = <span class="hljs-keyword">new</span> SumTask(array, low, mid);
            SumTask right = <span class="hljs-keyword">new</span> SumTask(array, mid + <span class="hljs-number">1</span>, high);

            <span class="hljs-comment">// 2. 分别计算</span>
            left.fork();
            right.fork();

            <span class="hljs-comment">// 3. 合并结果</span>
            sum = left.<span class="hljs-keyword">join</span>() + right.<span class="hljs-keyword">join</span>();
        }
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws ExecutionException, InterruptedException {
        <span class="hljs-keyword">long</span>[] array = genArray(<span class="hljs-number">1000000</span>);

        System.<span class="hljs-keyword">out</span>.println(Arrays.toString(array));

        <span class="hljs-comment">// 1. 创建任务</span>
        SumTask sumTask = <span class="hljs-keyword">new</span> SumTask(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);

        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();

        <span class="hljs-comment">// 2. 创建线程池</span>
        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();

        <span class="hljs-comment">// 3. 提交任务到线程池</span>
        forkJoinPool.submit(sumTask);

        <span class="hljs-comment">// 4. 获取结果</span>
        Integer result = sumTask.<span class="hljs-keyword">get</span>();

        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();

        System.<span class="hljs-keyword">out</span>.println(String.format(<span class="hljs-string">"结果 %s 耗时 %sms"</span>, result, end - begin));
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span>[] <span class="hljs-title">genArray</span>(<span class="hljs-keyword">int</span> size) {
        <span class="hljs-keyword">long</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[size];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
            array[i] = <span class="hljs-keyword">new</span> Random().nextLong();
        }
        <span class="hljs-keyword">return</span> array;
    }
}
</code></pre>

<p>我们通过调整阈值（THRESHOLD），可以发现耗时是不一样的。实际应用中，如果需要分割的任务大小是固定的，可以经过测试，得到最佳阈值；如果大小不是固定的，就需要设计一个可伸缩的算法，来动态计算出阈值。如果子任务很多，效率并不一定会高。 <br>
未完待续。。。</p>

<hr>



<h2 id="参考资料">参考资料</h2>

<p><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">http://gee.cs.oswego.edu/dl/papers/fj.pdf</a> <br>
<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a> <br>
<a href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/">https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/</a> <br>
<a href="http://www.ibm.com/developerworks/cn/java/j-jtp11137.html">http://www.ibm.com/developerworks/cn/java/j-jtp11137.html</a></p>

<p>本文来自：<a href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/46287769">http://blog.csdn.net/ghsau/article/details/46287769</a>，转载请注明。</p>
            <div>
                作者：ghsau 发表于2015/7/22 21:12:51 <a href="http://blog.csdn.net/ghsau/article/details/46287769">原文链接</a>
            </div>
            <div>
            阅读：411 评论：2 <a href="http://blog.csdn.net/ghsau/article/details/46287769#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]MySQL从5.5升级到5.6，TIMESTAMP的变化]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/45625841</link>
        <guid>http://blog.csdn.net/ghsau/article/details/45625841</guid>
        <author>ghsau</author>
        <pubDate>2015/5/10 23:47:32</pubDate>
        <description><![CDATA[
            <h1 id="前言">前言</h1>

<p>前段时间，系统MySQL从5.5升级到了5.6，系统出现了大量的异常。大部分异常引起原因是由于TIMESTAMP的行为发生了变化。</p>



<h1 id="timestamp在mysql55中的行为">TIMESTAMP在MySQL5.5中的行为</h1>

<ul>
<li>第一个未设置默认值的TIMESTAMP NOT NULL字段隐式默认值： <br>
CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</li>
<li>后面未设置默认值的TIMESTAMP NOT NULL字段隐式默认值： <br>
0000-00-00 00:00:00</li>
<li>TIMESTAMP NOT NULL字段插入NULL时，会使用隐式默认值： <br>
CURRENT_TIMESTAMP</li>
<li>不支持多个CURRENT_TIMESTAMP 默认值</li>
</ul>



<h1 id="timestamp在mysql56中的行为">TIMESTAMP在MySQL5.6中的行为</h1>

<ul>
<li>支持多个CURRENT_TIMESTAMP 默认值</li>
<li>可以兼容5.5的行为，支持隐性默认值 <br>
<ul><li>explicit_defaults_for_timestamp=0</li>
<li>我测试安装的MySQL5.6默认使用这个参数，启动时，服务器会给出一个警告。 <br>
[Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use –explicit_defaults_for_timestamp server option (see documentation for more details).</li></ul></li>
<li>可以去掉隐性默认值 <br>
<ul><li>explicit_defaults_for_timestamp=1</li></ul></li>
</ul>



<h1 id="总结">总结</h1>

<ul>
<li>MySQL5.5中TIMESTAMP行为是比较诡异的，会造成一些隐含的问题，比如程序中传入了NULL值</li>
<li>MySQL5.6中可以将TIMESTAMP的行为变得正常，但会存在兼容问题</li>
<li>explicit_defaults_for_timestamp参数未来会消失</li>
<li>我们不要过度依赖数据库的特性，这些特性会给应用程序造成掣肘</li>
</ul>

<hr>

<p>参考：<a href="http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp">http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp</a> <br>
本文来自：<a href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/45625841">http://blog.csdn.net/ghsau/article/details/45625841</a>，转载请注明。</p>
            <div>
                作者：ghsau 发表于2015/5/10 23:47:32 <a href="http://blog.csdn.net/ghsau/article/details/45625841">原文链接</a>
            </div>
            <div>
            阅读：830 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/45625841#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[译]Nested-Loop Join Algorithms]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/43762027</link>
        <guid>http://blog.csdn.net/ghsau/article/details/43762027</guid>
        <author>ghsau</author>
        <pubDate>2015/3/6 14:16:43</pubDate>
        <description><![CDATA[
            <p>MySQL使用嵌套循环算法来实现多表之间的联接。</p>



<h2 id="nested-loop-join-algorithms">Nested-Loop Join Algorithms</h2>

<p>一个简单的嵌套循环联接（NLJ）算法，循环从第一个表中依次读取行，取到每行再到联接的下一个表中循环匹配。这个过程会重复多次直到剩余的表都被联接了。 <br>
假设表t1、t2、t3用下面的联接类型进行联接：</p>

<pre><code>Table   Join Type
t1      range
t2      ref
t3      ALL
</code></pre>

<p>如果使用的是简单NLJ算法，那么联接的过程像这样：</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">for</span> each row in t1 matching range {
  <span class="hljs-keyword">for</span> each row in t2 matching reference key {
    <span class="hljs-keyword">for</span> each row in t3 {
      <span class="hljs-keyword">if</span> row satisfies join conditions,
          send to client
    }
  }
}</code></pre>

<p>因为NLJ算法是通过外循环的行去匹配内循环的行，所以内循环的表会被扫描多次。</p>



<h2 id="block-nested-loop-join-algorithm">Block Nested-Loop Join Algorithm</h2>

<p>一个块嵌套循环联接（BNL）算法，将外循环的行缓存起来，读取缓存中的行，减少内循环的表被扫描的次数。例如，如果10行读入缓冲区并且缓冲区传递给下一个内循环，在内循环读到的每行可以和缓冲区的10行做比较。这样使内循环表被扫描的次数减少了一个数量级。 <br>
MySQL使用联接缓冲区时，会遵循下面这些原则：</p>

<ul>
<li><p>join_buffer_size系统变量的值决定了每个联接缓冲区的大小。</p></li>
<li><p>联接类型为ALL、index、range时（换句话说，联接的过程会扫描索引或数据时），MySQL会使用联接缓冲区。</p></li>
<li><p>缓冲区是分配给每一个能被缓冲的联接，所以一个查询可能会使用多个联接缓冲区。</p></li>
<li><p>联接缓冲区永远不会分配给第一个表，即使该表的查询类型为ALL或index。</p></li>
<li><p>联接缓冲区联接之前分配，查询完成之后释放。</p></li>
<li><p>使用到的列才会放到联接缓冲区中，并不是所有的列。</p></li>
</ul>

<p>上面的例子使用的是NLJ算法（没有使用缓存），使用缓存的联接方式像下面这样：</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">for</span> each row in t1 matching range {
  <span class="hljs-keyword">for</span> each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    <span class="hljs-keyword">if</span> buffer is full {
      <span class="hljs-keyword">for</span> each row in t3 {
        <span class="hljs-keyword">for</span> each t1, t2 combination in join buffer {
          <span class="hljs-keyword">if</span> row satisfies join conditions,
          send to client
        }
      }
      empty buffer
    }
  }
}

<span class="hljs-keyword">if</span> buffer is not empty {
  <span class="hljs-keyword">for</span> each row in t3 {
    <span class="hljs-keyword">for</span> each t1, t2 combination in join buffer {
      <span class="hljs-keyword">if</span> row satisfies join conditions,
      send to client
    }
  }
}</code></pre>

<p>对上面的过程解释如下： <br>
1. 将t1、t2的联接结果放到缓冲区，直到缓冲区满为止； <br>
2. 遍历t3，内部再循环缓冲区，并找到匹配的行，发送到客户端； <br>
3. 清空缓冲区； <br>
4. 重复上面步骤，直至缓冲区不满； <br>
5. 处理缓冲区中剩余的数据，重复步骤2。</p>

<p>设S是每次存储t1、t2组合的大小，C是组合的数量，则t3被扫描的次数为：</p>

<pre><code>(S * C)/join_buffer_size + 1
</code></pre>

<p>由此可见，随着join_buffer_size的增大，t3被扫描的次数会较少，如果join_buffer_size足够大，大到可以容纳所有t1和t2联接产生的数据，t3只会被扫描1次。</p>

<hr>

<p>英文地址：<a href="http://dev.mysql.com/doc/refman/5.5/en/nested-loop-joins.html">http://dev.mysql.com/doc/refman/5.5/en/nested-loop-joins.html</a> <br>
本文来自：<a href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/43762027">http://blog.csdn.net/ghsau/article/details/43762027</a>，转载请注明。</p>
            <div>
                作者：ghsau 发表于2015/3/6 14:16:43 <a href="http://blog.csdn.net/ghsau/article/details/43762027">原文链接</a>
            </div>
            <div>
            阅读：622 评论：2 <a href="http://blog.csdn.net/ghsau/article/details/43762027#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Collections.sort in JDK6：MergeSort]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/42060651</link>
        <guid>http://blog.csdn.net/ghsau/article/details/42060651</guid>
        <author>ghsau</author>
        <pubDate>2015/1/2 14:01:41</pubDate>
        <description><![CDATA[
            &nbsp; &nbsp; &nbsp; &nbsp;本文是对JDK6中Collections.sort方法的源码解析，也可以看作是对<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365">Comparison method violates its general contract!</a>的后续分析。在JDK6中，该方法底层使用的是经过优化后的归并排序，废话不多说，直接看源码。<pre code_snippet_id="557965" snippet_file_name="blog_20150102_1_9385691"  name="code" class="java">public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
	Object[] a = list.toArray();
	Arrays.sort(a, (Comparator)c);
	ListIterator i = list.listIterator();
	for (int j=0; j&lt;a.length; j++) {
	    i.next();
	    i.set(a[j]);
	}
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;将list转成数组，然后调用Arrays.sort方法排序，最后将排好顺序的值覆盖到原list上。<pre code_snippet_id="557965" snippet_file_name="blog_20141221_2_1089324"  code_snippet_id="557965" snippet_file_name="blog_20141221_2_1089324" name="code" class="java">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
	T[] aux = (T[])a.clone();
	if (c==null)
		mergeSort(aux, a, 0, a.length, 0);
	else
		mergeSort(aux, a, 0, a.length, 0, c);
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;克隆一个数组，如果比较器为空，<span style="background-color: rgb(204, 204, 204);">mergeSort(aux, a, 0, a.length, 0);</span>如果比较器不为空，<span style="background-color: rgb(204, 204, 204);">mergeSort(aux, a, 0, a.length, 0, c);</span>二者内部算法实现一致，只是比较元素的方法不一样。下面来看归并排序的实现，看其是如何优化的。<pre code_snippet_id="557965" snippet_file_name="blog_20141221_3_202719"  code_snippet_id="557965" snippet_file_name="blog_20141221_3_202719" name="code" class="java">private static void mergeSort(Object[] src,
				  Object[] dest,
				  int low, int high, int off,
				  Comparator c) {
	int length = high - low;

	// Insertion sort on smallest arrays
	if (length &lt; INSERTIONSORT_THRESHOLD) {
	    for (int i=low; i&lt;high; i++)
			for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
				swap(dest, j, j-1);
	    return;
	}

	// Recursively sort halves of dest into src
	int destLow  = low;
	int destHigh = high;
	low  += off;
	high += off;
	int mid = (low + high) &gt;&gt;&gt; 1;
	mergeSort(dest, src, low, mid, -off, c);
	mergeSort(dest, src, mid, high, -off, c);

	// If list is already sorted, just copy from src to dest.  This is an
	// optimization that results in faster sorts for nearly ordered lists.
	if (c.compare(src[mid-1], src[mid]) &lt;= 0) {
	   System.arraycopy(src, low, dest, destLow, length);
	   return;
	}

	// Merge sorted halves (now in src) into dest
	for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
		if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)
			dest[i] = src[p++];
		else
			dest[i] = src[q++];
	}
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;我们分段来看。<pre code_snippet_id="557965" snippet_file_name="blog_20141221_4_3036243"  code_snippet_id="557965" snippet_file_name="blog_20141221_4_3036243" name="code" class="java">int length = high - low;

// Insertion sort on smallest arrays
if (length &lt; INSERTIONSORT_THRESHOLD) {
	for (int i=low; i&lt;high; i++)
		for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
			swap(dest, j, j-1);
	return;
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;这里有一个常量INSERTIONSORT_THRESHOLD。<pre code_snippet_id="557965" snippet_file_name="blog_20141221_5_7788595"  code_snippet_id="557965" snippet_file_name="blog_20141221_5_7788595" name="code" class="java">/**
 * Tuning parameter: list size at or below which insertion sort will be
 * used in preference to mergesort or quicksort.
 */
private static final int INSERTIONSORT_THRESHOLD = 7;</pre>&nbsp; &nbsp; &nbsp; &nbsp;当数组长度&lt;7时，这里使用了直接插入排序。直接插入排序的过程可以看<a target=_blank target="_blank" href="http://v.youku.com/v_show/id_XMjU4NTY5MzEy.html">这个视频</a>，插入排序适用于小数列的排序。<strong>这里是JDK6中归并排序的第一个优化</strong>。<pre code_snippet_id="557965" snippet_file_name="blog_20150102_6_4063393"  name="code" class="java">// Recursively sort halves of dest into src
int destLow  = low;
int destHigh = high;
low  += off;
high += off;
int mid = (low + high) &gt;&gt;&gt; 1;// 中间索引，相当于(low + high) / 2
mergeSort(dest, src, low, mid, -off, c);// 排序左边
mergeSort(dest, src, mid, high, -off, c);// 排序右边</pre>&nbsp; &nbsp; &nbsp; &nbsp;这里开始递归排序，我们不需要关注off变量，这个变量是排序数组中部分区域的时候使用的，而我们要排序的是整个数组。<pre code_snippet_id="557965" snippet_file_name="blog_20150102_7_8165206"  name="code" class="java">// If list is already sorted, just copy from src to dest.  This is an
// optimization that results in faster sorts for nearly ordered lists.
if (c.compare(src[mid-1], src[mid]) &lt;= 0) {
   System.arraycopy(src, low, dest, destLow, length);
   return;
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;左边和右边排好序之后，开始合并。这时src[low ~ mid - 1]和src[mid ~ high - 1]都是有序的，这时比较src[mid - 1]和src[mid]，如果前者比后者小，那么皆大欢喜，真个src数组就是有序的了，只需将其复制到目标数组后，就完成了排序，不过这种碰运气的几率会比较小。<strong>这里是JDK6中归并排序的第二个优化</strong>。<pre code_snippet_id="557965" snippet_file_name="blog_20150102_8_9476139"  name="code" class="java">// Merge sorted halves (now in src) into dest
for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
	if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)
		dest[i] = src[p++];
	else
		dest[i] = src[q++];
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;程序执行到这里，进行传统的合并操作。其过程如下图：<br />&nbsp; &nbsp; &nbsp; &nbsp;初始状态：<br />&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20150102134837552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br />&nbsp; &nbsp; &nbsp; &nbsp;循环一次后：<br />&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20150102134841935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br />&nbsp; &nbsp; &nbsp; &nbsp;每次都比较src[p]和src[q]，将较小的元素存储到dest[i]，不断的循环比较，直至整个数组都有序。<br /><p>&nbsp; &nbsp; &nbsp; &nbsp;最终：<br />&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20150102135549610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><div>&nbsp; &nbsp; &nbsp; JDK6中的排序是基于传统的归并排序做了部分优化，这两个优化都很简单，实际上效率并未提高多少。所以在JDK7中将其替换为TimSort，下回分解。</div><div>&nbsp; &nbsp; &nbsp; （完）</div><div>&nbsp; &nbsp; &nbsp; 本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/42060651">http://blog.csdn.net/ghsau/article/details/42060651</a>，转载请注明。</div></p>
            <div>
                作者：ghsau 发表于2015/1/2 14:01:41 <a href="http://blog.csdn.net/ghsau/article/details/42060651">原文链接</a>
            </div>
            <div>
            阅读：872 评论：1 <a href="http://blog.csdn.net/ghsau/article/details/42060651#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Comparison method violates its general contract!]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/42012365</link>
        <guid>http://blog.csdn.net/ghsau/article/details/42012365</guid>
        <author>ghsau</author>
        <pubDate>2014/12/18 23:08:42</pubDate>
        <description><![CDATA[
            <h1>背景</h1><p>16号为了统一线上服务器运行环境，将两台服务器的Tomcat6+JDK6升级到Tomcat7+JDK7，本以为很简单的事情，升级后自己验证也没问题，没想到却悲剧了。升级后，过了半小时运营就找过来反馈问题，部分角色无法登陆系统，由于异常日志没有输出，没有找到问题，无奈回滚。今天我们就来说说JDK6升级到JDK7会遇到的坑。本文为了方便搜索，就直接以异常信息作为文章标题了。</p><h1>复现</h1><p>回滚后，到beta环境按照线上的权限配置，复现该问题，加上了error日志输出，输出了文章标题的异常，这个异常是在类似如下代码中抛出的：</p><pre code_snippet_id="556305" snippet_file_name="blog_20141218_1_6261096"  code_snippet_id="556305" snippet_file_name="blog_20141218_1_6261096" name="code" class="java">Collections.sort(list, new Comparator&lt;Integer&gt;() {
	@Override
	public int compare(Integer o1, Integer o2) {
		return o1 &gt; o2 ? 1 : -1;// 错误的方式
	}
});</pre><h1>解决方案</h1><p></p><p>先说如何解决，解决方式有两种。</p><h2>修改代码</h2><p>上面代码写的本身就有问题，第4行没有考虑o1 == o2的情况，再者说我们不需要自己去比较，修改为如下代码即可：</p><pre code_snippet_id="556305" snippet_file_name="blog_20141218_2_1651150"  code_snippet_id="556305" snippet_file_name="blog_20141218_2_1651150" name="code" class="java">Collections.sort(list, new Comparator&lt;Integer&gt;() {
	@Override
	public int compare(Integer o1, Integer o2) {
		// return o1 &gt; o2 ? 1 : -1;
		return o1.compareTo(o2);// 正确的方式
	}
});</pre><h2>不修改代码</h2><p></p><p>那么问题来了。为什么上面代码在JDK6中运行无问题，而在JDK7中却会抛异常呢？这是因为JDK7底层的排序算法换了，如果要继续使用JDK6的排序算法，可以在JVM的启动参数中加入如下参数：</p><pre code_snippet_id="556305" snippet_file_name="blog_20141218_3_3700490"  code_snippet_id="556305" snippet_file_name="blog_20141218_3_3700490" name="code" class="plain">-Djava.util.Arrays.useLegacyMergeSort=true</pre>这样就会照旧使用JDK6的排序算法，在不能修改代码的情况下，解决这个兼容的问题。<p></p><h1>分析</h1><p>在我以前的认知中，高版本的JDK是可以兼容之前的代码的，与同事讨论了一番另加搜索了一番，事实证明，JDK6到JDK7确实存在兼容问题（<a target=_blank target="_blank" href="http://www.oracle.com/technetwork/java/javase/compatibility-417013.html#incompatibilities">不兼容列表</a>）。在不兼容列表中我们可以找到关于Collections.sort的不兼容说明，如下：</p><pre code_snippet_id="556305" snippet_file_name="blog_20141218_4_3765747"  code_snippet_id="556305" snippet_file_name="blog_20141218_4_3765747" name="code" class="plain">Area: API: Utilities
Synopsis: Updated sort behavior for Arrays and Collections may throw an IllegalArgumentException
Description: The sorting algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort has been replaced. 
The new sort implementation may throw an IllegalArgumentException if it detects a Comparable that violates the Comparable contract. 
The previous implementation silently ignored such a situation.
If the previous behavior is desired, you can use the new system property, java.util.Arrays.useLegacyMergeSort, 
to restore previous mergesort behavior.
Nature of Incompatibility: behavioral
RFE: 6804124</pre><p></p>描述的意思是说，java.util.Arrays.sort(java.util.Collections.sort调用的也是此方法)方法中的排序算法在JDK7中已经被替换了。如果违法了比较的约束新的排序算法也许会抛出llegalArgumentException异常。JDK6中的实现则忽略了这种情况。那么比较的约束是什么呢？<a target=_blank target="_blank" href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html#compare(T,%20T)">看这里</a>，大体如下：<br /><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><img src="http://img.blog.csdn.net/20141218224145015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></p></blockquote><p></p><p></p><ul><li>sgn(compare(x, y)) == -sgn(compare(y, x))<br /></li><li>((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0<br /></li><li>compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z</li></ul><div>再回过头来看我们开篇有问题的实现：<pre code_snippet_id="556305" snippet_file_name="blog_20141218_5_6339258"  code_snippet_id="556305" snippet_file_name="blog_20141218_5_6339258" name="code" class="java">return x &gt; y ? 1 : -1;</pre>当x == y时，sgn(compare(x, y)) &nbsp;= -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束，所以在JDK7中抛出了本文标题的异常。</div><h1>结论</h1><div>那么现在是否可以盖棺定论了，按照上面的分析来看，使用这种比较方式（return x &gt; y ? 1 : -1;），只要集合或数组中有相同的元素，就会抛出本文标题的异常。实则不然，什么情况下抛出异常，还取决于JDK7底层排序算法的实现，也就是大名鼎鼎的<a target=_blank target="_blank" href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>。后面文章会分析TimSort。本文给出一个会引发该异常的Case，以便有心人共同研究，如下：<pre code_snippet_id="556305" snippet_file_name="blog_20141218_6_7832974"  code_snippet_id="556305" snippet_file_name="blog_20141218_6_7832974" name="code" class="java">Integer[] array = 
{0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2, 1, 0, 0, 0, 2, 30, 0, 3};</pre></div><div>&nbsp; &nbsp; &nbsp; （完）</div><div>&nbsp; &nbsp; &nbsp; 本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365">http://blog.csdn.net/ghsau/article/details/42012365</a>，转载请注明。</div><p></p>
            <div>
                作者：ghsau 发表于2014/12/18 23:08:42 <a href="http://blog.csdn.net/ghsau/article/details/42012365">原文链接</a>
            </div>
            <div>
            阅读：2879 评论：2 <a href="http://blog.csdn.net/ghsau/article/details/42012365#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[译]Java线程(篇外篇)：线程和锁]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/41350821</link>
        <guid>http://blog.csdn.net/ghsau/article/details/41350821</guid>
        <author>ghsau</author>
        <pubDate>2014/11/22 20:25:32</pubDate>
        <description><![CDATA[
            <h1>前言</h1><p>本文翻译自JLS7(<span style="font-family: arial, sans-serif; color: rgb(221, 75, 57); line-height: 18.2px;">Java Language Specification</span>)第17章，与大家分享。文中的英文还不知道怎么译，持续更新。</p><p>英文原文：<a target=_blank target="_blank" href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html</a>。</p><h1>概述</h1><p><span style="font-size: 32px;">前</span>面章节大部分讨论的是只关心代码在同一时间执行一条语句或表达式的行为，也就是单线程执行，Java虚拟机同时可以支持多个线程执行。多个线程能够独立的执行代码，代码通常会操作共享主内存中的值和对象。多线程可以被多硬件处理器、时间分片单硬件处理器、时间分片多硬件处理器支持。</p><p>Java中线程由Thread类来代表。用户创建线程唯一的方式就是创建该类的对象；每一个线程都与这样的对象关联。当相应Thread对象的start()方法被调用时，一个线程就启动了。</p><p>线程的执行会产生不可预知的行为，尤其是在没有正确同步的情况下。本章描述了多线程程序的语义；它包含了被多线程更新的共享内存的值是否可见的规则。为了规范不同硬件架构中相似的内存模型，这些语义被称为Java程序语言内存模型。当没有争论出现时，我们将这些规则简称为&quot;内存模型&quot;。<br /></p><p>这些语义没有规定多线程程序如何被执行。相反，它们描述了多线程程序能够展现出的行为。产生唯一允许行为的任何一个执行策略都是一个可接受的执行策略。</p><h1>同步(Synchronization)</h1><p>Java程序语言提供了多种机制用于线程通信。这些方法中最基本的就是同步，同步使用监视器实现。Java中每个对象都与一个监视器关联，线程基于某个对象来实现持有锁或者释放锁。同一时间只有一个线程可以持有监视器上的锁。此时，其它线程在尝试持有该监视器上的锁时，都将被阻塞，直到原来的线程释放该监视器上的锁。一个线程t也许会锁定特定的监视器多次; 每次解锁反转一个锁定操作的效果。</p><p>synchronized语句(<a target=_blank target="_blank" href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19">§14.19</a>)使用一个对象的引用作为监视器，在执行其代码块之前，会先尝试对该监视器对象进行锁定操作。锁定操作成功完成后，会进一步执行代码块。如果代码块执行完，包括正常的或者异常的，那么该监视器上的锁会自动的释放。<br /></p><p>synchronized方法(<a target=_blank target="_blank" title="8.4.3.6.&nbsp;synchronized Methods" class="xref" href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.6" style="line-height: 16.8px;">§8.4.3.6</a>)被调用时，会自动进行锁定操作；直到锁定操作成功的完成，方法体才被执行。如果该方法是一个非静态方法，监视器对象是该方法所在类的一个实例。如果该方法是一个静态方法，监视器对象是该方法所在类的Class对象。如果方法体执行完，包括正常的或者异常的，那么该监视器上的锁会自动的释放。<br /></p><p>Java程序语言既不阻止也不需要检测死锁条件。当多线程程序直接或间接的持有多个对象上的锁时应该使用常规的技术来避免死锁问题，如果必要的话，创建更高级别的不会死锁的锁定原语。</p><p>还有其它的机制，如volatile变量的读写和使用java.util.concurrent包中的类，提供了同步的替代方法。</p><h1>等待集合和通知(Wait Sets and Notification)</h1><p>每一个对象，除了有关联的监视器，还有一个关联的等待集合。等待集合中存储的是线程。</p><p>当一个对象被创建时，它的等待集合是空的。等待集合中线程的增加和删除这两个基本操作是原子的。对等待集合的操作只有通过Object.wait、Object.notify、Object.notifyAll三个方法。</p><p>等待集合操作也可以被线程的中断状态、线程类处理中断的方法所影响。另外，线程类的睡眠和合并方法拥有那些等待和通知操作的衍生属性。</p><h2>等待(Wait)</h2><p>wait()或带时间参数的wait(long millisecs)和wait(long millisecs, int nanosecs)被调用时会触发等待操作。<br /><em>调用wait(0)或wait(0, 0)是和wait()等价的。</em></p><p>一个线程从等待中正常返回如果它没有抛出InterruptedException。</p><p>设线程t为执行m对象wait方法的线程，and let n be the number of lock actions by t on m that have not been matched by unlock actions。则会发生下面这些情况之一：</p><ul><li>如果n=0(也就是线程t已经不再持有对象m的锁)，将会抛出IllegalMonitorStateException。</li><li>如果是带时间参数的wait方法，并且nanosecs参数不在0-999999范围内或者millisecs是负数，将会抛出IllegalArgumentException。</li><li>如果线程t被中断，将会抛出InterruptedException并且线程t的中断状态设为false。</li><li>否则，以下情况会顺序发生：</li><ol><li>线程t被添加到m对象的等待集合中，并释放m上的锁。</li><li>线程t直到从对象m的等待集合中移除后，才会执行后面的代码。直到下列的情况发生任意一种时，线程才会从等待队列中移除，并重新进行线程调度：</li><ul><li>其他某个线程调用对象m的 notify 方法，并且线程t碰巧被任选为被唤醒的线程。</li><li>其他某个线程调用对象m的&nbsp;<tt>notifyAll</tt>&nbsp;方法。</li><li>其他某个线程中断了线程t。<br /></li><li>如果是带时间参数的wait方法，从wait操作时间开始，millisecs毫秒数+nanosecs纳秒数指定的超时时间已用完。</li><li>虚假唤醒(spurious wake-ups)。<em>为了防止虚假唤醒，wait操作必须放在循环中。</em></li></ul><p>每个线程对于能引起它从等待集合中移除的事件都必须有一个确定的执行顺序。该顺序不必与其它的排序相一致，但是该线程必须表现得好像这些事件是按照这个顺序发生的。</p><p>例如，假设一个线程t在对象m的等待集合中，线程t的中断和对象m的通知两个事件同时发生，那么这两个事件必须有一个执行顺序。如果中断事件先执行，线程t会抛出一个InterruptedException并从等待中退出，并且对象m的等待集合中的其它线程会接收到通知。如果通知事件先执行，线程t从等待中正常退出，中断事件被挂起。</p><li>线程t在m上执行锁操作。</li><li>如果线程t是在第2部的时候从m的等待集合中移除，t的中断状态设置为false并且wait方法抛出InterruptedException。</li></ol></ul><h2>通知(Notification)</h2><p>notify和notifyAll被调用时会触发通知操作。</p><p>设线程t为执行m对象通知方法的线程，and let n be the number of lock actions by t on m that have not been matched by unlock actions。则会发生下面这些情况之一：<br /></p><p></p><ul><li>如果n=0，将会抛出IllegalMonitorStateException。这是线程t已经不再持有对象m的锁的情况。</li><li>如果n&gt;0并且这是一个notify操作，如果m的等待集合非空，m的等待集合中一个线程u被选中，从等待集合中移除。等待集合中哪一个线程被选中是没有规则的。从等待集合中移除使u从等待状态恢复。然而，在u恢复后，直到线程t释放了在监视器的所之后，u才能持有锁。</li><li>如果n&gt;0并且这是一个notifyAll操作，所有的线程都会从m的等待集合中移除，重新开始竞争。然而，恢复后，它们之中只有一个会持有监视器的锁。</li></ul><h2>中断(Interruptions)</h2><p>Thread.interrupt、ThreadGroup.interrupt被调用时会触发中断操作。</p><p>设t为执行u.interrupt的线程，该操作会将线程u的中断状态设为true。</p><p>另外，如果m的等待集合中包含u，u会被移出。This enables u to resume in a wait action, in which case this wait will, after re-locking m's monitor, throw InterruptedException。</p><p>调用Thread.isInterrupted能确定一个线程的中断状态。静态方法Thread.interrupted也许会被一个守护线程调用，并清除它自己的中断状态。</p><h2>等待、通知、中断的相互影响(Interactions of Waits, Notification, and Interruption)</h2><p>待译。</p><h1>睡眠和让步(Sleep and Yield)</h1><p>﻿﻿待译。</p>
            <div>
                作者：ghsau 发表于2014/11/22 20:25:32 <a href="http://blog.csdn.net/ghsau/article/details/41350821">原文链接</a>
            </div>
            <div>
            阅读：1480 评论：2 <a href="http://blog.csdn.net/ghsau/article/details/41350821#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Java线程(十)：CAS]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/38471987</link>
        <guid>http://blog.csdn.net/ghsau/article/details/38471987</guid>
        <author>ghsau</author>
        <pubDate>2014/8/18 21:54:37</pubDate>
        <description><![CDATA[
            <h1>前言</h1><p>&nbsp; &nbsp; &nbsp; &nbsp;在Java并发包中有这样一个包，java.util.concurrent.atomic，该包是对Java部分数据类型的原子封装，在原有数据类型的基础上，提供了原子性的操作方法，保证了线程安全。下面以AtomicInteger为例，来看一下是如何实现的。</p><pre code_snippet_id="447205" snippet_file_name="blog_20140810_1_9664284" name="code" class="java">public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}</pre><pre code_snippet_id="447205" snippet_file_name="blog_20140810_2_6568168" name="code" class="java">public final int decrementAndGet() {
    for (;;) {
        int current = get();
        int next = current - 1;
        if (compareAndSet(current, next))
            return next;
    }
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;以这两个方法为例，incrementAndGet方法相当于原子性的++i，decrementAndGet方法相当于原子性的--i（根据<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/7421217">第一章</a>和<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/7424694">第二章</a>我们知道++i或--i不是一个原子性的操作），这两个方法中都没有使用阻塞式的方式来保证原子性（如Synchronized），那它们是如何保证原子性的呢，下面引出CAS。</p><h1>Compare And Swap</h1><p>&nbsp; &nbsp; &nbsp; &nbsp;CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。（这段描述引自《Java并发编程实践》）<br />&nbsp; &nbsp; &nbsp; &nbsp;简单的来说，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。<strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V</strong>。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</p><h2>volatile变量</h2><div><pre code_snippet_id="447205" snippet_file_name="blog_20140818_3_8367963" name="code" class="java">private volatile int value;</pre>&nbsp; &nbsp; &nbsp; &nbsp;首先声明了一个volatile变量value，在<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/7424694">第二章</a>我们知道volatile保证了变量的内存可见性，也就是所有工作线程中同一时刻都可以得到一致的值。<pre code_snippet_id="447205" snippet_file_name="blog_20140818_4_6944432" name="code" class="java">public final int get() {
    return value;
}</pre></div><h2>Compare And Set</h2><div><pre code_snippet_id="447205" snippet_file_name="blog_20140818_5_296647" name="code" class="java">// setup to use Unsafe.compareAndSwapInt for updates
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;// 注意是静态的

static {
  try {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));// 反射出value属性，获取其在内存中的位置
  } catch (Exception ex) { throw new Error(ex); }
}

public final boolean compareAndSet(int expect, int update) {
  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;比较并设置，这里利用Unsafe类的JNI方法实现，使用CAS指令，可以保证读-改-写是一个原子操作。compareAndSwapInt有4个参数，this - 当前AtomicInteger对象，Offset - value属性在内存中的位置(需要强调的是不是value值在内存中的位置)，expect - 预期值，update - 新值，根据上面的CAS操作过程，当内存中的value值等于expect值时，则将内存中的value值更新为update值，并返回true，否则返回false。在这里我们有必要对Unsafe有一个简单点的认识，从名字上来看，不安全，确实，这个类是用于执行低级别的、不安全操作的方法集合，这个类中的方法大部分是对内存的直接操作，所以不安全，但当我们使用反射、并发包时，都间接的用到了Unsafe。</div><p></p><h2>循环设置</h2><p></p><div>&nbsp; &nbsp; &nbsp; &nbsp;现在在来看开篇提到的两个方法，我们拿incrementAndGet来分析一下其实现过程。</div><div><pre code_snippet_id="447205" snippet_file_name="blog_20140818_6_8873115" name="code" class="java">public final int incrementAndGet() {
    for (;;) {// 这样优于while(true)
        int current = get();// 获取当前值
        int next = current + 1;// 设置更新值
        if (compareAndSet(current, next))
            return next;
    }
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;循环内，获取当前值并设置更新值，调用compareAndSet进行CAS操作，如果成功就返回更新至，否则重试到成功为止。这里可能存在一个隐患，那就是循环时间过长，总是在当前线程compareAndSet时，有另一个线程设置了value(点子太背了)，这个当然是属于小概率时间，目前Java貌似还不能处理这种情况。</div><p></p><h1>缺点</h1><p></p><div>&nbsp; &nbsp; &nbsp; &nbsp;虽然使用CAS可以实现非阻塞式的原子性操作，但是会产生ABA问题，关于ABA问题，计划单拿出一章来整理。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;(完)</div><div>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/38471987">http://blog.csdn.net/ghsau/article/details/38471987</a>，转载请注明。<br /></div>
            <div>
                作者：ghsau 发表于2014/8/18 21:54:37 <a href="http://blog.csdn.net/ghsau/article/details/38471987">原文链接</a>
            </div>
            <div>
            阅读：2881 评论：4 <a href="http://blog.csdn.net/ghsau/article/details/38471987#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Guava Collect]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/27962647</link>
        <guid>http://blog.csdn.net/ghsau/article/details/27962647</guid>
        <author>ghsau</author>
        <pubDate>2014/6/1 17:57:03</pubDate>
        <description><![CDATA[
            
<p></p>
<h2 id="Guava是什么">Guava是什么</h2>
<p>进入新公司就会接触一些新的东东，Guava就是一个，Guava是Google的一个开源类库，丰富了JDK的API，而且使用起来很方便，本文介绍的是Guava collect包下的一些常用工具类。</p>
<p>项目主页：<a target="_blank" target="_blank" href="https://code.google.com/p/guava-libraries/">https://code.google.com/p/guava-libraries/</a></p>
<p>源码下载(GIT)：git clone <a target="_blank" target="_blank" href="https://code.google.com/p/guava-libraries/">
https://code.google.com/p/guava-libraries/</a></p>
<p>Maven依赖：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_1_3473558"  code_snippet_id="372577" snippet_file_name="blog_20140601_1_3473558" name="code" class="html">&lt;groupId&gt;com.google.guava&lt;/groupId&gt;
&lt;artifactId&gt;guava&lt;/artifactId&gt;
&lt;version&gt;17.0&lt;/version&gt;</pre>
<p></p>
<a target="_blank" target="_blank" id="more"></a>
<h2 id="代码演示">代码演示</h2>
<h3 id="List">List</h3>
<p>一般情况下，我们创建一个List集合，使用如下代码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_2_2251276"  code_snippet_id="372577" snippet_file_name="blog_20140601_2_2251276" name="code" class="java">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();
strList.add(&quot;1&quot;);
strList.add(&quot;2&quot;);
strList.add(&quot;3&quot;);</pre>
<p></p>
<p>使用Collections工具类，可以简化：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_3_6046287"  code_snippet_id="372577" snippet_file_name="blog_20140601_3_6046287" name="code" class="java">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();
Collections.addAll(strList, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</pre>
<p></p>
<p>使用Guava，可以进一步简化：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_4_5381195"  code_snippet_id="372577" snippet_file_name="blog_20140601_4_5381195" name="code" class="java">List&lt;String&gt; strList = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</pre>
<p></p>
<p>Lists.newArrayList(“1”, “2”, “3”)其实就是对第二步的一个封装，并且这里使用了Java泛型推断，可以看一下源码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_5_3079901"  code_snippet_id="372577" snippet_file_name="blog_20140601_5_3079901" name="code" class="java">public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList(E... elements) {
    checkNotNull(elements); // for GWT
    // Avoid integer overflow when a large array is passed in
    int capacity = computeArrayListCapacity(elements.length);
    ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;(capacity);
    Collections.addAll(list, elements);
    return list;
}</pre>
<p></p>
<p>JDK7以后，可以去掉实现类中的泛型声明：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_6_778607"  code_snippet_id="372577" snippet_file_name="blog_20140601_6_778607" name="code" class="java">List&lt;String&gt; strList = new ArrayList&lt;&gt;;</pre>
<p></p>
<p>Oracle也意识到了在等号右面又写一遍泛型是件很2的事情，但是依然不如Guava方便。</p>
<h3 id="不可变List">不可变List</h3>
<p>JDK中有两种创建不可变集合的API，且只能包含一个元素，如下代码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_7_2588750"  code_snippet_id="372577" snippet_file_name="blog_20140601_7_2588750" name="code" class="java">List&lt;String&gt; strList = Collections.singletonList(&quot;1&quot;);// 返回一个只包含指定对象的不可变列表
List&lt;String&gt; strList = Collections.emptyList();// 返回空的列表（不可变的）</pre>
<p></p>
<p>但通常我们都需要集合中包含多个元素，这两种API特殊情况下可以用到。</p>
<p>Collections还可以创建一个不可变的<strong>视图</strong>，如下代码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_8_9971810"  code_snippet_id="372577" snippet_file_name="blog_20140601_8_9971810" name="code" class="java">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();
Collections.addAll(strList, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(strList);</pre>
<p></p>
<p>unmodifiableList是通过包装可变strList生成，其内部引用的是同一个对象，虽然unmodifiableList是无法改变了，但是strList依然可以改变，如：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_9_5685649"  code_snippet_id="372577" snippet_file_name="blog_20140601_9_5685649" name="code" class="java">strList.add(&quot;10&quot;);</pre>
<p></p>
<p>unmodifiableList也随之变化，所以说这是创建一个不可变的<strong>视图</strong>。</p>
<p>JDK中还可以创建一种<strong>只能修改，但不能增加和删除</strong>的List，如下代码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_10_5892609"  code_snippet_id="372577" snippet_file_name="blog_20140601_10_5892609" name="code" class="java">String[] strArray = new String[] {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
List&lt;String&gt; strList = Arrays.asList(strArray);</pre>
<p></p>
<p>可以想想，这是由数组决定的特性，这种List实际上就是数组的一个变形，List更方便开发者来使用。</p>
<p>Guava可以创建一个完全不可变的集合，如下代码：</p>
<pre code_snippet_id="372577" snippet_file_name="blog_20140601_11_3275671"  code_snippet_id="372577" snippet_file_name="blog_20140601_11_3275671" name="code" class="java">List&lt;String&gt; strList = ImmutableList.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</pre>
<p></p>
<p>本文只是对Guava Collect的管中窥豹，也仅仅介绍了List部分，更多请移步：<a target="_blank" target="_blank" href="https://code.google.com/p/guava-libraries/wiki/GuavaExplained?tm=6">https://code.google.com/p/guava-libraries/wiki/GuavaExplained?tm=6</a>。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/27962647">http://blog.csdn.net/ghsau/article/details/27962647</a>，转载请注明。<br>
</p>

            <div>
                作者：ghsau 发表于2014/6/1 17:57:03 <a href="http://blog.csdn.net/ghsau/article/details/27962647">原文链接</a>
            </div>
            <div>
            阅读：1927 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/27962647#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]一张有趣的漫画]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/26827133</link>
        <guid>http://blog.csdn.net/ghsau/article/details/26827133</guid>
        <author>ghsau</author>
        <pubDate>2014/5/24 13:36:36</pubDate>
        <description><![CDATA[
            
<img src="http://img.blog.csdn.net/20140524133612781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">

            <div>
                作者：ghsau 发表于2014/5/24 13:36:36 <a href="http://blog.csdn.net/ghsau/article/details/26827133">原文链接</a>
            </div>
            <div>
            阅读：1317 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/26827133#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Eclipse使用]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/24057391</link>
        <guid>http://blog.csdn.net/ghsau/article/details/24057391</guid>
        <author>ghsau</author>
        <pubDate>2014/4/20 17:31:01</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;到了新公司，大家都在用idea，我也有想换的冲动，更换之前，记录下Eclipse常用的配置和快捷键，防止以后忘记。</p>
<h3>下载</h3>
<p>&nbsp; &nbsp; &nbsp; &nbsp;最近发现了一款比较好用的Eclipse，那就是Spring Tool Suite(STS)，STS基于Eclipse做了诸多支持，如GIT、Maven，支持最好的当然是Spring了，下载地址戳<a target="_blank" target="_blank" href="http://spring.io/tools/sts/all">这里</a>。</p>
<h3>配置</h3>
<p>&nbsp; &nbsp; &nbsp; &nbsp;编码：Windows--&gt;Preferences--&gt;General--&gt;Workspace--&gt;Text file encoding</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;字体：Windows--&gt;Preferences--&gt;General--&gt;Appearance--&gt;Colors and Fonts</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;智能提示：Windows--&gt;Preferences--&gt;Java--&gt;Editor--&gt;Content Assist--&gt;Auto activation triggers for Java--&gt;.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@</p>
<h3>快捷键</h3>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;R 快速打开资源</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;T 快速打开类<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;H&nbsp;<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;E 选择一个已经打开的编辑窗口<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;W 关闭所有编辑窗口<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;F 代码&#26684;式化<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;/ 选中加注释</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;\ 选中去掉注释</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Shift&#43;C 选中行加/去掉注释<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Alt&#43;↓ 向下复制一行</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Alt&#43;↑ 向上复制一行<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Q 返回到最后编辑处</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;O 打开大纲视图<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;M 最大/小化<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;E 搜索一个已经打开的编辑窗口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;1 解决问题</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;2&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;N 新建</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;W 关闭当前窗口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;F6 切换编辑窗口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;D 删除行<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Page Up 上一窗口</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Ctrl&#43;Page Down 下一窗口<br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;/ 提示</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;↑ 移到上一行</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;↓ 移到下一行</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;← 上一光标位置</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;→ 下一光标位置&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;Shift&#43;O 高亮变量</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;Shift&#43;R 重命名</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;Shift&#43;M 抽取方法</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;Shift&#43;S&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Alt&#43;Shift&#43;Z</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Shift&#43;Enter 切换到新行</p>

            <div>
                作者：ghsau 发表于2014/4/20 17:31:01 <a href="http://blog.csdn.net/ghsau/article/details/24057391">原文链接</a>
            </div>
            <div>
            阅读：1373 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/24057391#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[译]INSERT ... ON DUPLICATE KEY UPDATE]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/23557915</link>
        <guid>http://blog.csdn.net/ghsau/article/details/23557915</guid>
        <author>ghsau</author>
        <pubDate>2014/4/13 22:05:37</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/23557915">http://blog.csdn.net/ghsau/article/details/23557915</a>，转载请注明。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;向数据库插入记录时，有时会有这种需求，当符合某种条件的数据存在时，去修改它，不存在时，则新增，也就是saveOrUpdate操作。这种控制可以放在业务层，也可以放在数据库层，大多数数据库都支持这种需求，如Oracle的merge语句，再如本文所讲的MySQL中的INSERT ... ON DUPLICATE KEY UPDATE语句。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;该语句是基于唯一索引或主键使用，比如一个字段a被加上了unique index，并且表中已经存在了一条记录值为1，下面两个语句会有相同的效果：</p><pre code_snippet_id="290456" snippet_file_name="blog_20140413_1_4689110"  code_snippet_id="290456" snippet_file_name="blog_20140413_1_4689110" name="code" class="sql">INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=c+1;

UPDATE table SET c=c+1 WHERE a=1;</pre>&nbsp; &nbsp; &nbsp; &nbsp;ON DUPLICATE KEY UPDATE后面可以放多个字段，用英文逗号分割。使用ON DUPLICATE KEY UPDATE，最终如果插入了一个新行，则受影响的行数是1，如果修改了已存在的一行数据，则受影响的行数是2。<br /><p>&nbsp; &nbsp; &nbsp; &nbsp;如果字段b也被加上了unique index，则该语句和下面的update语句是等效的：</p><pre code_snippet_id="290456" snippet_file_name="blog_20140413_2_2813710"  code_snippet_id="290456" snippet_file_name="blog_20140413_2_2813710" name="code" class="sql">UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果a=1 OR b=2匹配了多行，则只有一行会被修改。通常的，在ON DUPLICATE KEY UPDATE语句中，我们应该避免多个唯一索引的情况。如果需要插入或更新多条数据，并且更新的字段需要根据其它字段来运算时，可以使用如下语句：<pre code_snippet_id="290456" snippet_file_name="blog_20140413_3_9160402"  code_snippet_id="290456" snippet_file_name="blog_20140413_3_9160402" name="code" class="sql">INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)
  ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);</pre>&nbsp; &nbsp; &nbsp; &nbsp;在ON DUPLICATE KEY UPDATE后面使用VALUES()方法，这个语句等同于下面的两个语句：<pre code_snippet_id="290456" snippet_file_name="blog_20140413_4_2126789"  code_snippet_id="290456" snippet_file_name="blog_20140413_4_2126789" name="code" class="sql">INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=3;--1+2
INSERT INTO table (a,b,c) VALUES (4,5,6)
  ON DUPLICATE KEY UPDATE c=9;--4+5</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果一个表中包含了一个auto_increment的字段，每次insert数据后，可以通过last_insert_id()方法返回最后自动生成的值，如果通过INSERT ... ON DUPLICATE KEY UPDATE语句修改了一条数据，那么再通过last_insert_id()方法获取的值将不正确，实际测试中是多了一个数，比如向表中增加了3条数据，那么通过last_insert_id()方法得到的值是3，但是通过该语句修改了一条数据后，通过last_insert_id()方法得到的值是4。如果想解决该问题，可以通过如下语句：<pre code_snippet_id="290456" snippet_file_name="blog_20140413_5_9586296"  code_snippet_id="290456" snippet_file_name="blog_20140413_5_9586296" name="code" class="sql">INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE id=LAST_INSERT_ID(id), c=3;</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;重点是这句id=LAST_INSERT_ID(id)。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;英文原文：<a target=_blank target="_blank" href="https://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html</a></p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/23557915">http://blog.csdn.net/ghsau/article/details/23557915</a>，转载请注明。<br />
            <div>
                作者：ghsau 发表于2014/4/13 22:05:37 <a href="http://blog.csdn.net/ghsau/article/details/23557915">原文链接</a>
            </div>
            <div>
            阅读：9306 评论：5 <a href="http://blog.csdn.net/ghsau/article/details/23557915#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Notepad++列编辑、正则查找、替换]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/22507859</link>
        <guid>http://blog.csdn.net/ghsau/article/details/22507859</guid>
        <author>ghsau</author>
        <pubDate>2014/3/29 19:07:06</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/22507859">http://blog.csdn.net/ghsau/article/details/22507859</a>，转载请注明。<br>
<strong>目标</strong>：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;将源数据转成初始化sql语句。<br>
<strong>源数据</strong>：</p>
<pre code_snippet_id="263832" snippet_file_name="blog_20140329_1_4475821"  name="code" class="plain">104110040018,1,中国银行,中国银行天津琼州道支行,NULL,1100,天津市,12,天津市
104110040059,1,中国银行,中国银行天津利民道支行,NULL,1100,天津市,12,天津市
104110040091,1,中国银行,中国银行天津九龙路支行,NULL,1100,天津市,12,天津市
104110040106,1,中国银行,中国银行天津枫林路支行,NULL,1100,天津市,12,天津市
104110040139,1,中国银行,中国银行天津滨湖路支行,NULL,1100,天津市,12,天津市
104110040155,1,中国银行,中国银行天津南楼支行,NULL,1100,天津市,12,天津市
104110045006,1,中国银行,中国银行天津和平支行,NULL,1100,天津市,12,天津市
104110050021,1,中国银行,中国银行天津海洋支行,NULL,1100,天津市,12,天津市
104110050048,1,中国银行,中国银行泰达大街支行,NULL,1100,天津市,12,天津市</pre>
<p><strong>处理列头</strong>：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;将光标定位在第一行数据开始处，按alt&#43;c组合键，弹出列编辑窗口，如图：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20140329183748562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;插入相应文本，确定后，数据变成了下面这样：</p>
<pre code_snippet_id="263832" snippet_file_name="blog_20140329_2_7397996"  name="code" class="plain">insert into t_bank values(104110040018,1,中国银行,中国银行天津琼州道支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110040059,1,中国银行,中国银行天津利民道支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110040091,1,中国银行,中国银行天津九龙路支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110040106,1,中国银行,中国银行天津枫林路支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110040139,1,中国银行,中国银行天津滨湖路支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110040155,1,中国银行,中国银行天津南楼支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110045006,1,中国银行,中国银行天津和平支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110050021,1,中国银行,中国银行天津海洋支行,NULL,1100,天津市,12,天津市
insert into t_bank values(104110050048,1,中国银行,中国银行泰达大街支行,NULL,1100,天津市,12,天津市</pre>
<p><strong>处理列尾</strong>：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;按ctrl&#43;h组合键，弹出替换窗口，如图：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20140329184145937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;windows下，每行都以这两个字符结束，\r使光标移到行首，\n使光标下移一行，注意要将查找模式选择为扩展，全部替换后，数据变成了下面这样：</p>
<pre code_snippet_id="263832" snippet_file_name="blog_20140329_3_5129722"  name="code" class="plain">insert into t_bank values(104110040018,1,中国银行,中国银行天津琼州道支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110040059,1,中国银行,中国银行天津利民道支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110040091,1,中国银行,中国银行天津九龙路支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110040106,1,中国银行,中国银行天津枫林路支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110040139,1,中国银行,中国银行天津滨湖路支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110040155,1,中国银行,中国银行天津南楼支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110045006,1,中国银行,中国银行天津和平支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110050021,1,中国银行,中国银行天津海洋支行,NULL,1100,天津市,12,天津市);
insert into t_bank values(104110050048,1,中国银行,中国银行泰达大街支行,NULL,1100,天津市,12,天津市);</pre><strong>处理文本</strong>：
<p></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;要将中文转换成两端带单引号的，匹配中文需要用正则<strong>[一-龥]&#43;</strong>，这里的问题是我们替换的时候要获取当前匹配的字符串，按ctrl&#43;h组合键，弹出替换窗口，如图：<br>
&nbsp; &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20140329185501875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;使用小括号将匹配的字符串包上，然后替换&#20540;中可以通过$1表达式来获取到当前正在匹配的&#20540;，这里可以更复杂些，比如存在多个小括号，相应的可以使用$1、$2、$3来获取对应&#20540;，全部替换后，就是我们最终想要的数据了。</p>
<pre code_snippet_id="263832" snippet_file_name="blog_20140329_4_5161959"  name="code" class="sql">insert into t_bank values(104110040018,1,'中国银行','中国银行天津琼州道支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110040059,1,'中国银行','中国银行天津利民道支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110040091,1,'中国银行','中国银行天津九龙路支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110040106,1,'中国银行','中国银行天津枫林路支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110040139,1,'中国银行','中国银行天津滨湖路支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110040155,1,'中国银行','中国银行天津南楼支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110045006,1,'中国银行','中国银行天津和平支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110050021,1,'中国银行','中国银行天津海洋支行',NULL,1100,'天津市',12,'天津市');
insert into t_bank values(104110050048,1,'中国银行','中国银行泰达大街支行',NULL,1100,'天津市',12,'天津市');</pre>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/22507859">http://blog.csdn.net/ghsau/article/details/22507859</a>，转载请注明。<br>
<p></p>

            <div>
                作者：ghsau 发表于2014/3/29 19:07:06 <a href="http://blog.csdn.net/ghsau/article/details/22507859">原文链接</a>
            </div>
            <div>
            阅读：3328 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/22507859#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Why hashcode 31?]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/21328203</link>
        <guid>http://blog.csdn.net/ghsau/article/details/21328203</guid>
        <author>ghsau</author>
        <pubDate>2014/3/16 17:22:44</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/21328203">http://blog.csdn.net/ghsau/article/details/21328203</a>，转载请注明。<br />&nbsp; &nbsp; &nbsp; &nbsp;前几天被人问到了hashcode如何实现，说实话，真的是没有自己写过，通常情况下都会通过IDE自动生成，惭愧。今天研究了下hashcode的生成原理，首先看一下String类中的hashCode方法：</p><pre code_snippet_id="238959" snippet_file_name="blog_20140316_1_3558023"  code_snippet_id="238959" snippet_file_name="blog_20140316_1_3558023" name="code" class="java"> public int hashCode() {
        int h = hash;
        if (h == 0 &amp;&amp; value.length &gt; 0) {
            char val[] = value;

            for (int i = 0; i &lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;核心的算法就是中间的for循环，假如字符串是&quot;abcde&quot;，那最终的hash值应该是31(31(31(31a+b) + c) + d) + e，扩号展开为a*31^4+b*31^3+c*31^2+d*31^1+e*31^0，设字符串的长度为n，那最终的计算公式为：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]，这实际上就是31进制数转成10进制数的算法。那为什么要用31作为基数呢？<br />&nbsp; &nbsp; &nbsp; &nbsp;我想可能有几点原因：31首先是一个素数，与素数相乘运算后，能降低hashcode碰撞的概率；31其次是一个特殊的值(32-1)，32的二进制是100000，31的二进制是011111，31*N = N &lt;&lt; 5 - N，运算速度会快。<br />&nbsp; &nbsp; &nbsp; &nbsp;普通类覆盖hashCode方法也可以使用类似的算法，如：</p><pre code_snippet_id="238959" snippet_file_name="blog_20140316_2_3132911"  code_snippet_id="238959" snippet_file_name="blog_20140316_2_3132911" name="code" class="java">@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((firstname == null) ? 0 : firstname.hashCode());
		result = prime * result
				+ ((lastname == null) ? 0 : lastname.hashCode());
		result = prime * result
				+ ((nickname == null) ? 0 : nickname.hashCode());
		return result;
	}</pre>&nbsp; &nbsp; &nbsp; &nbsp;属性如果是引用类型，要与其hashCode运算，属性如果是byte、short、int类型，要与其值运算，属性如果是float、double、long，要经过特殊运算，可以参考对应封装类的hashCode方法实现。<br /><p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/21328203">http://blog.csdn.net/ghsau/article/details/21328203</a>，转载请注明。</p>
            <div>
                作者：ghsau 发表于2014/3/16 17:22:44 <a href="http://blog.csdn.net/ghsau/article/details/21328203">原文链接</a>
            </div>
            <div>
            阅读：1329 评论：1 <a href="http://blog.csdn.net/ghsau/article/details/21328203#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]完全跨域的单点登录]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/20545513</link>
        <guid>http://blog.csdn.net/ghsau/article/details/20545513</guid>
        <author>ghsau</author>
        <pubDate>2014/3/5 16:11:50</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20545513">http://blog.csdn.net/ghsau/article/details/20545513</a>，转载请注明。<br>
&nbsp; &nbsp; &nbsp; &nbsp;完全跨域的单点登录实现方案基本和上篇文章介绍的一样，只不过生成ticket的过程更复杂些。上篇文章中的项目是不能完全跨域的，由于多个应用系统以及认证系统域不同，也没有共同的父域，导致登录后，认证系统向浏览器写的ticket在其它应用系统中获取不到，这时访问其它应用系统时，没有携带着ticket的cookie，无法认证也无法单点登录。那解决的方案是每个应用系统都向浏览器cookie中写入ticket，请看下图，图中浅蓝色圆角区域代表不同的域，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="background-color:rgb(255,255,255)"><span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明[认证系统_ticket]；这时再通过浏览器将[认证系统_ticket]发送到到应用系统1的设置cookie的url，应用系统1返回给浏览器一个证明[应用系统1_ticket]，这时再将请求重定向到最初访问的页面，以后应用系统1就可以自动登录了。现在用户访问了应用系统2，由于应用系统2没有生成过cookie（但是用户已经在应用系统1登录过一次了），将请求重定向到认证系统；认证系统检测到已经生成过[认证系统_ticket]了，认证通过；再通过浏览器将[认证系统_ticket]发送到到应用系统2的设置cookie的url，应用系统2返回给浏览器一个证明[应用系统2_ticket]，这时再将请求重定向到最初访问的页面。应用系统3也同样原理，我们等于将ticket做了一次同步，保证了每个应用系统都有一份认证系统产生的ticket。剩余的ticket验证过程和上篇文章一样了。</span></span><img src="http://img.blog.csdn.net/20140305150846046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ticket同步的过程用jsonp应该也可以实现，我基于上篇文章中的项目实现了完全跨域的单点登录，可以在<a target="_blank" href="http://download.csdn.net/detail/ghsau/6995969" target="_blank">这里</a>下载项目。</p>
<p><strong>域名准备</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>修改hosts文件，映射3个域名：</p>
<pre code_snippet_id="218843" snippet_file_name="blog_20140305_1_6385560"  code_snippet_id="218843" snippet_file_name="blog_20140305_1_6385560" name="code" class="html">127.0.0.1 web1.com
127.0.0.1 web2.com
127.0.0.1 passport.com</pre>&nbsp; &nbsp; &nbsp; &nbsp;三个域名都是独立的，没有共同父域，web1和web2用于访问应用系统，passport用于访问认证系统。
<p></p>
<p><strong>项目部署</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>项目中包含的是两个Eclipse Project，导入到Eclipse/MyEclipse后，可能需要设置下JavaEE类库。WebSSOAuth为认证系统，WebSSODemo为应用系统，如果映射的域名和我设置的一样，不需要设置，直接部署即可。如果不一样，需要修改下WebSSODemo/WEB-INF/web.xml文件。关键配置信息如下：</p>
<pre code_snippet_id="218843" snippet_file_name="blog_20140305_2_4847634"  code_snippet_id="218843" snippet_file_name="blog_20140305_2_4847634" name="code" class="html">&lt;filter&gt;
    &lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
    &lt;filter-class&gt;com.ghsau.filter.SSOAuth&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;!-- 认证系统服务 --&gt;
    	&lt;param-name&gt;SSOService&lt;/param-name&gt;
    	&lt;param-value&gt;http://passport.com:8080/WebSSOAuth/SSOAuth&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;!-- 认证系统ticket名称 --&gt;
    	&lt;param-name&gt;cookieName&lt;/param-name&gt;
    	&lt;param-value&gt;SSOID&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
	&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
	&lt;url-pattern&gt;/logout&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
	&lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
	&lt;url-pattern&gt;/setCookie&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果域名或端口号和我的不一致，可以修改对应配置项。最后部署到应用服务器中，启动服务器。
<p></p>
<p><strong>SSO使用</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;首先输入第一个应用系统的访问地址，http://web1.com:8080/WebSSODemo/index.jsp，如果是第一次访问的话，会自动跳转到登录页，如下图：<img src="http://img.blog.csdn.net/20140305154755140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;系统中内置了3个用户，张三、李四、王五，用户名和密码皆为拼音全拼，输入zhangsan/zhangsan登录后，会自动跳转到我们刚才访问的页面，页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140305154843171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这时，我们再输入第二个应用系统的访问地址，http://web2.com:8080/WebSSODemo/index.jsp，我们发现，没有进行第二次登录，同样页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140305154930046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们接着点击Logout注销用户，页面跳转到了登录页面，这时我们再回头访问第一个应用系统的页面，发现同样跳转到了登录页面。<br>
&nbsp; &nbsp; &nbsp; &nbsp;互联网中的完全跨域登录的站点也有很多，如<a target="_blank" target="_blank" href="http://www.taobao.com/">淘宝</a>和<a target="_blank" target="_blank" href="http://www.tmall.com/">天猫</a>，但肯定不是我这样实现的。我的实现中，认证系统和应用系统是通过url参数来传递ticket，可能存在一些不稳定因素。应用系统的每次请求都会通过HTTP远程到认证系统进行验证ticket，速度上应该会慢一些，这里可以改进一步，在每个应用系统中也维护一份tickets，验证时，首先到本系统中验证，如果不存在，再远程到认证系统进行验证，但这也增加了应用系统的代码量。本文完，如果有什么问题，欢迎讨论。<br>
&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20545513">http://blog.csdn.net/ghsau/article/details/20545513</a>，转载请注明。<br>
</p>

            <div>
                作者：ghsau 发表于2014/3/5 16:11:50 <a href="http://blog.csdn.net/ghsau/article/details/20545513">原文链接</a>
            </div>
            <div>
            阅读：9708 评论：29 <a href="http://blog.csdn.net/ghsau/article/details/20545513#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]共同父域下的单点登录]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/20466351</link>
        <guid>http://blog.csdn.net/ghsau/article/details/20466351</guid>
        <author>ghsau</author>
        <pubDate>2014/3/4 22:38:28</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20466351">http://blog.csdn.net/ghsau/article/details/20466351</a>，转载请注明。<br>
&nbsp; &nbsp; &nbsp; &nbsp;单点登录(Single Sign On)，简称为SSO，SSO不仅在企业级开发很常用，在互联网中更是大行其道。随便举几个例子，比如我们登录新浪微博后，再访问新浪首页后，我们发现，已经自动登录了；再比如我们登录CSDN后，可以写博客、逛论坛、下载资源等等。前者是完全跨域的单点登录，下文会讲，后者是共同父域下(www.csdn.net、blog.csdn.net、bbs.csdn.net、passport.csdn.net)的单点登录，也就是本文的主要内容。<br>
&nbsp; &nbsp; &nbsp; &nbsp;单点登录实际上是“身份认证”的整合，当我们存在多个应用时，我们希望登录了其中的一个应用，再访问其他应用时，会自动登录，避免用户重复的体力劳动。单点登录的实现原理是比较简单的，如下图所示，当用户通过浏览器第一次访问应用系统1时，由于还没有登录，会被引导到认证系统进行登录。下面开始单点登录的过程：<span style="color:#3333ff">认证系统根据用户在浏览器中输入的登录信息，进行身份认证，如果认证通过，返回给浏览器一个证明ticket(票)；用户再访问其它应用系统时，会带着ticket；应用系统接收到ticket后，会将其发送到认证系统进行合法性校验；校验通过后，用户就不需要再次输入用户名密码来登录了，从而实现了单点登录的功能</span>。<img src="http://img.blog.csdn.net/20140304211546578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;上面描述的过程实际上是WEB-SSO。要实现SSO，首先必须要有统一的认证系统，其次每个应用系统都通过认证系统来校验用户，所以这需要两方面的配合。WEB-SSO是比较好实现的，尤其是共同父域的情况下，我们可以通过浏览器的cookie来保存ticket。今天我用Servlet技术实现了SSO的主要功能，可以在<a target="_blank" target="_blank" href="http://download.csdn.net/detail/ghsau/6993043">这里</a>下载项目。<br>
</p>
<p><strong>域名准备</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>修改hosts文件，映射3个域名：</p>
<pre code_snippet_id="217752" snippet_file_name="blog_20140304_1_7053891"  code_snippet_id="217752" snippet_file_name="blog_20140304_1_7053891" name="code" class="html">127.0.0.1 web1.ghsau.com
127.0.0.1 web2.ghsau.com
127.0.0.1 passport.ghsau.com</pre>&nbsp; &nbsp; &nbsp; &nbsp;3个域名必须拥有共同父域(.ghsau.com)，web1和web2用于访问应用系统，passport用于访问认证系统。
<p></p>
<p><strong>项目部署</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>项目中包含的是两个Eclipse Project，导入到Eclipse/MyEclipse后，可能需要设置下JavaEE类库。WebSSOAuth为认证系统，WebSSODemo为应用系统，如果映射的域名和我设置的一样，不需要设置，直接部署即可。如果不一样，需要修改下两个项目的web.xml文件。关键配置信息如下：<br>
&nbsp; &nbsp; &nbsp; &nbsp;WebSSOAuth/WEB-INF/web.xml：</p>
<pre code_snippet_id="217752" snippet_file_name="blog_20140304_2_6050543"  code_snippet_id="217752" snippet_file_name="blog_20140304_2_6050543" name="code" class="html">&lt;servlet&gt;
    &lt;servlet-name&gt;SSOAuth&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.ghsau.servlet.SSOAuth&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;!-- ticket名称 --&gt;
      &lt;param-name&gt;cookieName&lt;/param-name&gt;
      &lt;param-value&gt;SSOID&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;!-- ticket作用域 --&gt;
      &lt;param-name&gt;domainName&lt;/param-name&gt;
      &lt;param-value&gt;.ghsau.com&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;secure&lt;/param-name&gt;
      &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;!-- ticket内容加密密钥，必须为24个字符，中文算2个字符 --&gt;
      &lt;param-name&gt;secretKey&lt;/param-name&gt;
      &lt;param-value&gt;111111112222222233333333&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;!-- 服务器中ticket的有效期，单位分钟 --&gt;
      &lt;param-name&gt;ticketTimeout&lt;/param-name&gt;
      &lt;param-value&gt;10080&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SSOAuth&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/SSOAuth&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</pre>&nbsp; &nbsp; &nbsp; &nbsp;WebSSODemo/WEB-INF/web.xml：<pre code_snippet_id="217752" snippet_file_name="blog_20140304_3_8003173"  code_snippet_id="217752" snippet_file_name="blog_20140304_3_8003173" name="code" class="html">&lt;filter&gt;
    &lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
    &lt;filter-class&gt;com.ghsau.filter.SSOAuth&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;!-- 认证系统服务 --&gt;
    	&lt;param-name&gt;SSOService&lt;/param-name&gt;
    	&lt;param-value&gt;http://passport.ghsau.com:8080/WebSSOAuth/SSOAuth&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;!-- 认证系统登录页面 --&gt;
    	&lt;param-name&gt;SSOLogin&lt;/param-name&gt;
    	&lt;param-value&gt;http://passport.ghsau.com:8080/WebSSOAuth/login.jsp&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;!-- 认证系统ticket名称 --&gt;
    	&lt;param-name&gt;cookieName&lt;/param-name&gt;
    	&lt;param-value&gt;SSOID&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;SSOAuth&lt;/filter-name&gt;
    &lt;url-pattern&gt;/logout&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果域名或端口号和我的不一致，可以修改对应配置项。最后部署到应用服务器中，启动服务器。<br>
<p></p>
<p><strong>SSO使用</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>首先输入第一个应用系统的访问地址，http://web1.ghsau.com:8080/WebSSODemo/index.jsp，如果是第一次访问的话，会自动跳转到登录页，如下图：<img src="http://img.blog.csdn.net/20140304220529515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;系统中内置了3个用户，张三、李四、王五，用户名和密码皆为拼音全拼，输入zhangsan/zhangsan登录后，会自动跳转到我们刚才访问的页面，页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140304220835828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这时，我们再输入第二个应用系统的访问地址，http://web2.ghsau.com:8080/WebSSODemo/index.jsp，我们发现，没有进行第二次登录，同样页面中显示了登录的用户名及欢迎信息，如下图：<img src="http://img.blog.csdn.net/20140304221211718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们接着点击Logout注销用户，页面跳转到了登录页面，这时我们再回头访问第一个应用系统的页面，发现同样跳转到了登录页面。这给用户的使用效果就是，一个应用登录了，其它的应用都会自动登录，而一个应用中注销了，其它的应用也都会自动注销，好神奇的样子。<br>
&nbsp; &nbsp; &nbsp; &nbsp;项目中提供了源码，代码的实现思路就是上面的那个图，ticket保存在cookie中，利用cookie域的特性，实现了ticket在不同应用中都能够获取到，ticket的验证过程是使用了HttpClient来发送的验证请求，ticket的加密使用了3DES，具体可以看DESUtils.java，好了，就到这里吧，如果有什么问题，欢迎讨论。<br>
&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20466351">http://blog.csdn.net/ghsau/article/details/20466351</a>，转载请注明。<br>
</p>

            <div>
                作者：ghsau 发表于2014/3/4 22:38:28 <a href="http://blog.csdn.net/ghsau/article/details/20466351">原文链接</a>
            </div>
            <div>
            阅读：4023 评论：1 <a href="http://blog.csdn.net/ghsau/article/details/20466351#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Cookie深度解析]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/20395681</link>
        <guid>http://blog.csdn.net/ghsau/article/details/20395681</guid>
        <author>ghsau</author>
        <pubDate>2014/3/4 12:37:29</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20466351">http://blog.csdn.net/ghsau/article/details/20466351</a>，转载请注明。<br>
&nbsp; &nbsp; &nbsp; &nbsp;最近在公司做了Web端单点登录(SSO)功能，基于Cookie实现，做完之后感觉有必要总结一下，本文着重讲解Cookie，下文会说明单点登录的实现方案。</p>
<p><strong>Cookie简介</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;众所周知，Web协议（也就是HTTP）是一个无状态的协议（HTTP1.0）。一个Web应用由很多个Web页面组成，每个页面都有唯一的URL来定义。用户在浏览器的地址栏输入页面的URL，浏览器就会向Web Server去发送请求。如下图，浏览器向Web服务器发送了两个请求，申请了两个页面。这两个页面的请求是分别使用了两个单独的HTTP连接。所谓无状态的协议也就是表现在这里，浏览器和Web服务器会在第一个请求完成以后关闭连接通道，在第二个请求的时候重新建立连接。Web服务器并不区分哪个请求来自哪个客户端，对所有的请求都一视同仁，都是单独的连接。这样的方式大大区别于传统的（Client/Server）C/S结构,在那样的应用中，客户端和服务器端会建立一个长时间的专用的连接通道。正是因为有了无状态的特性，每个连接资源能够很快被其他客户端所重用，一台Web服务器才能够同时服务于成千上万的客户端。<img src="http://img.blog.csdn.net/20140303202645515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
&nbsp; &nbsp; &nbsp; &nbsp;但是我们通常的应用是有状态的。先不用提不同应用之间的SSO，在同一个应用中也需要保存用户的登录身份信息。例如用户在访问页面1的时候进行了登录，但是刚才也提到，客户端的每个请求都是单独的连接，当客户再次访问页面2的时候，如何才能告诉Web服务器，客户刚才已经登录过了呢？浏览器和服务器之间有约定：通过使用cookie技术来维护应用的状态。Cookie是可以被Web服务器设置的字符串，并且可以保存在浏览器中。如下图所示，当浏览器访问了页面1时，web服务器设置了一个cookie，并将这个cookie和页面1一起返回给浏览器，浏览器接到cookie之后，就会保存起来，在它访问页面2的时候会把这个cookie也带上，Web服务器接到请求时也能读出cookie的&#20540;，根据cookie&#20540;的内容就可以判断和恢复一些用户的信息状态。<img src="http://img.blog.csdn.net/20140303203325796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><strong>Cookie组成</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;</strong>cookie是由名称、内容、作用路径、作用域、<span style="font-size:12px">协议、</span>生存周期组成，另外还有个HttpOnly属性，HttpOnly属性很重要，如果您在cookie中设置了HttpOnly属性，那么通过js脚本(document.cookie)将无法读取到cookie信息，这样能一定程度上的防止XSS攻击，关于XSS可以看我之前的文章--<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/17027893">XSS攻击及防御</a>。Tomcat服务器设置的JSESSIONID就是HttpOnly的。<img src="http://img.blog.csdn.net/20140303213906046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
&nbsp; &nbsp; &nbsp; &nbsp;JavaEE中对cookie做了封装，对应的是下面这个类：</p>
<pre>java.lang.Object
  |
  &#43;--<strong>javax.servlet.http.Cookie</strong></pre>
&nbsp; &nbsp; &nbsp; &nbsp;该类可以设置cookie的名称、内容、作用路径、作用域、协议、生存周期，but不能设置HttpOnly属性，不知道这么做是出于什么考虑，如果非要设置HttpOnly的cookie，我们可以通过响应头来处理：<pre code_snippet_id="216375" snippet_file_name="blog_20140304_1_5137003"  code_snippet_id="216375" snippet_file_name="blog_20140304_1_5137003" name="code" class="java">response.setHeader(&quot;Set-Cookie&quot;, &quot;cookiename=value;Path=/;Domain=domainvalue;Max-Age=seconds;HttpOnly&quot;);</pre><strong>Cookie作用域</strong><br>
&nbsp; &nbsp; &nbsp; &nbsp;测试Cookie的作用域需要弄几个域名，修改C:\Windows\System32\drivers\etc\hosts文件，将本机ip映射出四个域名，如下：<pre code_snippet_id="216375" snippet_file_name="blog_20140304_2_5769858"  code_snippet_id="216375" snippet_file_name="blog_20140304_2_5769858" name="code" class="html">127.0.0.1 web1.ghsau.com
127.0.0.1 web2.ghsau.com

127.0.0.1 web1.com
127.0.0.1 web2.com</pre>&nbsp; &nbsp; &nbsp; &nbsp;前两个是2级域名(ghsau.com)相同，3级域名(web1、web2)不同，后两个是2级域名不同。然后我们再写两个jsp，一个用于设置Cookie，另一个用于显示Cookie。<br>
&nbsp; &nbsp; &nbsp; &nbsp;SetCookie.jsp：<br>
<pre code_snippet_id="216375" snippet_file_name="blog_20140304_3_1418440"  code_snippet_id="216375" snippet_file_name="blog_20140304_3_1418440" name="code" class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%
	Cookie cookie = new Cookie(&quot;test_key&quot;, &quot;test_value&quot;);
	cookie.setPath(&quot;/&quot;);
// 	cookie.setDomain(&quot;.ghsau.com&quot;);
	response.addCookie(cookie);
%&gt;</pre>&nbsp; &nbsp; &nbsp; ShowCookie.jsp：<pre code_snippet_id="216375" snippet_file_name="blog_20140304_4_6718357"  code_snippet_id="216375" snippet_file_name="blog_20140304_4_6718357" name="code" class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%
	// 输出cookies，过滤掉JSESSIONID
	Cookie[] cookies = request.getCookies();
	if(cookies != null)
		for(Cookie cookie : cookies) {
			if(cookie.getName().equals(&quot;JSESSIONID&quot;))    continue;
			out.println(cookie.getName() + &quot;-&quot; + cookie.getValue());
		}
%&gt;</pre>&nbsp; &nbsp; &nbsp; &nbsp;将这两个jsp放到应用后，部署到服务器中，启动服务器，我们就可以通过域名来访问了。<br>
&nbsp; &nbsp; &nbsp; &nbsp;测试一，首先访问http://<em>web1.ghsau.com:8080</em>/WebSSOAuth/SetCookie.jsp，设置cookie后，再访问http://<em>web1.ghsau.com:8080</em>/WebSSOAuth/ShowCookie.jsp，页面输出test_key=test_value，这时我们访问http://<em>web2.ghsau.com:8080</em>/WebSSOAuth/ShowCookie.jsp，发现页面什么都没有输出，这时我们得出结论，<u>cookie默认情况下作用域为当前域名</u>。<br>
&nbsp; &nbsp; &nbsp; &nbsp;测试二，将SetCookie.jsp第五行注释打开，按照上面的顺序依次访问，我们发现http://<em>web2.<strong>ghsau</strong>.com:8080</em>/WebSSOAuth/ShowCookie.jsp中输出了http://<em>web1.<strong>ghsau</strong>.com:8080</em>/WebSSOAuth/SetCookie.jsp中设置的cookie，这时我们得出结论，<u>cookie作用域为父级域名时，所有子级域名都可以得到该cookie</u>，这也是实现跨子域SSO的关键。这时有些朋友可能会想到那我把cookie作用域设置到顶级域名(.com、.net)上，是不是用该顶级域名的网站就都能获取该cookie了？这样设置的cookie，浏览器是不存储的，无效的cookie。<br>
<p>&nbsp; &nbsp; &nbsp; &nbsp;测试三，修改SetCookie.jsp第五行代码为cookie.setDomain(&quot;.web2.com&quot;)，首先访问http://<em><strong>web1</strong>.com:8080</em>/WebSSOAuth/SetCookie.jsp，设置cookie后，这时我们访问http://<em><strong>web2</strong>.com:8080</em>/WebSSOAuth/ShowCookie.jsp，发现页面什么都没有输出，这时我们得出结论，<u>cookie不能跨二级域名设置</u>。</p>
<p><strong>Cookie安全性</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;cookie中的数据通常会包含用户的隐私数据，首先要保证数据的保密性，其次要保证数据不能被伪造或者篡改，基于这两点，我们通常需要对cookie内容进行加密，加密方式一般使用对称加密(单密钥，如<a target="_blank" target="_blank" href="http://baike.baidu.com/view/878529.htm?fromId=7510">DES</a>)或非对称加密(一对密钥，如<a target="_blank" target="_blank" href="http://baike.baidu.com/view/10613.htm?fromId=7520">RSA</a>)，密钥需要保存在服务器端一个安全的地方，这样，别人不知道密钥时，无法对数据进行解密，也无法伪造或篡改数据。另外，像上文提到的，重要的cookie数据需要设置成HttpOnly的，避免跨站脚本获取你的cookie，保证了cookie在浏览器端的安全性。还有我们可以设置cookie只作用于安全的协议(https)，JavaEE中可以通过Cookie类的setSecure(boolean
 flag)来设置，设置后，该cookie只会在https下发送，而不会再http下发送，保证了cookie在服务器端的安全性，服务器https的设置可以参照<a target="_blank" target="_blank" href="http://blog.csdn.net/lifetragedy/article/details/7699236">该文章</a>。<br>
&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/20466351">http://blog.csdn.net/ghsau/article/details/20466351</a>，转载请注明。<br>
</p>

            <div>
                作者：ghsau 发表于2014/3/4 12:37:29 <a href="http://blog.csdn.net/ghsau/article/details/20395681">原文链接</a>
            </div>
            <div>
            阅读：9729 评论：9 <a href="http://blog.csdn.net/ghsau/article/details/20395681#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Java序列化(二)]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/19120019</link>
        <guid>http://blog.csdn.net/ghsau/article/details/19120019</guid>
        <author>ghsau</author>
        <pubDate>2014/2/12 17:27:50</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/19120019">http://blog.csdn.net/ghsau/article/details/19120019</a>，转载请注明。<br>
&nbsp; &nbsp; &nbsp; &nbsp;上文中实现了序列化和逆序列化一个简单的Name对象，下面来看一个稍复杂的情况，Name类中复合了其它类。<br>
&nbsp; &nbsp; &nbsp; &nbsp;Name.java：</p>
<pre code_snippet_id="185555" snippet_file_name="blog_20140212_1_5647513"  name="code" class="java">import java.io.Serializable;

/**
 * 可序列化的类，需要实现Serializable接口
 * @author 爽
 *
 */
public class Name implements Serializable {

	private static final long serialVersionUID = 1L;

	private String firstname;
	
	private String lastname;
	
	private Nickname nickname;
	
	public Name() {}

	public Name(String firstname, String lastname) {
		this.firstname = firstname;
		this.lastname = lastname;
	}
	
	public Name(String firstname, String lastname, Nickname nickname) {
		this.firstname = firstname;
		this.lastname = lastname;
		this.nickname = nickname;
	}

	public String getFirstname() {
		return firstname;
	}

	public void setFirstname(String firstname) {
		this.firstname = firstname;
	}

	public String getLastname() {
		return lastname;
	}

	public void setLastname(String lastname) {
		this.lastname = lastname;
	}
	
	public Nickname getNickname() {
		return nickname;
	}

	public void setNickname(Nickname nickname) {
		this.nickname = nickname;
	}

	@Override
	public String toString() {
		return &quot;我的名字是&quot; + firstname + &quot;,&quot; + lastname + &quot;\n我的昵称是&quot; + nickname;
	}
	
}
</pre>&nbsp; &nbsp; &nbsp; &nbsp;Nickname.java：<pre code_snippet_id="185555" snippet_file_name="blog_20140212_2_8090511"  name="code" class="java">import java.io.Serializable;

/**
 * 昵称类
 * @author 爽
 *
 */
public class Nickname implements Serializable {

	private static final long serialVersionUID = 1L;
	
	private String name;
	
	public Nickname() {}

	public Nickname(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}
	
}
</pre>&nbsp; &nbsp; &nbsp; &nbsp;WriteObject.java：<pre code_snippet_id="185555" snippet_file_name="blog_20140212_3_1820266"  name="code" class="java">import java.io.IOException;

import com.runqianapp.test.bean.Name;
import com.runqianapp.test.bean.Nickname;

public class WriteObject {

	public static void main(String[] args) throws IOException {
		Nickname nickname = new Nickname(&quot;黑曼巴&quot;);
		Name name = new Name(&quot;科比&quot;, &quot;布莱恩特&quot;, nickname);
		Serializations.serialize(args[0], name);
	}

}
</pre>&nbsp; &nbsp; &nbsp; &nbsp;运行后，指定目录下会生成相应文件，再次运行ReadObject.java，会得到如下输出信息：<pre code_snippet_id="185555" snippet_file_name="blog_20140212_4_1089918"  name="code" class="java">我的名字是科比,布莱恩特
我的昵称是黑曼巴</pre>&nbsp; &nbsp; &nbsp; &nbsp;在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。在序列化过程中，可能会遇到不支持可序列化接口的对象，在此情况下，将抛出
 NotSerializableException，并将标识不可序列化对象的类。如将Nickname.java去掉Serializable接口，再次运行WriteObject.java，会抛出如下异常：<pre code_snippet_id="185555" snippet_file_name="blog_20140212_5_8166959"  name="code" class="java">Exception in thread &quot;main&quot; java.io.NotSerializableException: Nickname
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1180)
	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1528)
	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1493)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1416)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1174)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:346)
	at Serializations.serialize(Serializations.java:26)
	at WriteObject.main(WriteObject.java:13)</pre>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们可以用<strong><span style="color:#993399">transient</span></strong>来修饰nickname属性，这样该类就可以正常序列化了，但是nickname中的属性也就无法序列化了，那我们如何让不能序列化的类NickName中的name属性可以序列化和反序列化呢？在序列化和反序列化过程中需要特殊处理的类必须使用下列准确签名来实现特殊方法：</p>
<pre code_snippet_id="185555" snippet_file_name="blog_20140212_6_8516406"  name="code" class="java">private void writeObject(java.io.ObjectOutputStream out)
    throws IOException;
private void readObject(java.io.ObjectInputStream in)
    throws IOException, ClassNotFoundException;</pre>&nbsp; &nbsp; &nbsp; &nbsp;在对象序列化时，会调用writeObject方法，在对象反序列化时，会调用readObject方法。writeObject 方法负责写入特定类的对象的状态，以便相应的 readObject 方法可以还原它。通过调用 out.defaultWriteObject 可以调用保存 Object 的字段的默认机制。readObject 方法负责从流中读取并还原类字段。它可以调用 in.defaultReadObject 来调用默认机制，以还原对象的非静态和非瞬态字段。所以，我们可以在Name类中加入如下方法：<pre code_snippet_id="185555" snippet_file_name="blog_20140212_7_2246160"  name="code" class="java">private void writeObject(java.io.ObjectOutputStream out)
		 throws IOException {
	// 默认序列化机制
	out.defaultWriteObject();
	// 序列化nickname中的name属性
	out.writeObject(nickname.getName());
}

private void readObject(java.io.ObjectInputStream in)
		 throws IOException, ClassNotFoundException {
	// 默认逆序列化机制
	in.defaultReadObject();
	// 逆序列化一个nickname对象
	nickname = new Nickname(in.readObject().toString());
}</pre>&nbsp;
 &nbsp; &nbsp; &nbsp;这样就可以处理其不可序列化的复合类Nickname中的name属性序列化及反序列化。运行WriteObject和ReadObject，序列化和反序列化成功。这两个方法如何实现取决于最终的需求，上面的例子是我想的一个比较符合应用场景的实例。<br>
&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/19120019">http://blog.csdn.net/ghsau/article/details/19120019</a>，转载请注明。<br>
<p></p>

            <div>
                作者：ghsau 发表于2014/2/12 17:27:50 <a href="http://blog.csdn.net/ghsau/article/details/19120019">原文链接</a>
            </div>
            <div>
            阅读：1496 评论：0 <a href="http://blog.csdn.net/ghsau/article/details/19120019#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Java序列化(一)]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/18240731</link>
        <guid>http://blog.csdn.net/ghsau/article/details/18240731</guid>
        <author>ghsau</author>
        <pubDate>2014/1/28 20:58:24</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/18240731">http://blog.csdn.net/ghsau/article/details/18240731</a>，转载请注明。<br />&nbsp; &nbsp; &nbsp; &nbsp;Java序列化，一个日常开发中比较少用到的技术。正常情况下，JVM启动后，我们可以创建对象生存其内，JVM关闭后，我们创建过的对象都随之销毁，资源释放。但有些时候可能要求在JVM停止之后，某些对象需要保存起来，以便将来再重新读取它们。举个例子，应用服务器的HttpSession对象，Session是指浏览器与服务器之间的一次会话，对应的是服务器中的一个Session对象，而客户端中保存一个jsessionid，这里回忆一下Session的知识，之前有文章详细的解析过Session，见<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/13023425">Session深度解析</a>。那么当某种情况下，我们不得不重启服务器的时候，就需要把之前所有的Session对象保存起来，服务器重启之后，将这些Session对象再重新加载过来，这样避免了之前浏览器与服务器建立的会话失效，在浏览器那看来，就好象服务器没有关闭过一样(假设服务器重启期间用户没有操作)。这就用到了Java序列化技术，关于这个例子，我们可以拿Tomcat来测试一下，注意要用正常的手段来关闭服务器(shutdown.bat)，而非强制关闭，强制关闭没有序列化的过程。下面来看一个序列化的程序。<br />&nbsp; &nbsp; &nbsp; &nbsp;首先创建一个可序列化的JavaBean类，Name.java。</p><pre code_snippet_id="174257" snippet_file_name="blog_20140128_1_2604123"  code_snippet_id="174257" snippet_file_name="blog_20140128_1_2604123" name="code" class="java">import java.io.Serializable;

/**
 * 可序列化的类，需要实现Serializable接口
 * @author 爽
 *
 */
public class Name implements Serializable {

	private String firstname;
	
	private String lastname;
	
	public Name() {
		System.out.println(&quot;无参构造器&quot;);
	}

	public Name(String firstname, String lastname) {
		System.out.println(&quot;全参构造器&quot;);
		this.firstname = firstname;
		this.lastname = lastname;
	}

	public String getFirstname() {
		return firstname;
	}

	public void setFirstname(String firstname) {
		this.firstname = firstname;
	}

	public String getLastname() {
		return lastname;
	}

	public void setLastname(String lastname) {
		this.lastname = lastname;
	}
	
	@Override
	public String toString() {
		return &quot;我的名字是&quot; + firstname + &quot;,&quot; + lastname;
	}
	
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;再实现一个序列化的工具类，Serializations.java。<pre code_snippet_id="174257" snippet_file_name="blog_20140128_2_542809"  code_snippet_id="174257" snippet_file_name="blog_20140128_2_542809" name="code" class="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * 序列化工具类
 * @author 爽
 *
 */
public class Serializations {

	/**
	 * 序列化对象到指定路径文件
	 * @param outPath 文件路径
	 * @param outObj 需要序列化的对象
	 * @throws IOException 当I/O发生异常时
	 */
	public static void serialize(String outPath, Object outObj) throws IOException {
		ObjectOutputStream oos = null;
		try {
			oos = new ObjectOutputStream(new FileOutputStream(outPath));
			oos.writeObject(outObj);
		} finally {
			if(oos != null)    oos.close();
		}
	}
	
	/**
	 * 从文件中逆序列化出对象
	 * @param inPath 文件路径
	 * @return 你序列化出的对象
	 * @throws IOException 当I/O发生异常时
	 * @throws ClassNotFoundException 当文件中不存在序列化的对象时
	 */
	public static Object deserialize(String inPath) throws IOException, ClassNotFoundException {
		ObjectInputStream ois = null;
		try {
			ois = new ObjectInputStream(new FileInputStream(inPath));
	        return ois.readObject();
		} finally {
			if(ois != null)    ois.close();
		}
	}
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;最后创建两个个测试类，来使用一下序列化方法和逆序列化方法，WriteObject.java。<pre code_snippet_id="174257" snippet_file_name="blog_20140128_3_1306177"  code_snippet_id="174257" snippet_file_name="blog_20140128_3_1306177" name="code" class="java">import java.io.IOException;

public class WriteObject {

	public static void main(String[] args) throws IOException {
		Name name = new Name(&quot;科比&quot;, &quot;布莱恩特&quot;);
		Serializations.serialize(args[0], name);
	}

}</pre>&nbsp; &nbsp; &nbsp; &nbsp;运行后，指定目录下会生成相应文件，其内包含了name对象信息。<br />&nbsp; &nbsp; &nbsp; &nbsp;ReadObject.java。<pre code_snippet_id="174257" snippet_file_name="blog_20140128_4_2418209"  code_snippet_id="174257" snippet_file_name="blog_20140128_4_2418209" name="code" class="java">import java.io.IOException;

public class ReadObject {

	public static void main(String[] args) throws ClassNotFoundException, IOException {
		Object obj = Serializations.deserialize(args[0]);
		System.out.println(obj);
	}

}</pre>&nbsp; &nbsp; &nbsp; &nbsp;运行后，输出：<pre code_snippet_id="174257" snippet_file_name="blog_20140128_5_6769627"  code_snippet_id="174257" snippet_file_name="blog_20140128_5_6769627" name="code" class="java">我的名字是科比,布莱恩特</pre>&nbsp; &nbsp; &nbsp; &nbsp;我们成功的将name对象序列化到了指定文件中，并且通过逆序列化得到一个和原对象属性相同的对象。注意，逆序列化出的对象没有使用该对象的构造器(由输出结果可以证明)，并且和原对象不相等。<strong>对象的默认序列化机制</strong>：序列化时，对象的类、类的签名，以及类及其所有超类型的非瞬态(non-transient)和非静态(non-static)字段的值都将被写入。逆序列化时，对象的类、类的签名，以及类及其所有超类型的非瞬态(non-transient)和非静态(non-static)字段的值都将被读取。如果我们想某个成员变量不被序列化，可以在其前面加入<strong>transient</strong>关键字。如：<pre code_snippet_id="174257" snippet_file_name="blog_20140128_6_3421557"  code_snippet_id="174257" snippet_file_name="blog_20140128_6_3421557" name="code" class="java">private transient String lastname;</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果对象所属类在对象序列化之后做了修改，比如修改属性名称、类型、修饰符等等，再次逆序列化就会发生异常，如我们将lastname前加入<strong>transient</strong>，使用ReadObject.java进行逆序列化，&nbsp;将会抛出如下异常：<pre code_snippet_id="174257" snippet_file_name="blog_20140128_7_3072110"  code_snippet_id="174257" snippet_file_name="blog_20140128_7_3072110" name="code" class="java">Exception in thread &quot;main&quot; java.io.InvalidClassException: Name; local class incompatible: stream classdesc serialVersionUID = 3999552307707967101, local class serialVersionUID = -4860856635192050881
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:604)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1601)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1514)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1750)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1347)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:369)
	at Serializations.deserialize(Serializations.java:43)
	at ReadObject.main(SerializationsTest.java:14)</pre>&nbsp; &nbsp; &nbsp; &nbsp;异常的大概描述是说流中的类的版本号和本地类的版本号不一致，这里要引入一个序列化版本号(serialVersionUID)的概念，<strong>serialVersionUID</strong>是一个64位的值，在类中需要声明为private static final long，它可以人为来维护，也可以通过<a target=_blank target="_blank" href="http://docs.oracle.com/javase/6/docs/platform/serialization/spec/class.html#4100">JVM实现的算法</a>来生成，安装JDK后，可以通过%JAVA_HOME%/bin/serialver.exe来生成<span style="font-weight:bold">serialVersionUID</span>。在逆序列化时，会将从对象流中读取的类信息和当前classpath下的相应类的类信息(Name.class)进行比对，比对的媒介就是<span style="font-weight:bold">serialVersionUID</span>，如果对象中没有声明serialVersionUID，那么该值就会通过默认的算法生成，两端不一致时，就会抛出上面的异常，逆序列化失败。<br />&nbsp; &nbsp; &nbsp; &nbsp;当编写一个可序列化的类时(Name.java)，可以给serialVersionUID赋一个即简单又易理解的值，如：<pre code_snippet_id="174257" snippet_file_name="blog_20140128_8_1327224"  code_snippet_id="174257" snippet_file_name="blog_20140128_8_1327224" name="code" class="java">private static final long serialVersionUID = 1L;</pre>&nbsp; &nbsp; &nbsp; &nbsp;如果对该类进行了更改，可能需要同时更新serialVersionUID，如：<pre code_snippet_id="174257" snippet_file_name="blog_20140128_9_6550693"  code_snippet_id="174257" snippet_file_name="blog_20140128_9_6550693" name="code" class="java">private static final long serialVersionUID = 2L;</pre>&nbsp; &nbsp; &nbsp; &nbsp;但有时我们可能即使更改了类之后，仍然要保持之前序列化的可逆性，也就是对之前的序列化文件做个兼容，那么就不能更新serialVersionUID的值，这时更改前生成的序列化文件依然可逆序列化，那么其更新的字段会以字段类型的预设值逆序列化，避开不兼容的问题。<br />&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target=_blank target="_blank" href="http://blog.csdn.net/ghsau/article/details/18240731">http://blog.csdn.net/ghsau/article/details/18240731</a>，转载请注明。<p></p>
            <div>
                作者：ghsau 发表于2014/1/28 20:58:24 <a href="http://blog.csdn.net/ghsau/article/details/18240731">原文链接</a>
            </div>
            <div>
            阅读：2753 评论：4 <a href="http://blog.csdn.net/ghsau/article/details/18240731#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Java Mail(三)：Session、Message详解]]></title>
        <link>http://blog.csdn.net/ghsau/article/details/17909093</link>
        <guid>http://blog.csdn.net/ghsau/article/details/17909093</guid>
        <author>ghsau</author>
        <pubDate>2014/1/6 12:29:25</pubDate>
        <description><![CDATA[
            
<p>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/17909093">http://blog.csdn.net/ghsau/article/details/17909093</a>，转载请注明。<br>
&nbsp; &nbsp; &nbsp; &nbsp;上篇文章介绍了JavaMail并实现了一个发送邮件的简单示例，JavaMail API使用上非常灵活，比如，服务器信息可以设置到Session中，也可以设置到Transport中，收件人可以设置到Message中，也可以设置到Transport中，如何使用，取决于我们应用程序中的实际情况。本文详细的介绍一下这三个类的主要方法。</p>
<h1>Session</h1>
<div><br>
</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;Session用于收集JavaMail运行过程中的环境信息，它可以创建一个单例的对象，也可以每次创建新的对象，Session没有构造器，只能通过如下方法创造实例：
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html">Session</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getDefaultInstance(java.util.Properties)">getDefaultInstance</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.util" href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html?is-external=true">Properties</a>&nbsp;props)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the default Session object.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html">Session</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getDefaultInstance(java.util.Properties, javax.mail.Authenticator)">getDefaultInstance</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.util" href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html?is-external=true">Properties</a>&nbsp;props,<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Authenticator.html">Authenticator</a>&nbsp;authenticator)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the default Session object.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html">Session</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getInstance(java.util.Properties)">getInstance</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.util" href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html?is-external=true">Properties</a>&nbsp;props)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a new Session object.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html">Session</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getInstance(java.util.Properties, javax.mail.Authenticator)">getInstance</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.util" href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html?is-external=true">Properties</a>&nbsp;props,<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Authenticator.html">Authenticator</a>&nbsp;authenticator)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a new Session object.</td>
</tr>
</tbody>
</table>
</div>
&nbsp; &nbsp; &nbsp; &nbsp;getDefaultInstance得到的始终是该方法初次创建的缺省的对象，而getInstance得到的始终是新的对象，Authenticator的使用后面会说到。通过Session可以创建Transport(用于发送邮件)和Store(用于接收邮件)，Transport和Store是JavaMail API中定义好的接口，通过上文我们知道JavaMail分为API和service provider两部分，API定义了相关接口(eg.:Transport and Store)，service
 provider中实现了这些接口，这些实现类配置在名为<em>javamail.providers</em>或<em>javamail.default.providers</em>的文件中，该文件放在mail.jar/smtp.jar/pop3.jar/imap.jar中的META-INF下，文件内容&#26684;式如：<pre code_snippet_id="144064" snippet_file_name="blog_20140106_1_2213911"  name="code" class="plain"># JavaMail IMAP provider Sun Microsystems, Inc
protocol=imap; type=store; class=com.sun.mail.imap.IMAPStore; vendor=Sun Microsystems, Inc;
protocol=imaps; type=store; class=com.sun.mail.imap.IMAPSSLStore; vendor=Sun Microsystems, Inc;
# JavaMail SMTP provider Sun Microsystems, Inc
protocol=smtp; type=transport; class=com.sun.mail.smtp.SMTPTransport; vendor=Sun Microsystems, Inc;
protocol=smtps; type=transport; class=com.sun.mail.smtp.SMTPSSLTransport; vendor=Sun Microsystems, Inc;
# JavaMail POP3 provider Sun Microsystems, Inc
protocol=pop3; type=store; class=com.sun.mail.pop3.POP3Store; vendor=Sun Microsystems, Inc;
protocol=pop3s; type=store; class=com.sun.mail.pop3.POP3SSLStore; vendor=Sun Microsystems, Inc;</pre>&nbsp; &nbsp; &nbsp; &nbsp;每一行声明了协议名称、类型、实现类、供应商、版本等信息，如果需要自己实现相应的协议，必须按照该&#26684;式配置好，Java Mail API中才能正确的调用到。Session中提供的创建Trasnsport和Store的方法如下：
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Store.html">Store</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getStore()">getStore</a></strong>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Store object that implements this user's desired Store protocol.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Store.html">Store</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getStore(javax.mail.Provider)">getStore</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Provider.html">Provider</a>&nbsp;provider)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an instance of the store specified by Provider.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Store.html">Store</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getStore(java.lang.String)">getStore</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html?is-external=true">String</a>&nbsp;protocol)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Store object that implements the specified protocol.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Store.html">Store</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getStore(javax.mail.URLName)">getStore</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/URLName.html">URLName</a>&nbsp;url)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Store object for the given URLName.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Transport.html">Transport</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getTransport()">getTransport</a></strong>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Transport object that implements this user's desired Transport protcol.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Transport.html">Transport</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getTransport(javax.mail.Address)">getTransport</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Address.html">Address</a>&nbsp;address)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Transport object that can transport a Message of the specified address type.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Transport.html">Transport</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getTransport(javax.mail.Provider)">getTransport</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Provider.html">Provider</a>&nbsp;provider)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an instance of the transport specified in the Provider.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Transport.html">Transport</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getTransport(java.lang.String)">getTransport</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html?is-external=true">String</a>&nbsp;protocol)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Transport object that implements the specified protocol.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Transport.html">Transport</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Session.html#getTransport(javax.mail.URLName)">getTransport</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/URLName.html">URLName</a>&nbsp;url)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a Transport object for the given URLName.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;可以看到，重构了很多，这些方法最终都会去解析上文提到的配置文件，找到对应配置信息。
<div><br>
</div>
<h1>Message</h1>
<div><br>
&nbsp; &nbsp; &nbsp; &nbsp;Message是邮件的载体，用于封装邮件的所有信息，Message是一个抽象类，已知的实现类有MimeMessage。一封完整的邮件都有哪些信息呢？我们打开一个邮件客户端，我用的是FoxMail，新建一封邮件，如下图所示：<img src="http://img.blog.csdn.net/20140106095118015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2hzYXU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;这就是一封完整的邮件包含的所有信息，默认情况下是没有暗送和回复设置的，可以通过菜单栏--&gt;查看--&gt;暗送地址/回复地址来显示出来，回复地址默认情况下为发件人，暗送是比较猥琐的发邮件方式，暗送邮件除了被暗送者，没有人能知道暗送给谁了，邮件头信息中也不会记录。下面来看下Message中设置邮件信息的一些方法。</div>
<h2>发件人</h2>
<div>
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>abstract &nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setFrom()">setFrom</a></strong>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the &quot;From&quot; attribute in this Message.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>abstract &nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setFrom(javax.mail.Address)">setFrom</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Address.html">Address</a>&nbsp;address)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the &quot;From&quot; attribute in this Message.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;现在大多数SMTP服务器要求发件人与连接账户必须一致，否则会抛出验证失败的异常，这样是防止用户伪装成其它人的账户恶意发送邮件。</div>
<h2>收件人/抄送人/暗送人</h2>
<div>
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setRecipient(javax.mail.Message.RecipientType, javax.mail.Address)">setRecipient</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html">Message.RecipientType</a>&nbsp;type,<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Address.html">Address</a>&nbsp;address)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the recipient address.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>abstract &nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setRecipients(javax.mail.Message.RecipientType, javax.mail.Address[])">setRecipients</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html">Message.RecipientType</a>&nbsp;type,<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Address.html">Address</a>[]&nbsp;addresses)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the recipient addresses.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;第一个方法设置单个人，第二个方法设置多个人。方法中第一个参数涉及到另一个类RecipientType，该类是Message的静态内部类，期内有三个常量&#20540;：
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html">Message.RecipientType</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html#BCC">BCC</a></strong></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The &quot;Bcc&quot; (blind carbon copy) recipients.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html">Message.RecipientType</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html#CC">CC</a></strong></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The &quot;Cc&quot; (carbon copy) recipients.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>static&nbsp;<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html">Message.RecipientType</a></code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.RecipientType.html#TO">TO</a></strong></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The &quot;To&quot; (primary) recipients.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;TO - 收件人；CC - 抄送人；BCC - 暗送人。</div>
<h2>回复人</h2>
<div>
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setReplyTo(javax.mail.Address[])">setReplyTo</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Address.html">Address</a>[]&nbsp;addresses)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the addresses to which replies should be directed.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;设置收件人收到邮件后的回复地址。</div>
<h2>标题</h2>
<div>
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>abstract &nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Message.html#setSubject(java.lang.String)">setSubject</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html?is-external=true">String</a>&nbsp;subject)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the subject of this message.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;设置邮件标题/主题。</div>
<h2>内容</h2>
<div>
<table width="100%" border="1" cellspacing="0" cellpadding="3" summary="">
<tbody>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Part.html#setContent(javax.mail.Multipart)">setContent</a></strong>(<a target="_blank" target="_blank" title="class in javax.mail" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Multipart.html">Multipart</a>&nbsp;mp)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method sets the given Multipart object as this message's content.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Part.html#setContent(java.lang.Object, java.lang.String)">setContent</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html?is-external=true">Object</a>&nbsp;obj,<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html?is-external=true">String</a>&nbsp;type)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A convenience method for setting this part's content.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td width="1%" align="right" valign="top"><span size="-1" style=""><code>&nbsp;void</code></span></td>
<td><code><strong><a target="_blank" target="_blank" href="file:///K:/Java%20Tool/JavaMail/javamail-1.4.5/docs/javadocs/javax/mail/Part.html#setText(java.lang.String)">setText</a></strong>(<a target="_blank" target="_blank" title="class or interface in java.lang" href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html?is-external=true">String</a>&nbsp;text)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A convenience method that sets the given String as this part's content with a MIME type of &quot;text/plain&quot;.</td>
</tr>
</tbody>
</table>
&nbsp; &nbsp; &nbsp; &nbsp;设置邮件文本内容、HTML内容、附件内容。</div>
<div><br>
</div>
<h1>示例</h1>
<div><br>
</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;下面来看一个稍复杂点的示例：<pre code_snippet_id="144064" snippet_file_name="blog_20140106_2_4275226"  name="code" class="java">public class JavaMailTest2 {

	public static void main(String[] args) throws MessagingException {
		Properties props = new Properties();
		// 开启debug调试
		props.setProperty(&quot;mail.debug&quot;, &quot;true&quot;);
		// 发送服务器需要身份验证
		props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);
		// 设置邮件服务器主机名
		props.setProperty(&quot;mail.host&quot;, &quot;smtp.163.com&quot;);
		// 发送邮件协议名称
		props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);
		
		// 设置环境信息
		Session session = Session.getInstance(props, new Authenticator() {
			// 在session中设置账户信息，Transport发送邮件时会使用
			protected PasswordAuthentication getPasswordAuthentication() {
				return new PasswordAuthentication(&quot;java_mail_001&quot;, &quot;javamail&quot;);
			}
		});
		
		// 创建邮件对象
		Message msg = new MimeMessage(session);
		// 发件人
		msg.setFrom(new InternetAddress(&quot;java_mail_001@163.com&quot;));
		// 多个收件人
		msg.setRecipients(RecipientType.TO, InternetAddress.parse(&quot;java_mail_002@163.com,java_mail_003@163.com&quot;));
		// 抄送人
		msg.setRecipient(RecipientType.CC, new InternetAddress(&quot;java_mail_001@163.com&quot;));
		// 暗送人
		msg.setRecipient(RecipientType.BCC, new InternetAddress(&quot;java_mail_004@163.com&quot;));
		
		// 主题
		msg.setSubject(&quot;中文主题&quot;);
		// HTML内容
		msg.setContent(&quot;&lt;div align=\&quot;center\&quot;&gt;你好啊&lt;/div&gt;&quot;, &quot;text/html;charset=utf-8&quot;);
		
		// 连接邮件服务器、发送邮件、关闭连接，全干了
		Transport.send(msg);
	}

}</pre>&nbsp; &nbsp; &nbsp; &nbsp;本文来自：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau">高爽|Coder</a>，原文地址：<a target="_blank" target="_blank" href="http://blog.csdn.net/ghsau/article/details/17909093">http://blog.csdn.net/ghsau/article/details/17909093</a>，转载请注明。<br>
</div>

            <div>
                作者：ghsau 发表于2014/1/6 12:29:25 <a href="http://blog.csdn.net/ghsau/article/details/17909093">原文链接</a>
            </div>
            <div>
            阅读：3893 评论：2 <a href="http://blog.csdn.net/ghsau/article/details/17909093#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
</channel>
</rss>
