<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园_jingwhale</title>
  <subtitle type="text">Learn and live.</subtitle>
  <id>uuid:fe355ab1-d2aa-4bf3-8e3c-b58532231d89;id=76</id>
  <updated>2015-08-31T13:00:12Z</updated>
  <author>
    <name>jingwhale</name>
    <uri>http://www.cnblogs.com/jingwhale/</uri>
  </author>
  <generator>feed.cnblogs.com</generator>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4774105.html</id>
    <title type="text">全解排序算法 - jingwhale</title>
    <summary type="text">排序：就是重新排列表中的元素，是表中的元素满足按关键字递增或递减的过程。为了查找方便，通常要求计算机中的表是按关键字有序的。排序的确切定义如下： 输入：n个记录R1,R2, ...，Rn对应的关键字为k1,k2，...，kn。 输出：输入序列的一个重排R1',R2', ...，Rn'，使得有k1'&lt;=k2'&lt;=...&lt;=kn'（其中“&lt;=”办以换成其他的比较大小的符号)。 算法的稳定性：如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且排序前Ri在Rj前面，如果使用某—排序算法排序后，Ri仍然在Rj前面，则称这个的，否则称排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。 注意：对于不稳定的排序算法，只需举出一组关键字的实例说明它的不稳定性即可。 在排序的过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序是指在排序期间元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之</summary>
    <published>2015-08-31T13:00:00Z</published>
    <updated>2015-08-31T13:00:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4774105.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4774105.html" />
    <content type="html">排序：就是重新排列表中的元素，是表中的元素满足按关键字递增或递减的过程。为了查找方便，通常要求计算机中的表是按关键字有序的。排序的确切定义如下：  输入：n个记录R1,R2, ...，Rn对应的关键字为k1,k2，...，kn。  输出：输入序列的一个重排R1',R2', ...，Rn'，使得有k1'&lt;=k2'&lt;=...&lt;=kn'（其中“&lt;=”办以换成其他的比较大小的符号)。 算法的稳定性：如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且排序前Ri在Rj前面，如果使用某—排序算法排序后，Ri仍然在Rj前面，则称这个的，否则称排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。  注意：对于不稳定的排序算法，只需举出一组关键字的实例说明它的不稳定性即可。  在排序的过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序是指在排序期间元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之&lt;img src="http://counter.cnblogs.com/blog/rss/4774105" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4774105.html" target="_blank"&gt;全解排序算法&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4771269.html</id>
    <title type="text">算法的复杂度 - jingwhale</title>
    <summary type="text">算法效率的度量是通过时间复杂度和空间复杂度来描述的。  一.时间复杂度 —个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作T(n),它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中的基本运算（最深层循环内的语句）的频度与T(n)同数量级，所以通常采用算法中基本运算的频度制来分析算法的时间复杂度。因此，算法的时间复杂度也记为： T(n)=O(f(n)) 上式中“O”的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和no,使得当n&gt;=no时，都满足0&lt;=T(n)&lt;=C*F(n)。 算法的时间复杂度不仅依赖于问题的规模n,也取决于待输入数据的性质（如输入数据元素的初始状态）。  （1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多</summary>
    <published>2015-08-30T10:01:00Z</published>
    <updated>2015-08-30T10:01:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4771269.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4771269.html" />
    <content type="html">算法效率的度量是通过时间复杂度和空间复杂度来描述的。   一.时间复杂度 —个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作T(n),它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中的基本运算（最深层循环内的语句）的频度与T(n)同数量级，所以通常采用算法中基本运算的频度制来分析算法的时间复杂度。因此，算法的时间复杂度也记为：  T(n)=O(f(n)) 上式中“O”的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和no,使得当n&gt;=no时，都满足0&lt;=T(n)&lt;=C*F(n)。 算法的时间复杂度不仅依赖于问题的规模n,也取决于待输入数据的性质（如输入数据元素的初始状态）。   （1）时间频度  一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多&lt;img src="http://counter.cnblogs.com/blog/rss/4771269" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4771269.html" target="_blank"&gt;算法的复杂度&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4753686.html</id>
    <title type="text">前端技术-布局解决方案 - jingwhale</title>
    <summary type="text">本文介绍了布局解决方案，主要分为三个部分来讲居中布局，多列布局，等列布局。每个部分又分为定宽和不定宽的讨论。</summary>
    <published>2015-08-23T17:07:00Z</published>
    <updated>2015-08-23T17:07:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4753686.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4753686.html" />
    <content type="html">本文介绍了布局解决方案，主要分为三个部分来讲居中布局，多列布局，等列布局。每个部分又分为定宽和不定宽的讨论。&lt;img src="http://counter.cnblogs.com/blog/rss/4753686" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4753686.html" target="_blank"&gt;前端技术-布局解决方案&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4714082.html</id>
    <title type="text">前端技术-HTML页面的加载 - jingwhale</title>
    <summary type="text">HTML页面的加载 HTML页面的加载实际上是基于http过程+浏览器对数据的解析渲染。 http协议的请求过程是基于TCP协议的。http是要基于TCP连接基础上，简单的说，TCP单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http基于TCP建立的连接来收发数据，即实际应用上来的。 一个HTML页面的加载的交互流程大致如下： 0.输入URL 1.解析URL 2.构造并发送HTTP请求 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com） 浏览器跟踪重定向地址 3.HTTP报文传输过程 4.服务器接受并处理HTTP报文 5.服务器构造并发送响应报文（传输过程略） 6.浏览器接收报文，并开始构建页面 7.（可选）浏览器发送嵌入在 HTML 中的静态资源如图片、音频、视频、CSS、JS等等） 8.（可选）浏览器发送Ajax异步请求（处理过程略） 9.页面构建完成 </summary>
    <published>2015-08-08T14:38:00Z</published>
    <updated>2015-08-08T14:38:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4714082.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4714082.html" />
    <content type="html">HTML页面的加载HTML页面的加载实际上是基于http过程+浏览器对数据的解析渲染。http协议的请求过程是基于TCP协议的。http是要基于TCP连接基础上，简单的说，TCP单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http基于TCP建立的连接来收发数据，即实际应用上来的。一个HTML页面的加载的交互流程大致如下：0.输入URL1.解析URL2.构造并发送HTTP请求服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）浏览器跟踪重定向地址3.HTTP报文传输过程4.服务器接受并处理HTTP报文5.服务器构造并发送响应报文（传输过程略）6.浏览器接收报文，并开始构建页面7.（可选）浏览器发送嵌入在 HTML 中的静态资源如图片、音频、视频、CSS、JS等等）8.（可选）浏览器发送Ajax异步请求（处理过程略）9.页面构建完成&lt;img src="http://counter.cnblogs.com/blog/rss/4714082" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4714082.html" target="_blank"&gt;前端技术-HTML页面的加载&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4696439.html</id>
    <title type="text">前端技术-前端优化 - jingwhale</title>
    <summary type="text">时间花哪里去了？ 只有10%-20%的最终用户响应时间花在了下载html文档上,其余80%-90%时间花在了下载页面的相关组件上。如：图片、Flash等。 所以主要优化： 减少http请求 缓存 减少文件大小：压缩文件+优化代码 健康的优化因该是根据页面的加载过程，全面的优化过程 第一步、浏览器预处理 查询Cache：读取Cache 或者发送304请求 第二步、查询DNS 优化规则--减少DNS查找 DNS缓存 浏览器DNS缓存 计算机DNS缓存 服务器DNS缓存（TTL） 使用Keep-Alive特性 减少DNS查找 当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。 较少的域名来减少DNS查找（2-4个主机）</summary>
    <published>2015-08-02T10:20:00Z</published>
    <updated>2015-08-02T10:20:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4696439.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4696439.html" />
    <content type="html">时间花哪里去了？只有10%-20%的最终用户响应时间花在了下载html文档上,其余80%-90%时间花在了下载页面的相关组件上。如：图片、Flash等。所以主要优化：减少http请求缓存减少文件大小：压缩文件+优化代码健康的优化因该是根据页面的加载过程，全面的优化过程第一步、浏览器预处理查询Cache：读取Cache 或者发送304请求第二步、查询DNS优化规则--减少DNS查找DNS缓存浏览器DNS缓存 计算机DNS缓存 服务器DNS缓存（TTL）使用Keep-Alive特性 减少DNS查找当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）&lt;img src="http://counter.cnblogs.com/blog/rss/4696439" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4696439.html" target="_blank"&gt;前端技术-前端优化&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4678656.html</id>
    <title type="text">js面向对象理解 - jingwhale</title>
    <summary type="text">ECMAScript 有两种开发模式：1.函数式(过程化)，2.面向对象(OOP)。面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。一．创建对象 创建一个对象，然后给这个对象新建属性和方法。构造函数的方法构造函数的方法有一些规范： 1）函数名和实例化构造名相同且大写，(PS：非强制，但这么写有助于区分构造函数和 普通函数)； 2）通过构造函数创建对象，必须使用new 运算符。三.原型 我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解：prototype 通过调用构造函数而创建的那个对象的原型对象。使用原型的好处可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。四.继承 继承是面向对象中一个比较核心的概念。其他正统面向对象语言都会用两种方式实现继承：一个是接口实现，一个是继承</summary>
    <published>2015-07-26T12:42:00Z</published>
    <updated>2015-07-26T12:42:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4678656.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4678656.html" />
    <content type="html">ECMAScript 有两种开发模式：1.函数式(过程化)，2.面向对象(OOP)。面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。一．创建对象创建一个对象，然后给这个对象新建属性和方法。构造函数的方法构造函数的方法有一些规范：1）函数名和实例化构造名相同且大写，(PS：非强制，但这么写有助于区分构造函数和普通函数)；2）通过构造函数创建对象，必须使用new 运算符。三.原型我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解：prototype 通过调用构造函数而创建的那个对象的原型对象。使用原型的好处可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。四.继承继承是面向对象中一个比较核心的概念。其他正统面向对象语言都会用两种方式实现继承：一个是接口实现，一个是继承&lt;img src="http://counter.cnblogs.com/blog/rss/4678656" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4678656.html" target="_blank"&gt;js面向对象理解&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4674946.html</id>
    <title type="text">js 时间戳转为日期格式 - jingwhale</title>
    <summary type="text">什么是Unix时间戳(Unix timestamp)： Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。 目前相当一部分操作系统使用32位二进制数字表示时间。此类系统的Unix时间戳最多可以使用到格林威治时间2038年01月19日03时14分07秒（二进制：01111111 11111111 11111111 11111111）。其后一秒，二进制数字会变为10000000 00000000 00000000 00000000，发生溢出错误，造成系统将时间误解为1901年12月13日20时45分52秒。这很可能会引起软件故障，甚至是系统瘫痪。使用64位二进制数字表示时间的系统（最多可以使用到格林威治时间292,277,026,596年12月04日15时30分08秒）则基本不会遇到这类溢出问题。</summary>
    <published>2015-07-24T14:11:00Z</published>
    <updated>2015-07-24T14:11:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4674946.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4674946.html" />
    <content type="html">什么是Unix时间戳(Unix timestamp)： Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。目前相当一部分操作系统使用32位二进制数字表示时间。此类系统的Unix时间戳最多可以使用到格林威治时间2038年01月19日03时14分07秒（二进制：01111111 11111111 11111111 11111111）。其后一秒，二进制数字会变为10000000 00000000 00000000 00000000，发生溢出错误，造成系统将时间误解为1901年12月13日20时45分52秒。这很可能会引起软件故障，甚至是系统瘫痪。使用64位二进制数字表示时间的系统（最多可以使用到格林威治时间292,277,026,596年12月04日15时30分08秒）则基本不会遇到这类溢出问题。&lt;img src="http://counter.cnblogs.com/blog/rss/4674946" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4674946.html" target="_blank"&gt;js 时间戳转为日期格式&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4671853.html</id>
    <title type="text">JS BOM简列 - jingwhale</title>
    <summary type="text">BOM 也叫浏览器对象模型，它提供了很多对象，用于访问浏览器的功能。BOM 缺少规范，每个浏览器提供商又按照自己想法去扩展它，那么浏览器共有对象就成了事实的标准。所以，BOM 本身是没有标准的或者还没有哪个组织去标准它。 window对象 BOM 的核心对象是window，它表示浏览器的一个实例。window 对象处于JavaScript 结构的最顶层，对于每个打开的窗口，系统都会自动为其定义window 对象。 Window 对象表示浏览器中打开的窗口。如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 注释：没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。</summary>
    <published>2015-07-23T13:32:00Z</published>
    <updated>2015-07-23T13:32:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4671853.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4671853.html" />
    <content type="html">BOM 也叫浏览器对象模型，它提供了很多对象，用于访问浏览器的功能。BOM 缺少规范，每个浏览器提供商又按照自己想法去扩展它，那么浏览器共有对象就成了事实的标准。所以，BOM 本身是没有标准的或者还没有哪个组织去标准它。window对象BOM 的核心对象是window，它表示浏览器的一个实例。window 对象处于JavaScript 结构的最顶层，对于每个打开的窗口，系统都会自动为其定义window 对象。Window 对象表示浏览器中打开的窗口。如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。注释：没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。&lt;img src="http://counter.cnblogs.com/blog/rss/4671853" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4671853.html" target="_blank"&gt;JS BOM简列&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4669050.html</id>
    <title type="text">JavaScript跨域 - jingwhale</title>
    <summary type="text">js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。 同源策略阻止从一个域上加载的脚本获取或操作另一个域上的文档属性。也就是说，受到请求的 URL 的域必须与当前 Web 页面的域相同。这意味着浏览器隔离来自不同源的内容，以防止它们之间的操作。JavaScript出于安全方面的考虑，同源策略不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。javascript跨域简单分为以下情况： 1、基于同一父域的子域之间，如：a.c.com和b.c.com 2、基于不同的父域之间，如：www.a.com和www.b.com 3、端口的不同，如：www.a.com:8080和www.a.com:8088 4、协议不同，如：http://www.a.com和https://www.a.com 对于端口和协议的不同，需要通过后台proxy来解决，具体方式如下：  a、在</summary>
    <published>2015-07-22T15:39:00Z</published>
    <updated>2015-07-22T15:39:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4669050.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4669050.html" />
    <content type="html">js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。同源策略阻止从一个域上加载的脚本获取或操作另一个域上的文档属性。也就是说，受到请求的 URL 的域必须与当前 Web 页面的域相同。这意味着浏览器隔离来自不同源的内容，以防止它们之间的操作。JavaScript出于安全方面的考虑，同源策略不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。javascript跨域简单分为以下情况：1、基于同一父域的子域之间，如：a.c.com和b.c.com 2、基于不同的父域之间，如：www.a.com和www.b.com 3、端口的不同，如：www.a.com:8080和www.a.com:8088 4、协议不同，如：http://www.a.com和https://www.a.com 对于端口和协议的不同，需要通过后台proxy来解决，具体方式如下： a、在&lt;img src="http://counter.cnblogs.com/blog/rss/4669050" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4669050.html" target="_blank"&gt;JavaScript跨域&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/jingwhale/p/4656869.html</id>
    <title type="text">深入浅出js事件 - jingwhale</title>
    <summary type="text">事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念是为了解决页面中事件流（事件发生顺序）的问题。 1.事件冒泡 微软提出了名为事件冒泡的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。  因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document  2.事件捕获 网景提出另一种事件流名为事件捕获与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。  上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p  3.W3C事件阶段(event phase)： 当一个DOM事件被触发的时候，他并不是只在它的起源对象上触发一次，而是会经历三个不同的阶段。简而言之：事件一开始从文档的根节点流向目标对象(捕获阶段)，然后在目标对向上被触发(目标阶段)，之后再回溯到文档的根节点(冒泡阶段)如图所示（图</summary>
    <published>2015-07-18T06:43:00Z</published>
    <updated>2015-07-18T06:43:00Z</updated>
    <author>
      <name>jingwhale</name>
      <uri>http://www.cnblogs.com/jingwhale/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/jingwhale/p/4656869.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/jingwhale/p/4656869.html" />
    <content type="html">事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念是为了解决页面中事件流（事件发生顺序）的问题。 1.事件冒泡微软提出了名为事件冒泡的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document 2.事件捕获网景提出另一种事件流名为事件捕获与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。 上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p 3.W3C事件阶段(event phase)：当一个DOM事件被触发的时候，他并不是只在它的起源对象上触发一次，而是会经历三个不同的阶段。简而言之：事件一开始从文档的根节点流向目标对象(捕获阶段)，然后在目标对向上被触发(目标阶段)，之后再回溯到文档的根节点(冒泡阶段)如图所示（图&lt;img src="http://counter.cnblogs.com/blog/rss/4656869" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/jingwhale/p/4656869.html" target="_blank"&gt;深入浅出js事件&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
</feed>