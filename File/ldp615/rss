<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">博客园_鹤冲天</title><subtitle type="text">对月狂饮，惊叹青春过半。顾镜自怜，提眉强作欢颜。</subtitle><id>uuid:b1ecc977-81e1-4fb6-b6e4-d350f4e2e40c;id=60</id><updated>2015-08-10T12:50:57Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><generator>feed.cnblogs.com</generator><entry><id>http://www.cnblogs.com/ldp615/p/quickly-create-instance-of-iequalitycomparer-improvement.html</id><title type="text">快速创建 IEqualityComparer 实例：改进 - 鹤冲天</title><summary type="text">两年前，我写了篇文章《快速创建 IEqualityComparer 和 IComparer 的实例》，文中给出了一个用于快速创建 IEqualityComparer 实例的类 Equality。 在后来的使用中发现了一些不足，在此进行一些改进，以便更好的使用。</summary><published>2013-12-31T15:59:00Z</published><updated>2013-12-31T15:59:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/p/quickly-create-instance-of-iequalitycomparer-improvement.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/p/quickly-create-instance-of-iequalitycomparer-improvement.html" /><content type="html">两年前，我写了篇文章《快速创建 IEqualityComparer&lt;T&gt; 和 IComparer&lt;T&gt; 的实例》，文中给出了一个用于快速创建 IEqualityComparer&lt;T&gt; 实例的类 Equality&lt;T&gt;。在后来的使用中发现了一些不足，在此进行一些改进，以便更好的使用。&lt;img src="http://counter.cnblogs.com/blog/rss/3500254" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/p/quickly-create-instance-of-iequalitycomparer-improvement.html" target="_blank"&gt;快速创建 IEqualityComparer 实例：改进&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/04/11/recursive-lambda-expressions-5.html</id><title type="text">使用 Lambda 表达式编写递归五：推导装配脑袋的 Fix - 鹤冲天</title><summary type="text"> 装配脑袋 给出的 Fix 函数精简到极致： Func&lt;T, TResult&gt; Fix&lt;T, TResult&gt;(Func&lt;Func&lt;T,TResult&gt;, Func&lt;T,TResult&gt;&gt; f) {    return t =&gt; f(Fix(f))(t); } 本文通过 λ 演算导出。</summary><published>2013-04-11T02:31:00Z</published><updated>2013-04-11T02:31:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/04/11/recursive-lambda-expressions-5.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/04/11/recursive-lambda-expressions-5.html" /><content type="html">&lt;img src="http://www.cnblogs.com/images/cnblogs_com/ldp615/469308/t_Print%20Gallery.jpg" class="desc_img"/&gt;&lt;/br&gt;装配脑袋 给出的 Fix 函数精简到极致： &lt;br /&gt;&lt;font color="#008080"&gt;Func&lt;/font&gt;&amp;lt;T, TResult&amp;gt; Fix&amp;lt;T, TResult&amp;gt;(&lt;font color="#008080"&gt;Func&lt;/font&gt;&amp;lt;&lt;font color="#008080"&gt;Func&lt;/font&gt;&amp;lt;T,TResult&amp;gt;, &lt;font color="#008080"&gt;Func&lt;/font&gt;&amp;lt;T,TResult&amp;gt;&amp;gt; f) { &lt;br /&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; t =&amp;gt; f(Fix(f))(t); &lt;br /&gt;} &lt;br /&gt;本文通过 λ 演算导出。&lt;img src="http://counter.cnblogs.com/blog/rss/3013016" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/04/11/recursive-lambda-expressions-5.html" target="_blank"&gt;使用 Lambda 表达式编写递归五：推导装配脑袋的 Fix&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-4.html</id><title type="text">使用 Lambda 表达式编写递归四：实现 Θ 组合子 - 鹤冲天</title><summary type="text"> 上一篇文章已经实现了 Y 组合子。 本文将实现另一个不动点组合子： Θ 组合子。 Θ 组合子也是一个常见不动点组合子，由 阿兰·图灵 发现，也称为图灵不动点组合子： Θ = (λx.λy.(y(x x y))) (λx.λy.(y(x x y))) </summary><published>2013-04-10T12:33:00Z</published><updated>2013-04-10T12:33:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-4.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-4.html" /><content type="html">&lt;img src="http://www.cnblogs.com/images/cnblogs_com/ldp615/469308/t_Fish%20and%20Scales%20-%20small.png" width="147px" class="desc_img"/&gt;&lt;br/&gt;上一篇文章已经实现了 Y 组合子。&lt;br/&gt;本文将实现另一个不动点组合子： Θ 组合子。&lt;br/&gt;Θ 组合子也是一个常见不动点组合子，由 阿兰·图灵 发现，也称为图灵不动点组合子： &lt;br/&gt;Θ = (λx.λy.(y(x x y))) (λx.λy.(y(x x y))) &lt;br/&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/3011273" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-4.html" target="_blank"&gt;使用 Lambda 表达式编写递归四：实现 &amp;Theta; 组合子&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-3.html</id><title type="text">使用 Lambda 表达式编写递归三：实现 Y 组合子 - 鹤冲天</title><summary type="text"> 也许你我都难以理解，为什么有人对她痴迷疯狂，铭记在心中不说，还要刻在身上。 她让人绞尽脑汁，也琢磨不定！她让人心力憔悴，又百般回味！ 她，看似平淡，却深藏玄机！她，貌不惊人，却天下无敌！ 她是谁？她就是...</summary><published>2013-04-10T09:31:00Z</published><updated>2013-04-10T09:31:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-3.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-3.html" /><content type="html">&lt;img src="http://images.cnblogs.com/cnblogs_com/ldp615/469111/o_lambda.png" class="desc_img"/&gt;&lt;br/&gt;也许你我都难以理解，为什么有人对她痴迷疯狂，铭记在心中不说，还要刻在身上。&lt;br/&gt;她让人绞尽脑汁，也琢磨不定！她让人心力憔悴，又百般回味！&lt;br/&gt;她，看似平淡，却深藏玄机！她，貌不惊人，却天下无敌！&lt;br/&gt;她是谁？她就是...&lt;img src="http://counter.cnblogs.com/blog/rss/3010442" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/04/10/recursive-lambda-expressions-3.html" target="_blank"&gt;使用 Lambda 表达式编写递归三：实现 Y 组合子&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-2.html</id><title type="text">使用 Lambda 表达式编写递归二：推断 FIX、g 的类型 - 鹤冲天</title><summary type="text"> 上一章节介绍的 λ 演算是无类型的，对于 FIX、g 我们只知道： 它们都是有独个参数的函数，它们的参数本身也是一个只有单一参数的函数... 基于这种描述，是无法将 FIX、g 转化为 c# 代码的，我们需要推断出 FIX、g 类型。</summary><published>2013-04-09T12:41:00Z</published><updated>2013-04-09T12:41:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-2.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-2.html" /><content type="html">&lt;img src="http://images.cnblogs.com/cnblogs_com/ldp615/469308/t_Stars.gif" class="desc_img"/&gt;&lt;br/&gt;上一章节介绍的 λ 演算是无类型的，对于 FIX、g 我们只知道：&lt;br/&gt;它们都是有独个参数的函数，它们的参数本身也是一个只有单一参数的函数...&lt;br/&gt;基于这种描述，是无法将 FIX、g 转化为 c# 代码的，我们需要推断出 FIX、g 类型。&lt;br/&gt;&lt;img src="http://counter.cnblogs.com/blog/rss/3009060" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-2.html" target="_blank"&gt;使用 Lambda 表达式编写递归二：推断 FIX、g 的类型&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-1.html</id><title type="text">使用 Lambda 表达式编写递归一：前言及基础 - 鹤冲天</title><summary type="text"> 这是一个比较古老的话题，三年半之前，老赵就此写过一篇很文章《使用Lambda表达式编写递归函数》。其中提出了伪递归的概念，提出了自己的解决方式，也引出了装配脑袋 使用不动点组合子 的解决办法。 最近比较轻闲，静下心来学习了下λ演算、不动点组合子的一些理论，并深入思考，略有所悟，在此和大家分享下。 本文及后续章节会用到相当复杂的泛型及 lambda 表达式，请做好相关技术和心理准备。</summary><published>2013-04-09T08:31:00Z</published><updated>2013-04-09T08:31:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-1.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-1.html" /><content type="html">&lt;img src="http://images.cnblogs.com/cnblogs_com/ldp615/469308/t_Drawing%20Hands.gif" class="desc_img"/&gt;&lt;br/&gt;这是一个比较古老的话题，三年半之前，老赵就此写过一篇很文章《使用Lambda表达式编写递归函数》。其中提出了伪递归的概念，提出了自己的解决方式，也引出了装配脑袋 使用不动点组合子 的解决办法。&lt;br/&gt;最近比较轻闲，静下心来学习了下λ演算、不动点组合子的一些理论，并深入思考，略有所悟，在此和大家分享下。&lt;br/&gt;本文及后续章节会用到相当复杂的泛型及 lambda 表达式，请做好相关技术和心理准备。&lt;img src="http://counter.cnblogs.com/blog/rss/3009054" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/04/09/recursive-lambda-expressions-1.html" target="_blank"&gt;使用 Lambda 表达式编写递归一：前言及基础&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2013/03/31/2991304.html</id><title type="text">替代反射调用的几种方式及性能测试 - 鹤冲天</title><summary type="text">园子里和这个话题的相关文章比较多，本文是旧话重提，外加个小的总结。主要因为近期看到很多同事、朋友都已经使用 VS2012 进行 .NET 4.5 开发了，却还在大量使用反射，不知道用新的方式。或有所了解，但又害怕性能不好不敢大胆去用。</summary><published>2013-03-31T09:25:00Z</published><updated>2013-03-31T09:25:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2013/03/31/2991304.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2013/03/31/2991304.html" /><content type="html">园子里和这个话题的相关文章比较多，本文是旧话重提，外加个小的总结。主要因为近期看到很多同事、朋友都已经使用 VS2012 进行 .NET 4.5 开发了，却还在大量使用反射，不知道用新的方式。或有所了解，但又害怕性能不好不敢大胆去用。&lt;img src="http://counter.cnblogs.com/blog/rss/2991304" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2013/03/31/2991304.html" target="_blank"&gt;替代反射调用的几种方式及性能测试&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2012/07/27/http-get-post.html</id><title type="text">也谈 GET 和 POST 的区别 - 鹤冲天</title><summary type="text">上个月，博客园精华区有篇文章《GET 和 POST 有什么区别？及为什么网上的多数答案都是错的》，文中和回复多是对长度限制和 Url 隐藏数据两个问题进行了深究。在我看来这两者都不是重点，特写此文予以讨论。</summary><published>2012-07-27T12:06:00Z</published><updated>2012-07-27T12:06:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2012/07/27/http-get-post.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2012/07/27/http-get-post.html" /><content type="html">上个月，博客园精华区有篇文章《GET 和 POST 有什么区别？及为什么网上的多数答案都是错的》，文中和回复多是对长度限制和 Url 隐藏数据两个问题进行了深究。在我看来这两者都不是重点，特写此文予以讨论。&lt;img src="http://counter.cnblogs.com/blog/rss/2612395" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2012/07/27/http-get-post.html" target="_blank"&gt;也谈 GET 和 POST 的区别&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2012/01/15/orderby-extensions.html</id><title type="text">c# 扩展方法 奇思妙用 高级篇 九：OrderBy(string propertyName, bool desc) - 鹤冲天</title><summary type="text">如题，本文实现 OrderBy(string propertyName, bool desc) 扩展方法，以弥补 Linq 原生排序方法的不足</summary><published>2012-01-15T10:41:00Z</published><updated>2012-01-15T10:41:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2012/01/15/orderby-extensions.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2012/01/15/orderby-extensions.html" /><content type="html">如题，本文实现 OrderBy(string propertyName, bool desc) 扩展方法，以弥补 Linq 原生排序方法的不足&lt;img src="http://counter.cnblogs.com/blog/rss/2322986" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2012/01/15/orderby-extensions.html" target="_blank"&gt;c# 扩展方法 奇思妙用 高级篇 九：OrderBy(string propertyName, bool desc)&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry><entry><id>http://www.cnblogs.com/ldp615/archive/2011/12/11/2284154.html</id><title type="text">Linq：切勿使用 Count() &gt; 0 来判断集合非空 - 鹤冲天</title><summary type="text">如题，使用 Linq 时切勿使用 Count() &gt; 0 来判断集合非空，这样做可能会带来严重的性能问题</summary><published>2011-12-11T12:51:00Z</published><updated>2011-12-11T12:51:00Z</updated><author><name>鹤冲天</name><uri>http://www.cnblogs.com/ldp615/</uri></author><link rel="alternate" href="http://www.cnblogs.com/ldp615/archive/2011/12/11/2284154.html" /><link rel="alternate" type="text/html" href="http://www.cnblogs.com/ldp615/archive/2011/12/11/2284154.html" /><content type="html">如题，使用 Linq 时切勿使用 Count() &gt; 0 来判断集合非空，这样做可能会带来严重的性能问题&lt;img src="http://counter.cnblogs.com/blog/rss/2284154" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/ldp615/archive/2011/12/11/2284154.html" target="_blank"&gt;Linq：切勿使用 Count() &amp;gt; 0 来判断集合非空&lt;/a&gt;，转载请注明。&lt;/p&gt;</content></entry></feed>