<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园_郭明锋</title>
  <subtitle type="text">程序员只做两件事：让代码奏效和让代码洁净</subtitle>
  <id>uuid:0bb2c06b-d269-4a25-bf66-9a76e4d41f13;id=94</id>
  <updated>2015-08-29T03:44:28Z</updated>
  <author>
    <name>郭明锋</name>
    <uri>http://www.cnblogs.com/guomingfeng/</uri>
  </author>
  <generator>feed.cnblogs.com</generator>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-logging-operate.html</id>
    <title type="text">OSharp3.0框架解说系列（6.2）：操作日志与数据日志 - 郭明锋</title>
    <summary type="text">在日志开发中，有些日志记录需求是常规需要的，比如操作日志，数据变更日志，系统异常日志等，我们希望把这些常规需求都集成到OSharp框架当中。有了内置的支持，在做开发的时候，只需要很简单的配置，就可以实现相关需求。 关于三类日志，这里先简要描述一下： 操作日志：粗略描述系统用户（如管理员、业务人员、会员等）对系统的业务操作，只需要说清楚“XXX用户在XXX时间做了XXX操作” 数据日志：有时候，为了追溯用户的业务操作对系统产生的影响，需要记录数据变更细节，这就是数据日志 系统日志：主要记录系统在运行过程中产生的与业务无关的常规或异常的日志信息，这些日志信息通常由系统维护人员或开发人员查看</summary>
    <published>2015-07-27T10:24:00Z</published>
    <updated>2015-07-27T10:24:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-operate.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-operate.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;在日志开发中，有些日志记录需求是常规需要的，比如操作日志，数据变更日志，系统异常日志等，我们希望把这些常规需求都集成到OSharp框架当中。有了内置的支持，在做开发的时候，只需要很简单的配置，就可以实现相关需求。关于三类日志，这里先简要描述一下：操作日志：粗略描述系统用户（如管理员、业务人员、会员等）对系统的业务操作，只需要说清楚“XXX用户在XXX时间做了XXX操作”数据日志：有时候，为了追溯用户的业务操作对系统产生的影响，需要记录数据变更细节，这就是数据日志系统日志：主要记录系统在运行过程中产生的与业务无关的常规或异常的日志信息，这些日志信息通常由系统维护人员或开发人员查看&lt;img src="http://counter.cnblogs.com/blog/rss/4280258" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-operate.html" target="_blank"&gt;OSharp3.0框架解说系列（6.2）：操作日志与数据日志&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp3-new-feature-preview.html</id>
    <title type="text">OSharp3.0框架解说系列：新版本说明及新功能规划预览 - 郭明锋</title>
    <summary type="text">经过最近一段时间的努力，OSharp3.0新增了不少功能，如框架初始化流程，多数据库多上下文的支持，分类日志记录等，包含功能权限与数据权限的权限系统正在设计当中，基于实体配置的缓存系统，在计划当中。 从OSharp3.0开始，远离喧嚣的开源环境，由几个志同道合的小伙伴沉下心来，认真的去继续开发OSharp框架。做出变更如下： OSharp3.0之前的源代码，仍然在github.com上面进行托管，但不再积极更新。 OSharp3.0及之后的源代码，仅在团队成员之间流通。 nuget 上面的类库，将持续更新，提供“非加密的dll类库文件，pdb调试文件，xml注释文件”的方式提供使用，有心人仍然可以通过各种途径很容易阅读到项目的源代码的。 配合OSharp3.0的新增功能，本系列博客将继续更新，对新增功能将会的详尽的技术描述，欢迎喜欢本系列的博友继续关注。</summary>
    <published>2015-07-05T12:15:00Z</published>
    <updated>2015-07-05T12:15:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp3-new-feature-preview.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp3-new-feature-preview.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;经过最近一段时间的努力，OSharp3.0新增了不少功能，如框架初始化流程，多数据库多上下文的支持，分类日志记录等，包含功能权限与数据权限的权限系统正在设计当中，基于实体配置的缓存系统，在计划当中。从OSharp3.0开始，远离喧嚣的开源环境，由几个志同道合的小伙伴沉下心来，认真的去继续开发OSharp框架。做出变更如下：OSharp3.0之前的源代码，仍然在github.com上面进行托管，但不再积极更新。OSharp3.0及之后的源代码，仅在团队成员之间流通。nuget 上面的类库，将持续更新，提供“非加密的dll类库文件，pdb调试文件，xml注释文件”的方式提供使用，有心人仍然可以通过各种途径很容易阅读到项目的源代码的。配合OSharp3.0的新增功能，本系列博客将继续更新，对新增功能将会的详尽的技术描述，欢迎喜欢本系列的博友继续关注。&lt;img src="http://counter.cnblogs.com/blog/rss/4621455" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp3-new-feature-preview.html" target="_blank"&gt;OSharp3.0框架解说系列：新版本说明及新功能规划预览&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-logging-design.html</id>
    <title type="text">【开源】OSharp框架解说系列（6.1）：日志系统设计 - 郭明锋</title>
    <summary type="text"> 日志记录对于一个系统而言，重要性不言而喻。日志记录功能在系统开发阶段，往往容易被忽略。因为开发阶段，程序可以调试，可以反复的运行以查找问题。但在系统进入正常的运行维护阶段，特别是在进行审计统计的时候，追踪问题的时候，在追溯责任的时候，在系统出错的时候等等场景中，日志记录才会显示出它不可替代的作用。记录的日志，平时看似累赘，只有在需要的时候，才会拍大腿后悔当初为什么不把日志记录得详细些。日志系统，是一个非常基础的系统，但由于需求的复杂性，各个场景需要的日志分类，来源，输出方式各有不同，日志系统又是一个相对复杂的系统。下面我们就来解说一下，OSharp开发框架的日志系统设计中，怎样来应对这些复杂性。</summary>
    <published>2015-02-09T02:34:00Z</published>
    <updated>2015-02-09T02:34:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-design.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-design.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;日志记录对于一个系统而言，重要性不言而喻。日志记录功能在系统开发阶段，往往容易被忽略。因为开发阶段，程序可以调试，可以反复的运行以查找问题。但在系统进入正常的运行维护阶段，特别是在进行审计统计的时候，追踪问题的时候，在追溯责任的时候，在系统出错的时候等等场景中，日志记录才会显示出它不可替代的作用。记录的日志，平时看似累赘，只有在需要的时候，才会拍大腿后悔当初为什么不把日志记录得详细些。日志系统，是一个非常基础的系统，但由于需求的复杂性，各个场景需要的日志分类，来源，输出方式各有不同，日志系统又是一个相对复杂的系统。下面我们就来解说一下，OSharp开发框架的日志系统设计中，怎样来应对这些复杂性。&lt;img src="http://counter.cnblogs.com/blog/rss/4275473" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-logging-design.html" target="_blank"&gt;【开源】OSharp框架解说系列（6.1）：日志系统设计&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-data-entity.html</id>
    <title type="text">【开源】OSharp框架解说系列（5.2）：EntityFramework数据层实现 - 郭明锋</title>
    <summary type="text"> 数据层设计中，我们主要设计了数据对对外开放的 实体基类EntityBase，单元操作接口IUnitOfWork 和 数据仓储接口IRepository，下面我们来解说怎样来使用 EntityFramework 对这些数据访问需求进行实现。EntityFramework 的实现中，我们不仅要实现以上设计的两个接口，还要做以下几件事：1.设计一个与 业务实体解耦的 EntityFramework数据上下文类。2.设计 实体加载方案，将 业务实体 加载到上下文中。3.设计数据迁移方案，对 EntityFramework 的运行环境进行初始化。4.使用 已初始化的上下文 实现 数据仓储操作</summary>
    <published>2015-02-05T08:55:00Z</published>
    <updated>2015-02-05T08:55:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-data-entity.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-data-entity.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;数据层设计中，我们主要设计了数据对对外开放的 实体基类EntityBase&lt;TKey&gt;，单元操作接口IUnitOfWork 和 数据仓储接口IRepository&lt;TEntity, TKey&gt;，下面我们来解说怎样来使用 EntityFramework 对这些数据访问需求进行实现。EntityFramework 的实现中，我们不仅要实现以上设计的两个接口，还要做以下几件事：1.设计一个与 业务实体解耦的 EntityFramework数据上下文类。2.设计 实体加载方案，将 业务实体 加载到上下文中。3.设计数据迁移方案，对 EntityFramework 的运行环境进行初始化。4.使用 已初始化的上下文 实现 数据仓储操作&lt;img src="http://counter.cnblogs.com/blog/rss/4244810" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-data-entity.html" target="_blank"&gt;【开源】OSharp框架解说系列（5.2）：EntityFramework数据层实现&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-data-design.html</id>
    <title type="text">【开源】OSharp框架解说系列（5.1）：EntityFramework数据层设计 - 郭明锋</title>
    <summary type="text"> 数据层设计真是一个百说不厌的话题，大系统说并发量，说高性能；小系统追求开发效率，易维护性各有各的追求。 OSharp 开发框架的定位是中小系统， 数据层的开发效率与易用性的权重就比较高了，所以，使用ORM当然是首选。在 .net 环境下，有众多的闭源的开源的优秀的ORM组件，从各方便对比来看，EntityFramework 是不二之选。一提起 EntityFramework，不少同学又要蠢蠢欲动来吐槽其性能了。其实，经过几个版本的更新换代，现在的稳定版 EntityFramework 6 已经相当好用了，nuget 上截止到目前 “8,830,918 total downloads” 已经足够能说明问题了，EntityFramework 在整个 .net 世界是相当受欢迎的。不过，不管哪个技术平台，能不能用好一个技术与技术水平有很大的关系，如果没追求，随处的 select * from</summary>
    <published>2015-01-29T01:43:00Z</published>
    <updated>2015-01-29T01:43:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-data-design.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-data-design.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;数据层设计真是一个百说不厌的话题，大系统说并发量，说高性能；小系统追求开发效率，易维护性各有各的追求。　　OSharp 开发框架的定位是中小系统， 数据层的开发效率与易用性的权重就比较高了，所以，使用ORM当然是首选。在 .net 环境下，有众多的闭源的开源的优秀的ORM组件，从各方便对比来看，EntityFramework 是不二之选。一提起 EntityFramework，不少同学又要蠢蠢欲动来吐槽其性能了。其实，经过几个版本的更新换代，现在的稳定版 EntityFramework 6 已经相当好用了，nuget 上截止到目前 “8,830,918 total downloads” 已经足够能说明问题了，EntityFramework 在整个 .net 世界是相当受欢迎的。不过，不管哪个技术平台，能不能用好一个技术与技术水平有很大的关系，如果没追求，随处的 select * from&lt;img src="http://counter.cnblogs.com/blog/rss/4244695" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-data-design.html" target="_blank"&gt;【开源】OSharp框架解说系列（5.1）：EntityFramework数据层设计&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-layer.html</id>
    <title type="text">【开源】OSharp框架解说系列（4）：架构分层及IoC - 郭明锋</title>
    <summary type="text"> 一个好的分层式结构，可以使得开发人员的分工更加明确。一旦定义好各层次之间的接口，负责不同逻辑设计的开发人员就可以分散关注，齐头并进。 OSharp开发框架约定的分层方案，依然是传统的三层（数据层 - 业务层 - 展现层）分层方式，但也有自己的特点：使用了三层分层方式，但并不严格遵守传统三层的“各层职责极其分明”的约定；参考了“领域驱动设计”的一些思想，但为了保证性能，并不使用 DDD 的聚合模型。</summary>
    <published>2015-01-23T22:46:00Z</published>
    <updated>2015-01-23T22:46:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-layer.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-layer.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;一个好的分层式结构，可以使得开发人员的分工更加明确。一旦定义好各层次之间的接口，负责不同逻辑设计的开发人员就可以分散关注，齐头并进。OSharp开发框架约定的分层方案，依然是传统的三层（数据层 - 业务层 - 展现层）分层方式，但也有自己的特点：使用了三层分层方式，但并不严格遵守传统三层的“各层职责极其分明”的约定；参考了“领域驱动设计”的一些思想，但为了保证性能，并不使用 DDD 的聚合模型。&lt;img src="http://counter.cnblogs.com/blog/rss/4227347" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-layer.html" target="_blank"&gt;【开源】OSharp框架解说系列（4）：架构分层及IoC&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-extensions.html</id>
    <title type="text">【开源】OSharp框架解说系列（3）：扩展方法 - 郭明锋</title>
    <summary type="text"> 本文定义（收集）了大量实用的扩展方法，从泛型、字符串、类型、随机数、参数检查、Expression表达式、集合类操作等方面进行分类解说。 扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。 扩展方法是一种特殊的静态方法，但可以像扩展类型上的实例方法一样进行调用。 对于用 C# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。</summary>
    <published>2015-01-11T16:08:00Z</published>
    <updated>2015-01-11T16:08:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-extensions.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-extensions.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;本文定义（收集）了大量实用的扩展方法，从泛型、字符串、类型、随机数、参数检查、Expression表达式、集合类操作等方面进行分类解说。扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。 扩展方法是一种特殊的静态方法，但可以像扩展类型上的实例方法一样进行调用。 对于用 C# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中实际定义的方法之间没有明显的差异。&lt;img src="http://counter.cnblogs.com/blog/rss/4216985" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-extensions.html" target="_blank"&gt;【开源】OSharp框架解说系列（3）：扩展方法&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-easyui-opera.html</id>
    <title type="text">【开源】OSharp框架解说系列（2.2）：EasyUI复杂布局及数据操作 - 郭明锋</title>
    <summary type="text"> 本篇将继续深入EasyUI的后台页面构建，使用前面定义的父视图（_DataGridLayout.cshtml）进行复杂表格布局，以及前端向后端提交数据的一些操作细节</summary>
    <published>2015-01-11T10:00:00Z</published>
    <updated>2015-01-11T10:00:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-opera.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-opera.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;本篇将继续深入EasyUI的后台页面构建，使用前面定义的父视图（_DataGridLayout.cshtml）进行复杂表格布局，以及前端向后端提交数据的一些操作细节&lt;img src="http://counter.cnblogs.com/blog/rss/4214389" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-opera.html" target="_blank"&gt;【开源】OSharp框架解说系列（2.2）：EasyUI复杂布局及数据操作&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-easyui-view.html</id>
    <title type="text">【开源】OSharp框架解说系列（2.1）：EasyUI的后台界面搭建及极致重构 - 郭明锋</title>
    <summary type="text"> 以前在用easyui的时候，每个页面都得从0做起，或者不厌其烦地由以前的页面通过“复制-粘贴”的方式来修改，久页久之，就会造成页面庞大且难以维护。其实，前端的html,javascript代码与后端的代码是一样的，通过一定的组织，把重复的代码抽离出来，同样也通过达到很好的复用率。而MVC的天生的Layout布局与分布视图（Partial View），就是对重复代码抽离的需求有很好的支持。多动脑，多总结，前端的代码也同样能像后台C#代码一样重构，重构到极致。</summary>
    <published>2015-01-09T13:43:00Z</published>
    <updated>2015-01-09T13:43:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-view.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-view.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;以前在用easyui的时候，每个页面都得从0做起，或者不厌其烦地由以前的页面通过“复制-粘贴”的方式来修改，久页久之，就会造成页面庞大且难以维护。其实，前端的html,javascript代码与后端的代码是一样的，通过一定的组织，把重复的代码抽离出来，同样也通过达到很好的复用率。而MVC的天生的Layout布局与分布视图（Partial View），就是对重复代码抽离的需求有很好的支持。多动脑，多总结，前端的代码也同样能像后台C#代码一样重构，重构到极致。&lt;img src="http://counter.cnblogs.com/blog/rss/4212862" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-easyui-view.html" target="_blank"&gt;【开源】OSharp框架解说系列（2.1）：EasyUI的后台界面搭建及极致重构&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/guomingfeng/p/osharp-overall-design.html</id>
    <title type="text">【开源】OSharp框架解说系列（1）：总体设计 - 郭明锋</title>
    <summary type="text">OSharp是一个依赖于EntityFramework，专注于业务数据模型与EntityFramework解耦的适用于中小型项目开发的（插件式）框架。OSharp将支持基于OSGi.NET的插件式开发，但我们还是会从非插件式讲起，详细了解OSharp开发框架的方方面面。在本系列中，将会讲解到不少非常实用的技术与编码技巧，欢迎关注。</summary>
    <published>2015-01-08T13:34:00Z</published>
    <updated>2015-01-08T13:34:00Z</updated>
    <author>
      <name>郭明锋</name>
      <uri>http://www.cnblogs.com/guomingfeng/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/guomingfeng/p/osharp-overall-design.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/guomingfeng/p/osharp-overall-design.html" />
    <content type="html">&lt;img src="http://images.cnitblog.com/blog/87201/201501/111502368903292.png" class="desc_img"/&gt;OSharp是一个依赖于EntityFramework，专注于业务数据模型与EntityFramework解耦的适用于中小型项目开发的（插件式）框架。OSharp将支持基于OSGi.NET的插件式开发，但我们还是会从非插件式讲起，详细了解OSharp开发框架的方方面面。在本系列中，将会讲解到不少非常实用的技术与编码技巧，欢迎关注。&lt;img src="http://counter.cnblogs.com/blog/rss/4197206" width="1" height="1" alt=""/&gt;&lt;br/&gt;&lt;p&gt;本文链接：&lt;a href="http://www.cnblogs.com/guomingfeng/p/osharp-overall-design.html" target="_blank"&gt;【开源】OSharp框架解说系列（1）：总体设计&lt;/a&gt;，转载请注明。&lt;/p&gt;</content>
  </entry>
</feed>